[{"title":"极客大挑战2024—Part1","url":"/2025/07/07/极客大挑战2024—Part1/WP1/","content":"\n# Hello_re\n\n​\tUPX壳，修改了大写标志位，010Editor打开文件修改`SYC0`为`UPX0`即可成功使用工具脱壳。然后打开程序，很明显的密钥+下标异或加密，但是正常解密后分析密钥应该是运行时修改过了，所以动调看一下真正的密钥。\n\n​\t因为有模8的操作，我们确定新密钥的前8位为所需。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250701150024569.png\" alt=\"image-20250701150024569\">\n\n```python\ndata = [0,1,2,52,3,96,47,28,107,15,9,24,45,62,60,2,17,123,39,58,41,48,96,26,8,52,63,100,33,106,122,48]\nkey = [83, 89, 67, 76, 79, 86, 69, 82]\nflag = \"\"\nfor i in range(len(data)):\n    flag += chr(data[i] ^ i ^ key[i%8])\nprint(flag) \n#SYC{H3lI0_@_new_R3vers3_Ctf3r!!}\n```\n\n​\t666，原来是我的IDA识别错误（字符串识别有问题），逆序过来就是正确的KEY。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250701151252865.png\" alt=\"image-20250701151252865\">\n\n\n\n\n\n\n\n\n\n# 先来一道签到题\n\n​\t给了一个`.s`后缀文件，这是用汇编语言编写的源代码文件，这是考察汇编基础了！\n\n​\t很显然，奇数位异或7，偶数位减5。\n\n```assembly\n.L3:\n    movl    -84(%rbp), %eax          ;取第i组\n    movl    %eax, %ecx               \n    shl     %ecx                     ;乘以2等于真正下标\n    movzbl  (%rdi,%rcx), %eax        ;取字符，数组操作\n    xorb    $7, %al                  \n    movb    %al, (%rdi,%rcx)          ;更新\n    movzbl  1(%rdi,%rcx), %eax        ;取后一位字符\n    subb    $5, %al                    \n    movb    %al, 1(%rdi,%rcx)       \n    addl    $1, -84(%rbp)\n.L2:\n    movl    -84(%rbp), %eax\n    imull   $2, %eax                  ;每两位一组\n    cmpl    $36, %eax                 \n    jl      .L3\n```\n\n```python\ndata = \"TTDv^jrZu`Gg6tXfi+pZojpZSjXmbqbmt.&x\"\nfor i in range(len(data)):\n    tmp = ord(data[i])\n    if i % 2 == 0:\n        tmp = tmp ^ 7;\n    else:\n        tmp = tmp + 5;\n    print(chr(tmp), end=\"\")\n```\n\n\n\n# 也许你也听jay\n\n​\t源代码的txt文本，变量名混淆过，0、o和O在混淆，不过我们又**sublime**配上神奇的插件**Word Highlight**，能够自动识别，当然也可以自己使用编辑器的**寻找替换**功能，换成易懂的代码。\n\n​\t直接写代码。\n\n```python\nENC_URL = [0x96, 0xa1, 0xa0, 0x9b, 0x9b, 0x5f, 0x49, 0x46, 0x85, 0x82, 0x53, 0x95, 0x7d, 0x36, 0x8d, 0x74, 0x82, 0x88, 0x46, 0x7a, 0x81, 0x65, 0x80, 0x6c, 0x78, 0x2f, 0x6b, 0x6a, 0x27, 0x50, 0x61, 0x38, 0x3f, 0x37, 0x33, 0xf1, 0x27, 0x32, 0x34, 0x1f, 0x39, 0x23, 0xde, 0x1c, 0x17, 0xd4]\n\nfor i in range(len(ENC_URL)):\n    ENC_URL[i] -= 0x5D - i\n    ENC_URL[i] += 47 + i + 1\n    ENC_URL[i] ^= i + 1\n    print(chr(ENC_URL[i]), end='')\n#https://am1re-sudo.github.io/Coisni ，后面有一些无用的字节\n```\n\n​\t访问不存在，去找**am1re-sudo**的仓库，看到另一个项目**[Coisni.github.io](https://github.com/Am1re-sudo/Coisni.github.io)**的**index.html**文件，打开后会有音乐哦。一点点翻，发现密文、KEY和RC4关键字，那就赛博厨子一把梭哈。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250701155638301.png\" alt=\"image-20250701155638301\">\n\n\n\n\n\n# 让我康康你的调试\n\n​\tIDA打开，先异或0x14，再在**sub_14A6**函数加密，其中开头的**sub_11C9**函数是RC4的KSA（利用Key生成S盒），后面是PRGA（利用S盒生成密钥流）。标准RC4，密钥为字符串**syclover**，唯一需要注意的就是，IDA反编译的容易大小端错误，逆序一下。\n\n​\t然后赛博厨子一把梭。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250701161018271.png\" alt=\"image-20250701161018271\">\n\n```python\nDATA1 = \"A67A02C9047D5B94\"\nDATA2 = \"7EF9680DBC980739\"\nDATA3 = \"7104F81698BFBD08\"\nDATA4 = \"61DB8498B686155F\"\nenc = \"\"\nfor i in range(len(DATA1)-2, -1, -2):\n    enc += DATA1[i:i+2]\nfor i in range(len(DATA2)-2, -1, -2):\n    enc += DATA2[i:i+2]\nfor i in range(len(DATA3)-2, -1, -2):\n    enc += DATA3[i:i+2]\nfor i in range(len(DATA4)-2, -1, -2):\n    enc += DATA4[i:i+2]\nprint(enc+\"6D\")\n```\n\n\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250701161059584.png\" alt=\"image-20250701161059584\">\n\n\n\n\n\n# 我勒个z3啊\n\n​\tIDA打开，看到**sub_401B7B**函数，是对第一次输入的约束，代码很清楚，直接写脚本。\n\n```python\nstr2 = [42, 14, 14, 20, 63, 63, 63, 38, 17, 10, 21, 21, 14, 23, 16, 14]\na0123456789abcd = \"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ?_\"\nfor i in range(len(str2)):\n    print(a0123456789abcd[str2[i]], end=\"\")\t#Geek___Challenge\n```\n\n​\t看到**sub_401AAC**函数，里面的**sub_4019EB**函数，每4位一组，从0开始，第i组左移（i+1）位。\n\n```c\n__int64 __fastcall sub_4019EB(char *Myflag2)\n{\n  __int64 result; // rax\n  char v2; // [rsp+3h] [rbp-Dh]\n  int k; // [rsp+4h] [rbp-Ch]\n  int j; // [rsp+8h] [rbp-8h]\n  int i; // [rsp+Ch] [rbp-4h]\n\n  for ( i = 0; i <= 7; ++i )\n  {\n    for ( j = 0; ; ++j )\n    {\n      result = (unsigned int)j;\n      if ( j >= i )\n        break;\n      v2 = Myflag2[4 * i];\n      for ( k = 0; k <= 2; ++k )\n        Myflag2[4 * i + k] = Myflag2[4 * i + 1 + k];\n      Myflag2[4 * i + 3] = v2;\n    }\n  }\n  return result;\n}\n```\n\n\n\n​\t看到函数**sub_40179A**，考察Z3求解。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250701162542314.png\" alt=\"image-20250701162542314\">\n\n```python\ndword_4040A0 = [411, 275, 393, 457, 592, 1334, 1246, 444, 1051, 1828, 1744, 1185, 1605, 1141, 1226, 1676, 997, 455, 829, 1463, 653, 580, 782, 657, 625, 769, 1119, 1135, 1303, 1054, 1062, 1205]\n\nfrom z3 import *\n\nEn_flag = [Int(f\"En_flag{i}\") for i in range(32)]\n\nconstraints = [And(En_flag[i] >= 0, En_flag[i] <= 255) for i in range(32)]\n\nfor i in range(0, 32, 4):\n    constraints.append(\n        En_flag[i] + 8 * En_flag[i + 1] + 6 * En_flag[i + 2] + En_flag[i + 3] == dword_4040A0[i]\n    )\n    constraints.append(\n        En_flag[i + 1] + 8 * En_flag[i + 2] + 6 * En_flag[i + 3] + En_flag[i] == dword_4040A0[i + 1]\n    )\n    constraints.append(\n        En_flag[i + 2] + 8 * En_flag[i + 3] + 6 * En_flag[i] + En_flag[i + 1] == dword_4040A0[i + 2]\n    )\n    constraints.append(\n        En_flag[i + 3] + 8 * En_flag[i] + 6 * En_flag[i + 1] + En_flag[i + 2] == dword_4040A0[i + 3]\n    )\n\nsolver = Solver()\nsolver.add(constraints)\n\n# 求解\nif solver.check() == sat:\n    model = solver.model()\n    result = [model.evaluate(En_flag[i]).as_long() for i in range(32)]\n    print(\"解为:\", result)\nelse:\n    print(\"无解\")\n    \n    \n#解为: [23, 40, 7, 26, 29, 3, 69, 125, 111, 9, 125, 118, 99, 126, 74, 54, 112, 89, 28, 5, 25, 63, 9, 70, 111, 26, 43, 48, 58, 102, 60, 69]\n```\n\n\n\n最后解**sub_401AAC**函数。\n\n```python\nMyflag2 = [23, 40, 7, 26, 29, 3, 69, 125, 111, 9, 125, 118, 99, 126, 74, 54, 112, 89, 28, 5, 25, 63, 9, 70, 111, 26, 43, 48, 58, 102, 60, 69]\nMyflag1 = \"Geek___Challenge\"\n\nfor i in range(len(Myflag2)-1, -1, -1):\n    Myflag2[i] ^= ord(Myflag1[(47 - i) % 16]) ^ i\n    Myflag2[i] ^= Myflag2[(i-1)%len(Myflag2)]\n\nfor i in range(0, len(Myflag2), 4):\n    for j in range(i//4):\n        Myflag2[i], Myflag2[i + 1], Myflag2[i + 2], Myflag2[i + 3] = Myflag2[i + 3], Myflag2[i], Myflag2[i + 1], \\\n        Myflag2[i + 2]\n\n\nfor i in range(len(Myflag2)):\n    print(chr(Myflag2[i]), end=\"\")\t#SYC{Wow!!_Y0u_4r3_9o0d_At_r3$!!}\n```\n\n\n\n# ezzzz\n\n​\t附件链接没了，太久远了，2024年底开的复习平台，现在已经无了。就看看别人的WP吧，好像是apk题，很纯的tea加密，java代码如下。\n\n```java\nimport java.beans.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        int[] enc={0xf1f186b2, 0x5a96c782,\n                0xe6c63a0b, 0x70b61b5c,\n                0xed6bf848, 0x89700d6b,\n                0x9381b5c, 0xcb2f24fa,\n                0xb1c79e79, 0x6d822d9c,\n                0xdcc55f76, 0xf780e75,\n                0xd65c4af, 0xb89084a9,\n                0xe978c382, 0x7a8dd810,\n                0x91f28df3, 0xa84dbaca,\n                0xb4d75f75, 0xf19af8e5,\n                0xb90f80fc, 0xfc10a5c3,\n                0xd20679fb, 0x2bc734c8,\n                0xccb31c92, 0x1ac52ad3,\n                0xe7f922b7, 0x2e24d923,\n                0xfb4ce9f5, 0x3548a9e5,\n                0x71ebc25a, 0xdf38862e,\n                0x10059186, 0x32750946,\n                0x3dd4d54c, 0x905abc36,\n                0xc26d5312, 0xd2cd42c0,\n                0x772d99e5, 0xcd4c466,\n                0x5c3178d6, 0x3a7ffe71,\n                0xada251c0, 0x70568d5a,\n                0x5798c292, 0x1ec0f7fc,\n                0x3ae9d841, 0x84607629,\n                0x30ca6a2d, 0xccef51d2,\n                0xa1a80854, 0x91b0f82d,\n                0x686ca347, 0x74c52d0f,\n                0xf26449f, 0xc28d362c,\n                0x86f3311b, 0x8adc4fb1,\n                0xa4497e34, 0xe0f0915d};\n        int[] data = new int[2];\n        for(int j=0;j<60;j+=2)\n        {\n            data[0]=enc[j];\n            data[1]=enc[j+1];\n            int[] res=Enc.encrypt(data);\n            System.out.print((char)res[0]);\n            System.out.print((char)res[1]);\n        }\n    }\n}\nclass Enc {\n    private static final int DELTA = -1640531527;\n\n    public static int[] encrypt(int[] iArr) {\n\n        int[] iArr2 = new int[4];\n        for (int i2 = 0; i2 < 4; i2++) {\n            iArr2[i2] = \"GEEK\".charAt(i2);\n        }\n        int[] iArr3=iArr;\n        decrypt(iArr3, iArr2);\n\n        return iArr3;\n\n    }\n    private static void decrypt(int[] iArr, int[] iArr2) {\n        int i = iArr[0];\n        int i2 = iArr[1];\n        int i3 = -957401312; // 初始化值，等于 32 * -1640531527\n\n        for (int i4 = 31; i4 >= 0; i4--) { // 反向迭代\n            i2 -= ((((i << 4) ^ (i >> 5)) + i) ^ (iArr2[(i3 >>> 11) & 3] + i3)) ^ (i3 + i4);\n            i3 += 1640531527;\n            i -= ((((i2 << 4) ^ (i2 >> 5)) + i2) ^ (iArr2[i3 & 3] + i3)) ^ (i3 + i4);\n        }\n\n        iArr[0] = i;\n        iArr[1] = i2;\n    }\n}\n```\n\n\n\n\n\n# CPP_flower\n\n​\tIDA打开，还看不到主逻辑。通过字符串搜索到指令部分，但是无法反编译，往上面翻一点点就会发现有个`jnz+jz`的花指令，去了之后还有，慢慢去吧。\n\n​\t看到一个新见的花指令形式，分析一下，**A39D9C**处调用函数，将返回地址**A39DA1**压栈，当前ESP指向。**push ebp**是**ESP-4**，并且EBP压栈，也就是在**A39DA7**执行完后，`[esp]`是指向EBP，而`[esp+4]`指向的是返回地址。所以返回地址被修改到了**A39DB3**，中间全部可以**nop**掉，或者把**call**改为**jmp**，然后nop掉中间的部分（不如全nop）。\n\n```assembly\n.text:00A39D9C                 call    sub_A39DA6\n.text:00A39DA1                 call    near ptr 4B4BA82h\n.text:00A39DA1 sub_A39D10      endp ; sp-analysis failed\n.text:00A39DA1\n.text:00A39DA6\n.text:00A39DA6 ; =============== S U B R O U T I N E =======================================\n.text:00A39DA6\n.text:00A39DA6 ; Attributes: bp-based frame\n.text:00A39DA6\n.text:00A39DA6 sub_A39DA6      proc near               ; CODE XREF: sub_A39D10+8C↑p\n.text:00A39DA6                 push    ebp\n.text:00A39DA7                 mov     ebp, esp\n.text:00A39DA9                 db      36h\t\t\t\t\t\n.text:00A39DA9                 add     dword ptr [esp+4], 12h\n.text:00A39DAF                 mov     esp, ebp\n.text:00A39DB1                 pop     ebp\n.text:00A39DB2                 retn\n.text:00A39DB2 sub_A39DA6      endp\n.text:00A39DB2\n.text:00A39DB3 ; ---------------------------------------------------------------------------\n.text:00A39DB3                 mov     esi, esp\n```\n\n​\t这是一段内存初始化，以前直接忽视过去了，没搞清楚。`edi`表示内存块起始地址，`ecx`表示内存块大小，单位是`dword`，`eax`表示初始化值。\n\n```assembly\n\t\t\t\t\t\t\tlea     edi, [ebp+var_164]\n.text:00A39D30                 mov     ecx, 56h\n.text:00A39D35                 mov     eax, 0CCCCCCCCh\n.text:00A39D3A                 rep stosd\n```\n\n​\t不会了啊，栈一直平不了，反编译也不行，如下代码处。后面我问**ChatGpt**，为什么还没有到函数未，IDA就放弃分析了？\n\n> ## 🧠 IDA 函数分析原理概述\n>\n> IDA 在分析函数（自动识别、跟踪、反汇编、恢复栈变量等）时，主要依赖三个核心机制：\n>\n> ### 1. **控制流分析（Control Flow Analysis）**\n>\n> - 从入口地址开始，沿着 `call/jmp/ret` 追踪所有可能执行的指令路径\n> - 构建控制流图（CFG），用于识别函数边界、代码块、调用关系\n>\n> ### 2. **栈指针追踪（ESP Tracking / SP Analysis）**\n>\n> - IDA 会模拟 `esp`（或在 x64 下 `rsp`）的变化\n> - 它跟踪所有栈相关指令：`push/pop`, `sub/add esp`, `call`, `ret` 等\n> - 用于判断局部变量偏移、参数传递、返回地址位置\n>\n> ### 3. **可达性判断（Code Reachability）**\n>\n> - 如果某段指令既没有跳转到它，也不跳转出去，IDA可能判定它是“孤立代码”\n> - 比如大量 `nop`，或字节无法反汇编成合法指令，IDA就不把它算进函数\n\n​\t虽然没有完全理解，但是我想到，可能是之前的花指令没改完的时候IDA分析异常后，就不分析了。\n\n```assembly\n\t\t\t\t\t\t\tcall    sub_A314B0\n.text:00A39D98                 mov     byte ptr [ebp+var_4], 1\n.text:00A39D98 sub_A39D10      endp ; sp-analysis failed\t\t\t\t;就是这里无法分析下去了。\n.text:00A39D98\n.text:00A39D9C                 nop\n.text:00A39D9D                 nop\n.text:00A39D9E                 nop\n.text:00A39D9F                 nop\n.text:00A39DA0                 nop\n.text:00A39DA1                 nop\n.text:00A39DA2                 nop\n.text:00A39DA3                 nop\n.text:00A39DA4                 nop\n.text:00A39DA5                 nop\n.text:00A39DA6                 nop\n.text:00A39DA7                 nop\n.text:00A39DA8                 nop\n.text:00A39DA9                 nop\n.text:00A39DAA                 nop\n.text:00A39DAB                 nop\n.text:00A39DAC                 nop\n.text:00A39DAD                 nop\n.text:00A39DAE                 nop\n.text:00A39DAF                 nop\n.text:00A39DB0                 nop\n.text:00A39DB1                 nop\n.text:00A39DB2                 nop\n.text:00A39DB3                 mov     esi, esp\n```\n\n​\t最后我检查了一遍没花指令了，重新在**sub_A39D10**函数头按**U**键，再按**C**键，最后按**P**、**F5**就又可以反编译了。\n\n​\t函数有点复杂，各种乱七八糟的东西，静态看不太懂。IDA反编译C++还是有点太难了，不太能看，这个时候我都建议去看汇编语句，不见得会比这个困难！\n\n```c\nint __cdecl main(int argc, const char **argv, const char **envp)\n{\n  int v3; // eax\n  __int64 Myflag; // rax\n  _DWORD *v5; // esi\n  int v6; // eax\n  int v8; // [esp-8h] [ebp-23Ch]\n  _DWORD v9[41]; // [esp+2Ch] [ebp-208h] BYREF\n  int v10; // [esp+104h] [ebp-130h]\n  _DWORD Buf2[52]; // [esp+110h] [ebp-124h] BYREF\n  int i; // [esp+1E0h] [ebp-54h]\n  _BYTE v13[36]; // [esp+1ECh] [ebp-48h] BYREF\n  _BYTE v14[20]; // [esp+210h] [ebp-24h] BYREF\n  int v15; // [esp+230h] [ebp-4h]\n  int savedregs; // [esp+234h] [ebp+0h] BYREF\n\n  sub_A31127(0x10u);\n  sub_A311C2(v14);\n  v15 = 0;\n  srand(0x7DE9u);\n  sub_A31519();\n  sub_A314B0(v13);\n  LOBYTE(v15) = 1;\n  v3 = sub_A3138E(std::cout, \"give your input:\");\n  std::ostream::operator<<(v3, sub_A31073);\n  sub_A31519();\n  Myflag = sub_A313F7(std::cin, (int)v13);\n  if ( sub_A3181B(v13, HIDWORD(Myflag)) == dword_A46004 )\n  {\n    for ( i = 0; i < dword_A46004; ++i )\n    {\n      rand();\n      v9[0] = sub_A31519() % 255;\n      sub_A312E4(v9);\n    }\n    for ( i = 0; i < dword_A46004; ++i )\n    {\n      v5 = (_DWORD *)sub_A3128A(i);\n      v10 = *v5 ^ *(char *)sub_A31113(i);\n      Buf2[i] = v10;\n    }\n    if ( !j_memcmp(&unk_A42C30, Buf2, 4 * dword_A46004) )\n      v6 = sub_A3138E(std::cout, \"you get it\");\n    else\n      v6 = sub_A3138E(std::cout, \"Wrong\");\n    std::ostream::operator<<(v6, sub_A31073);\n    sub_A31519();\n    LOBYTE(v15) = 0;\n    sub_A31438(v13);\n    v15 = -1;\n    sub_A31726(v14);\n  }\n  else\n  {\n    v9[3] = 0;\n    LOBYTE(v15) = 0;\n    sub_A31438(v13);\n    v15 = -1;\n    sub_A31726(v14);\n  }\n  sub_A31456(&savedregs, &dword_A3A008, 0);\n  return v8;\n}\n```\n\n​\t开始动调，设断点也是很讲究学问的！像这种复杂的东西，而且已知**check**函数的地方，我们就不能从头开始一点点看，得多次调试，先从**check**的前一步开始看，凭借**IDA**动调时看变量的值来确定加密与否。\n\n​\t`memcmp`里面存储我们加密flag的是**Buf2**变量，而前一步中**Buf2**和**v10**有关，**v10**是两个值异或来的，我们就看这两个异或值是多少。一看就知道，这就是一个异或加密，其中一个是我们输入的flag字符串，另一个是一个固定的key（改变输入确认这是固定的）。所以前面一堆都是系统代码，或者是无关紧要的代码。\n\n```python\nkey1 = [109, 193, 168, 93, 124, 190, 80, 186, 229, 136, 81, 199, 251, 176, 24, 43, 217, 148, 82, 66, 89, 245, 248, 167, 231, 34, 173, 31, 134, 245, 249, 101, 38, 88, 52, 155, 69, 123, 134, 180, 101, 253, 104, 39, 82, 50, 129, 80, 196, 184]\nenc = [62, 152, 235, 38, 37, 142, 37, 229, 134, 200, 63, 152, 200, 222, 82, 68, 160, 203, 43, 42, 60, 170, 190, 203, 136, 85, 158, 109, 217, 148, 151, 28, 82, 49, 89, 254, 26, 26, 232, 208, 58, 156, 6, 94, 37, 90, 228, 34, 161, 197]\nfor i in range(len(enc)):\n    print(chr(enc[i] ^ key1[i]), end='')\t#SYC{Y0u_c@n_3nJoy_yhe_Flow3r_anytime_and_anywhere}\n```\n\n​\t另外，[花指令真得看这个文章](https://bbs.kanxue.com/thread-279604.htm)。\n\n# DH爱喝茶\n\n​\t根据enc函数找到main函数，然后反编译不了，往上看到花指令，无敌了。\n\n​\t这个花指令，`xor`会将**ebx**设置为0，并且设置ZF标志为1；`test`指令会执行按位与运算，`ebx&ebx`，但是不影响结果，只改变标志位，由于ebx是0，所以ZF保持1。所以`jnz`不会跳转，`jz`会跳转。`jnz`开始`nop`掉吧，然后就可以反编译main函数了。\n\n```assembly\n.text:00001399                 xor     ebx, ebx\n.text:0000139B                 test    ebx, ebx\n.text:0000139D                 jnz     short near ptr LABEL7\n.text:0000139F                 jz      short LABEL8\n.text:0000139F ; ---------------------------------------------------------------------------\n.text:000013A1 LABEL7          db 0C7h                 ; CODE XREF: .text:0000139D↑j\n.text:000013A2 ; ---------------------------------------------------------------------------\n.text:000013A2\n.text:000013A2 LABEL8:                                 ; CODE XREF: .text:0000139F↑j\n.text:000013A2                 pop     ebx\n```\n\n​\t碰到一个新函数，`size_t strcspn(const char *str1, const char *str2);`，在字符串**str1**中找到第一个包含**str2**中任意字符的位置，然后返回这个位置的索引值；如果没找到，就返回**str1**的长度。\n\n​\tenc函数是一个标准tea加密，每次加密前，对key处理， `Key[i] = __ROL4__(Key[i], 6);`， **ROL4I**DA Pro（反汇编工具）自动生成的伪C代码中使用的一个宏函数，用来表示**对一个32位整数进行循环左移（rotate left）操作**。\n\n​\t其中需要注意的是，`+0x98765432`的指令容易被IDA反编译为`-0x6789ABCD`，不知道为什么，用减号就不对。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nuint32_t rol32(uint32_t value, int shift)\n{\n    return (value << shift) | (value >> (32 - shift));\n}\n\n\nint main()\n{\n    uint32_t enc[] = {0x1F85A965,0xEEC063EC,0x5BF1D0B6,0xF2FDE7B0,0xAA38809A,0x670772E9,0x360D24B9,0xE98C688C};\n    uint32_t key[] = {0x56789ABC,0x6789ABCD,0x789ABCDE,0x89ABCDEF};\n    uint32_t v0,v1;\n    int sum,delta;\n    for(int i=0;i<4;i++)\n    {\n        key[i] = rol32(key[i],6);\n        v0 = enc[i*2];\n        v1 = enc[i*2+1];\n        delta = (uint8_t)(key[0]^key[1]) + 0x98765432;\n        sum = delta * 32;\n        for(int j=0;j<32;j++)\n        {\n            v1 -= (v0 + sum) ^ ((v0 << 4) + key[2]) ^ ((v0 >> 5) + key[3]);\n            v0 -= (v1 + sum) ^ ((v1 << 4) + key[0]) ^ ((v1 >> 5) + key[1]);\n            sum -= delta;\n        }\n        enc[i*2] = v0;\n        enc[i*2+1] = v1;\n    }\n    \n    for(int i=0;i<32;i++)\n    {\n        printf(\"%c\", *((char*)enc + i));\t//SYC{DH_likes_flower_and_tea!!!!}\n    }\n    return 0;\n}\n```\n\n\n\n\n\n# 好像是python？\n\n​\t文本文件，以txt格式打开，看到python字节码的反汇编结果，我刚好没学过，乘此机会好好补一下。\n\n​\t推荐文章：[[原创\\]死磕python字节码-手工还原python源码-软件逆向-看雪-安全社区|安全招聘|kanxue.com](https://bbs.kanxue.com/thread-246683.htm)、[Python逆向（五）—— Python字节码解读 - Blili - 博客园](https://www.cnblogs.com/blili/p/11804690.html#3.6数学运算)。\n\n```assembly\n  1           0 LOAD_CONST               0 ('SYC{MD5(input)}')\n              2 STORE_NAME               0 (flag)                               ;flag = 'SYC{MD5(input)}'\n\n  2           4 LOAD_NAME                1 (print)\n              6 LOAD_CONST               1 ('Please input0:')                   \n              8 CALL_FUNCTION            1                                      ;print('Please input0:')\n             10 POP_TOP\n\n  3          12 LOAD_CONST               2 ('')\n             14 STORE_NAME               2 (input0)\n\n  6          16 LOAD_CONST               3 (<code object test2 at 0x00000245D4F44B30, file \"program.py\", line 6>)\n             18 LOAD_CONST               4 ('test2')\n             20 MAKE_FUNCTION            0\n             22 STORE_NAME               3 (test2)\n\n 14          24 LOAD_CONST               5 (<code object test at 0x00000245D4F44BE0, file \"program.py\", line 14>)\n             26 LOAD_CONST               6 ('test')\n             28 MAKE_FUNCTION            0\n             30 STORE_NAME               4 (test)\n\n 28          32 LOAD_CONST               7 (13)\n             34 STORE_NAME               5 (a)                              ;a=13\n\n 29          36 LOAD_CONST               8 (14)\n             38 STORE_NAME               6 (b)                              ;b=14\n\n 30          40 LOAD_NAME                5 (a)\n             42 LOAD_NAME                6 (b)\n             44 LOAD_NAME                5 (a)\n             46 BINARY_ADD \n             48 BINARY_XOR\n             50 STORE_NAME               7 (c)                              ;c=(a+b)^a\n\n 31          52 LOAD_NAME                6 (b)\n             54 LOAD_CONST               9 (100)        \n             56 BINARY_MULTIPLY\n             58 STORE_NAME               8 (d)                              ;d=b*100\n\n 32          60 LOAD_NAME                5 (a)\n             62 LOAD_NAME                6 (b)\n             64 BINARY_XOR\n             66 STORE_NAME               9 (e)                              ;e=a^b\n\n 33          68 LOAD_NAME                8 (d)\n             70 LOAD_NAME                7 (c)\n             72 LOAD_CONST              10 (4)\n             74 BINARY_MULTIPLY\n             76 BINARY_SUBTRACT\n             78 LOAD_NAME                9 (e)              \n             80 BINARY_ADD\n             82 LOAD_CONST              11 (1)\n             84 BINARY_SUBTRACT\n             86 STORE_NAME              10 (m)                               ;m=(d-(c*4))+e-1\n\n 35          88 LOAD_NAME               10 (m)\n             90 LOAD_CONST              12 (26)\n             92 BINARY_MODULO\n             94 STORE_NAME              11 (r)\n\n 37          96 LOAD_NAME                4 (test)\n             98 LOAD_NAME                2 (input0)\n            100 LOAD_NAME               11 (r)\n            102 CALL_FUNCTION            2\n            104 STORE_NAME              12 (cipher1)\n\n 38         106 LOAD_NAME                3 (test2)\n            108 LOAD_NAME               12 (cipher1)\n            110 CALL_FUNCTION            1\n            112 STORE_NAME              13 (cipher2)\n\n 39         114 LOAD_CONST              13 (-1)\n            116 LOAD_CONST              14 (-36)\n            118 LOAD_CONST              12 (26)\n            120 LOAD_CONST              15 (-5)\n            122 LOAD_CONST               8 (14)\n            124 LOAD_CONST              16 (41)\n            126 LOAD_CONST              17 (6)\n            128 LOAD_CONST              18 (-9)\n            130 LOAD_CONST              19 (60)\n            132 LOAD_CONST              20 (29)\n            134 LOAD_CONST              21 (-28)\n            136 LOAD_CONST              22 (17)\n            138 LOAD_CONST              23 (21)\n            140 LOAD_CONST              24 (7)\n            142 LOAD_CONST              25 (35)\n            144 LOAD_CONST              26 (38)\n            146 LOAD_CONST              12 (26)\n            148 LOAD_CONST              27 (48)\n            150 BUILD_LIST              18\n            152 STORE_NAME              14 (num)\n\n 40         154 LOAD_NAME               15 (range)\n            156 LOAD_CONST              28 (18)\n            158 CALL_FUNCTION            1\n            160 GET_ITER\n        >>  162 FOR_ITER                38 (to 202)\n            164 STORE_NAME              16 (i)\n\n 41         166 LOAD_NAME               13 (cipher2)\n            168 LOAD_NAME               16 (i)\n            170 BINARY_SUBSCR                                   ;索引访问\n            172 LOAD_NAME               14 (num)\n            174 LOAD_NAME               16 (i)\n            176 BINARY_SUBSCR                                   ;索引访问\n            178 COMPARE_OP               3 (!=)\n            180 POP_JUMP_IF_FALSE      192\n\n 42         182 LOAD_NAME                1 (print)\n            184 LOAD_CONST              29 ('wrong!')\n            186 CALL_FUNCTION            1\n            188 POP_TOP\n            190 JUMP_ABSOLUTE          162\n\n 44     >>  192 LOAD_NAME                1 (print)\n            194 LOAD_CONST              30 ('Rrrright!')\n            196 CALL_FUNCTION            1\n            198 POP_TOP\n            200 JUMP_ABSOLUTE          162\n        >>  202 LOAD_CONST              31 (None)\n            204 RETURN_VALUE\n\nDisassembly of <code object test2 at 0x00000245D4F44B30, file \"program.py\", line 6>:\n  7           0 LOAD_CONST               1 ('SYC')\n              2 STORE_FAST               1 (key)\n\n  8           4 LOAD_CONST               2 (18)\n              6 STORE_FAST               2 (length)\n\n  9           8 BUILD_LIST               0\n             10 STORE_FAST               3 (cipher)\n\n 10          12 LOAD_GLOBAL              0 (range)\n             14 LOAD_FAST                2 (length)\n             16 CALL_FUNCTION            1                  ;调用后，栈顶就会是 range(length) 返回的迭代器对象\n             18 GET_ITER                                    ;从栈中弹出迭代器对象，并准备开始迭代\n        >>   20 FOR_ITER                48 (to 70)          ;从迭代器中取出下一个值，并将值推送到栈顶,如果取到的值是合法的，它会继续执行循环体,否则跳转到70\n             22 STORE_FAST               4 (i)              ;将栈顶的值（就是 FOR_ITER 获取到的当前值）存储到局部变量 i 中\n\n 11          24 LOAD_FAST                3 (cipher)\n             26 LOAD_METHOD              1 (append)\n             28 LOAD_GLOBAL              2 (ord)\n             30 LOAD_FAST                0 (s2)\n             32 LOAD_FAST                4 (i)\n             34 BINARY_SUBSCR\n             36 CALL_FUNCTION            1              ;ord(s2[i])\n             38 LOAD_FAST                4 (i)\n             40 BINARY_XOR                              ;ord(s2[i]) ^ i\n             42 LOAD_GLOBAL              2 (ord)\n             44 LOAD_FAST                1 (key)\n             46 LOAD_FAST                4 (i)\n             48 LOAD_CONST               3 (3)          \n             50 BINARY_MODULO\n             52 BINARY_SUBSCR\n             54 CALL_FUNCTION            1              ;ord(key[i%3])\n             56 UNARY_INVERT                            ;执行一元取反（bitwise NOT）操作，~ord(key[i%3])\n             58 LOAD_CONST               4 (1)\n             60 BINARY_ADD                              ;~ord(key[i%3])+1\n             62 BINARY_ADD                              ;ord(s2[i]) ^ i + (~ord(key[i%3])+1)\n             64 CALL_METHOD              1\n             66 POP_TOP\n             68 JUMP_ABSOLUTE           20\n\n 12     >>   70 LOAD_FAST                3 (cipher)\n             72 RETURN_VALUE\n\nDisassembly of <code object test at 0x00000245D4F44BE0, file \"program.py\", line 14>:\n 15           0 BUILD_LIST               0\n              2 STORE_FAST               2 (result)                            ;result=[]\n\n 16           4 LOAD_FAST                0 (s)\n              6 GET_ITER\n        >>    8 FOR_ITER               218 (to 228) \n             10 STORE_FAST               3 (i)                                  ;for i in s:\n\n 17          12 LOAD_CONST               1 ('A')\n             14 LOAD_FAST                3 (i)\n             16 DUP_TOP                                                 ;取栈顶变量复制一份再压入，栈顶元素变两份\n             18 ROT_THREE                                               ;当前栈顶的三个元素旋转一下，例如当前['A',i,i]变成[i,'A',i]，这样做是为了适配后面的判断语句\n             20 COMPARE_OP               1 (<=)                                ;     i >= 'A'\n             22 POP_JUMP_IF_FALSE       32\n             24 LOAD_CONST               2 ('Z') \n             26 COMPARE_OP               1 (<=)                                    ; i <= 'Z'\n             28 POP_JUMP_IF_FALSE       80\n             30 JUMP_FORWARD             4 (to 36)\n        >>   32 POP_TOP\n             34 JUMP_FORWARD            44 (to 80)\n\n 18     >>   36 LOAD_FAST                2 (result)\n             38 LOAD_METHOD              0 (append)\n             40 LOAD_GLOBAL              1 (chr)\n             42 LOAD_GLOBAL              2 (ord)\n             44 LOAD_FAST                3 (i)\n             46 CALL_FUNCTION            1\n             48 LOAD_GLOBAL              2 (ord)\n             50 LOAD_CONST               1 ('A')\n             52 CALL_FUNCTION            1\n             54 BINARY_SUBTRACT\n             56 LOAD_FAST                1 (R)\n             58 BINARY_ADD\n             60 LOAD_CONST               3 (26)\n             62 BINARY_MODULO\n             64 LOAD_GLOBAL              2 (ord)\n             66 LOAD_CONST               1 ('A')\n             68 CALL_FUNCTION            1\n             70 BINARY_ADD\n             72 CALL_FUNCTION            1\n             74 CALL_METHOD              1\n             76 POP_TOP\n             78 JUMP_ABSOLUTE            8\n\n 19     >>   80 LOAD_CONST               4 ('a')\n             82 LOAD_FAST                3 (i)\n             84 DUP_TOP\n             86 ROT_THREE\n             88 COMPARE_OP               1 (<=)\n             90 POP_JUMP_IF_FALSE      100\n             92 LOAD_CONST               5 ('z')\n             94 COMPARE_OP               1 (<=)\n             96 POP_JUMP_IF_FALSE      148\n             98 JUMP_FORWARD             4 (to 104)\n        >>  100 POP_TOP\n            102 JUMP_FORWARD            44 (to 148)\n\n 20     >>  104 LOAD_FAST                2 (result)\n            106 LOAD_METHOD              0 (append)\n            108 LOAD_GLOBAL              1 (chr)\n            110 LOAD_GLOBAL              2 (ord)\n            112 LOAD_FAST                3 (i)\n            114 CALL_FUNCTION            1\n            116 LOAD_GLOBAL              2 (ord)\n            118 LOAD_CONST               4 ('a')\n            120 CALL_FUNCTION            1\n            122 BINARY_SUBTRACT\n            124 LOAD_FAST                1 (R)\n            126 BINARY_ADD\n            128 LOAD_CONST               3 (26)\n            130 BINARY_MODULO\n            132 LOAD_GLOBAL              2 (ord)\n            134 LOAD_CONST               4 ('a')\n            136 CALL_FUNCTION            1\n            138 BINARY_ADD\n            140 CALL_FUNCTION            1\n            142 CALL_METHOD              1\n            144 POP_TOP\n            146 JUMP_ABSOLUTE            8\n\n 21     >>  148 LOAD_CONST               6 ('0')\n            150 LOAD_FAST                3 (i)\n            152 DUP_TOP\n            154 ROT_THREE\n            156 COMPARE_OP               1 (<=)\n            158 POP_JUMP_IF_FALSE      168\n            160 LOAD_CONST               7 ('9')\n            162 COMPARE_OP               1 (<=)\n            164 POP_JUMP_IF_FALSE      216\n            166 JUMP_FORWARD             4 (to 172)\n        >>  168 POP_TOP\n            170 JUMP_FORWARD            44 (to 216)\n\n 22     >>  172 LOAD_FAST                2 (result)\n            174 LOAD_METHOD              0 (append)\n            176 LOAD_GLOBAL              1 (chr)\n            178 LOAD_GLOBAL              2 (ord)\n            180 LOAD_FAST                3 (i)\n            182 CALL_FUNCTION            1\n            184 LOAD_GLOBAL              2 (ord)\n            186 LOAD_CONST               6 ('0')\n            188 CALL_FUNCTION            1\n            190 BINARY_SUBTRACT\n            192 LOAD_FAST                1 (R)\n            194 BINARY_ADD\n            196 LOAD_CONST               8 (10)\n            198 BINARY_MODULO\n            200 LOAD_GLOBAL              2 (ord)\n            202 LOAD_CONST               6 ('0')\n            204 CALL_FUNCTION            1\n            206 BINARY_ADD\n            208 CALL_FUNCTION            1\n            210 CALL_METHOD              1\n            212 POP_TOP\n            214 JUMP_ABSOLUTE            8\n\n 24     >>  216 LOAD_FAST                2 (result)\n            218 LOAD_METHOD              0 (append)\n            220 LOAD_FAST                3 (i)\n            222 CALL_METHOD              1\n            224 POP_TOP\n            226 JUMP_ABSOLUTE            8\n\n 25     >>  228 LOAD_CONST               9 ('')\n            230 LOAD_METHOD              3 (join)\n            232 LOAD_FAST                2 (result)\n            234 CALL_METHOD              1\n            236 RETURN_VALUE\n\n```\n\n​\t**chatgpt**梭哈还原的代码如下，md它也有错误，垃圾东西！尝试自己对照看汇编指令修改。\n\n```python\nflag = 'SYC{MD5(input)}'\n\nprint('Please input0:')\ninput0 = ''\n\n# 加密函数1：类似 Caesar Cipher 带偏移\ndef test(s, R):\n    result = []\n    for i in s:\n        if 'A' <= i <= 'Z':\n            result.append(chr((ord(i) - ord('A') + R) % 26 + ord('A')))\n        elif 'a' <= i <= 'z':\n            result.append(chr((ord(i) - ord('a') + R) % 26 + ord('a')))\n        elif '0' <= i <= '9':\n            result.append(chr((ord(i) - ord('0') + R) % 10 + ord('0')))\n        else:\n            result.append(i)\n    return ''.join(result)\n\n# 加密函数2：字符与 key 异或 + 取反变换\ndef test2(s2):\n    key = 'SYC'\n    length = 18\n    cipher = []\n    for i in range(length):\n        c = ord(s2[i]) ^ i + (~ord(key[i % 3]) + 1)\t\t#这种运算chatgpt未注册版搞不定。\n        cipher.append(c)\n    return cipher\n\n# 主逻辑\na = 13\nb = 14\nc = (a+b)^a \t#同样修改过。\nd = b * 100\ne = a ^ b\nm = d - c * 4 + e - 1\nr = m % 26    #r=14\n\ncipher1 = test(input0, r)\ncipher2 = test2(cipher1)\n\nnum = [\n    -1, -36, 26, -5, 14, 41, 6, -9, 60, 29,\n    -28, 17, 21, 7, 35, 38, 26, 48\n]\n\nfor i in range(18):\n    if cipher2[i] != num[i]:\n        print('wrong!')\n        continue\n    print('Rrrright!')\n\n```\n\n​\t解密脚本，md5加密后的flag为**SYC{ed798fdd74e5c382b9c7fcca88500aca}**。\n\n```python\nnum = [\n    -1, -36, 26, -5, 14, 41, 6, -9, 60, 29,\n    -28, 17, 21, 7, 35, 38, 26, 48\n]\nkey = 'SYC'\nrol = 14\nfor i in range(len(num)):\n    num[i] = (num[i] - (~ord(key[i%3]) + 1)) ^ i\n    A = ord('A')\n    Z = ord('Z')\n    a = ord('a')\n    z = ord('z')\n    if A <= num[i] <= Z:\n        num[i] = (num[i] - A - rol) % 26 + A\n    elif a <= num[i] <= z:\n        num[i] = (num[i] - a - rol) % 26 + a\n    elif ord('0') <= num[i] <= ord('9'):\n        num[i] = (num[i] - ord('0') - rol) % 10 + ord('0')\n\n    print(chr(num[i]), end='')  #D0_You_Iik3_python\n```\n\n​\t\n\n# 奇怪的RC4\n\n​\t**PyInstaller**打包的exe程序，**pydumpck**解包后得到密文和加密逻辑，直接解包还会反编译不完全，怎么回事，没遇到过啊。\n\n​\t手动反汇编，读汇编来补充！这个自动添加的**()注释**真的是漏洞百出，没几个对的。xor1和xor2都没能解析出来。（**原来是3.8的版本，我是一点解不出来**）\n\n```python\nimport dis\nimport marshal\n# 读取 .pyc 文件\nfor i in range(50):\n    with open(r\"easy_xor_and_rc4.pyc\",\n              'rb') as f:\n        try:\n            f.read(i)\t\t\t#因为我不确定魔术头包含多少位，实践证明是0\n            code = marshal.load(f)\n            print(\"ok : \", i)\n            break\n        except:\n            print(\"Error\")\n\n# 使用 dis 模块反汇编字节码\ndis.dis(code)\n```\n\n> 容易理解错的指令：**STORE_SUBSCR**指令执行时栈顶是**[b[1],a,i]**，那么就是**a[i]=b[1]**。\n>\n> **FOR_ITER**指令不知道。\n>\n> **JUMP_ABSOLUTE**指令是绝对地址跳转。\n>\n> **JUMP_FORWARD**指令是相对地址，基址是下一条指令地址。\n\n```assembly\n  2           0 LOAD_CONST               0 (0)\n              2 LOAD_CONST               1 (('*',))\n              4 IMPORT_NAME              0 (Rc4)\n              6 IMPORT_STAR \n\n 15           8 LOAD_CONST               2 (<code object xor1 at 0x0000023C79386EF0, file \"easy_xor_and_rc4.py\", line 2>)\n             10 LOAD_CONST               3 ('xor1')\n             12 MAKE_FUNCTION            0\n             14 STORE_NAME               1 (xor1) \t\t\t;函数声明，xor1\n\n 24          16 LOAD_CONST               4 (<code object xor2 at 0x0000023C79387050, file \"easy_xor_and_rc4.py\", line 15>)\n             18 LOAD_CONST               5 ('xor2')\n             20 MAKE_FUNCTION            0\n             22 STORE_NAME               2 (xor2)\n\n 30          24 LOAD_CONST               6 (<code object enc at 0x0000023C79387100, file \"easy_xor_and_rc4.py\", line 24>)\n             26 LOAD_CONST               7 ('enc')\n             28 MAKE_FUNCTION            0\n             30 STORE_NAME               3 (enc)\n\n 31          32 LOAD_NAME                4 (input)\n             34 LOAD_CONST               8 ('please give your input:')\n             36 CALL_FUNCTION            1\n             38 STORE_NAME               5 (plaintext) \t\t;plaintext=input(\"...\")\n\n 32          40 LOAD_CONST               9 ('SYCFOREVER')\n             42 STORE_NAME               6 (key) \t\t\t;key='...'\n\n 33          44 LOAD_NAME                7 (list)\n             46 LOAD_NAME                8 (range)\n             48 LOAD_NAME                9 (len)\n             50 LOAD_NAME                5 (plaintext)\n             52 CALL_FUNCTION            1\n             54 CALL_FUNCTION            1\n             56 CALL_FUNCTION            1\n             58 STORE_NAME              10 (xor_list) \t\t\t;xor_list = list[range(len(plaintext))]\n\n 34          60 LOAD_CONST              10 (158)\n             62 LOAD_CONST              11 (31)\n             64 LOAD_CONST              12 (205)\n             66 LOAD_CONST              13 (434)\n             68 LOAD_CONST              14 (354)\n             70 LOAD_CONST              15 (15)\n             72 LOAD_CONST              16 (383)\n             74 LOAD_CONST              17 (298)\n             76 LOAD_CONST              18 (304)\n             78 LOAD_CONST              19 (351)\n             80 LOAD_CONST              20 (465)\n             82 LOAD_CONST              21 (312)\n             84 LOAD_CONST              22 (261)\n             86 LOAD_CONST              23 (442)\n             88 LOAD_CONST              24 (397)\n             90 LOAD_CONST              25 (474)\n             92 LOAD_CONST              26 (310)\n             94 LOAD_CONST              24 (397)\n             96 LOAD_CONST              11 (31)\n             98 LOAD_CONST              27 (21)\n            100 LOAD_CONST              28 (78)\n            102 LOAD_CONST              29 (67)\n            104 LOAD_CONST              30 (47)\n            106 LOAD_CONST              31 (133)\n            108 LOAD_CONST              32 (168)\n            110 LOAD_CONST              33 (48)\n            112 LOAD_CONST              34 (153)\n            114 LOAD_CONST              35 (99)\n            116 LOAD_CONST              36 (103)\n            118 LOAD_CONST              37 (204)\n            120 LOAD_CONST              38 (137)\n            122 LOAD_CONST              39 (29)\n            124 LOAD_CONST              40 (22)\n            126 LOAD_CONST              41 (13)\n            128 LOAD_CONST              42 (228)\n            130 LOAD_CONST              43 (3)\n            132 LOAD_CONST              44 (136)\n            134 LOAD_CONST              45 (141)\n            136 LOAD_CONST              46 (248)\n            138 LOAD_CONST              47 (124)\n            140 LOAD_CONST              48 (26)\n            142 LOAD_CONST              48 (26)\n            144 LOAD_CONST              49 (65)\n            146 LOAD_CONST              50 (200)\n            148 LOAD_CONST              51 (7)\n            150 BUILD_LIST              45\n            152 STORE_NAME              11 (cipher) \t\t;cipher=[...]\n\n 35         154 LOAD_NAME                3 (enc)\n            156 LOAD_NAME                5 (plaintext)\n            158 LOAD_NAME                6 (key)\n            160 LOAD_NAME               10 (xor_list)\n            162 CALL_FUNCTION            3 \t\t\t\t\t\t;enc(plaintext,key,xor_list)\n            164 STORE_NAME               5 (plaintext)\n\n 36         166 LOAD_NAME                8 (range)\n            168 LOAD_NAME                9 (len)\n            170 LOAD_NAME               11 (cipher)\n            172 CALL_FUNCTION            1\n            174 CALL_FUNCTION            1 \t\t\t\t\t\t\n            176 GET_ITER\n            178 FOR_ITER                36 (to 252)\n            180 STORE_NAME              12 (i)\t\t\t\t\t\t;for i in range(len(cipher))\n\n 37         182 LOAD_NAME               11 (cipher)\n            184 LOAD_NAME               12 (i)\n            186 BINARY_SUBSCR\n            188 LOAD_NAME                5 (plaintext)\n            190 LOAD_NAME               12 (i)\n            192 BINARY_SUBSCR\n            194 COMPARE_OP               3 (!=) \t\t\t\t;cipher[i]!=plaintext[i]\n            196 POP_JUMP_IF_FALSE      178 (to 356)\n\n 38         198 LOAD_NAME               13 (print)\n            200 LOAD_CONST              52 ('Wrong')\n            202 CALL_FUNCTION            1\n            204 POP_TOP\n\n 39         206 LOAD_NAME               14 (exit)\n            208 LOAD_CONST              53 (1)\n            210 CALL_FUNCTION            1\n            212 POP_TOP\n            214 JUMP_ABSOLUTE          178 (to 356)\n            216 LOAD_NAME               13 (print)\n            218 LOAD_CONST              54 ('You know the flag!!')\n            220 CALL_FUNCTION            1\n            222 POP_TOP\n            224 LOAD_CONST              55 (None)\n            226 RETURN_VALUE\n\nDisassembly of <code object xor1 at 0x0000023C79386EF0, file \"easy_xor_and_rc4.py\", line 2>:\n  4           0 SETUP_FINALLY           18 (to 38)\n\n  5           2 LOAD_CONST               1 (<code object <listcomp> at 0x0000023C79386550, file \"easy_xor_and_rc4.py\", line 4>)\n              4 LOAD_CONST               2 ('xor1.<locals>.<listcomp>')\n              6 MAKE_FUNCTION            0\n              8 LOAD_FAST                1 (xor_list)\n             10 GET_ITER\n             12 CALL_FUNCTION            1\n             14 STORE_FAST               1 (xor_list)\n             16 POP_BLOCK\n             18 JUMP_FORWARD            12 (to 44)\n\n  6          20 POP_TOP\n             22 POP_TOP\n             24 POP_TOP\n\n  7          26 POP_EXCEPT\n             28 JUMP_FORWARD             2 (to 34)\n             30 <88>\n\n  8          32 SETUP_FINALLY           18 (to 70)\n\n  9     >>   34 LOAD_CONST               3 (<code object <listcomp> at 0x0000023C79386E40, file \"easy_xor_and_rc4.py\", line 8>)\n             36 LOAD_CONST               2 ('xor1.<locals>.<listcomp>')\n        >>   38 MAKE_FUNCTION            0\n             40 LOAD_FAST                0 (plaintext)\n             42 GET_ITER\n        >>   44 CALL_FUNCTION            1\n             46 STORE_FAST               0 (plaintext)\n             48 POP_BLOCK\n             50 JUMP_FORWARD            12 (to 76)\n\n 10          52 POP_TOP\n             54 POP_TOP\n             56 POP_TOP\n\n 11          58 POP_EXCEPT\n             60 JUMP_FORWARD             2 (to 66)\n             62 <88>\n\n 12          64 LOAD_GLOBAL              0 (range)\n        >>   66 LOAD_GLOBAL              1 (len)\n             68 LOAD_FAST                0 (plaintext)\n        >>   70 CALL_FUNCTION            1\n             72 CALL_FUNCTION            1\n             74 GET_ITER\n        >>   76 FOR_ITER                24 (to 126)\n             78 STORE_FAST               2 (i)\n\n 13          80 LOAD_FAST                0 (plaintext)\n             82 LOAD_FAST                2 (i)\n             84 DUP_TOP_TWO\t\t\t\t\t\t\t\t\t;将栈顶两个元素复制一份放到栈顶\n             86 BINARY_SUBSCR\n             88 LOAD_FAST                1 (xor_list)\n             90 LOAD_FAST                2 (i)\n             92 BINARY_SUBSCR\n             94 INPLACE_XOR \t\t\t\t\t\t\t\t;就地（栈）异或，减少内存占用\n             96 ROT_THREE\n             98 STORE_SUBSCR \t\t\t\t\t\t\t\t;plaintext[i]^=xor_list[i]\n            100 JUMP_ABSOLUTE           76 (to 152)\n            102 LOAD_FAST                0 (plaintext)\n            104 RETURN_VALUE\n\nDisassembly of <code object <listcomp> at 0x0000023C79386550, file \"easy_xor_and_rc4.py\", line 4>:\n  4           0 BUILD_LIST               0\n              2 LOAD_FAST                0 (.0)\n              4 FOR_ITER                12 (to 30)\n              6 STORE_FAST               1 (i)\n        >>    8 LOAD_GLOBAL              0 (ord)\n             10 LOAD_FAST                1 (i)\n             12 CALL_FUNCTION            1\n             14 LIST_APPEND              2\n             16 JUMP_ABSOLUTE            4 (to 8)\n             18 RETURN_VALUE\n\nDisassembly of <code object <listcomp> at 0x0000023C79386E40, file \"easy_xor_and_rc4.py\", line 8>:\n  8           0 BUILD_LIST               0\n              2 LOAD_FAST                0 (.0)\n              4 FOR_ITER                12 (to 30)\n              6 STORE_FAST               1 (i)\n        >>    8 LOAD_GLOBAL              0 (ord)\n             10 LOAD_FAST                1 (i)\n             12 CALL_FUNCTION            1\n             14 LIST_APPEND              2\n             16 JUMP_ABSOLUTE            4 (to 8)\n             18 RETURN_VALUE\n\nDisassembly of <code object xor2 at 0x0000023C79387050, file \"easy_xor_and_rc4.py\", line 15>:\n 17           0 SETUP_FINALLY           18 (to 38)    \t;异常发生时跳转到38\n\n 18           2 LOAD_CONST               1 (<code object <listcomp> at 0x0000023C79386FA0, file \"easy_xor_and_rc4.py\", line 17>) \t\t\t;加载常量 1，这个常量指向一个内联的列表推导式\n              4 LOAD_CONST               2 ('xor2.<locals>.<listcomp>')\n              6 MAKE_FUNCTION            0 \t\t\t\t\t\t\t;创建一个函数对象，准备将其应用\n              8 LOAD_FAST                0 (plaintext)\n             10 GET_ITER\n             12 CALL_FUNCTION            1 \t\t\t\t;由于这个函数是列表推导式，所以它将对 plaintext 进行迭代，并返回一个列表。\n             14 STORE_FAST               0 (plaintext)\n             16 POP_BLOCK \t\t\t\t\t\t\t\t;结束当前代码块（通常用于 try、with 语句块）\n             18 JUMP_FORWARD            12 (to 44)\n\n 19          20 POP_TOP\n             22 POP_TOP\n             24 POP_TOP\n\n 20          26 POP_EXCEPT\n             28 JUMP_FORWARD             2 (to 34)\n             30 <88>\n\n 21          32 LOAD_GLOBAL              0 (range)\n        >>   34 LOAD_GLOBAL              1 (len)\n             36 LOAD_FAST                0 (plaintext)\n        >>   38 CALL_FUNCTION            1\n             40 LOAD_CONST               3 (1)\n             42 BINARY_SUBTRACT\n        >>   44 CALL_FUNCTION            1 \t\t\t\t\t\t\t\t;range(len(plaintext)-1)\n             46 GET_ITER\n             48 FOR_ITER                32 (to 114) \t\t\t\t\t;32啥也不是！\n             50 STORE_FAST               1 (i) \t\t\t\t\t\t\t;for i in range(...)\n\n 22          52 LOAD_FAST                0 (plaintext)\n             54 LOAD_FAST                1 (i)\n             56 BINARY_SUBSCR\n             58 LOAD_FAST                0 (plaintext)\n             60 LOAD_FAST                1 (i)\n             62 LOAD_CONST               3 (1)\n             64 BINARY_ADD\n             66 BINARY_SUBSCR\n             68 BINARY_XOR \t\t\t\t\t\t\t\t\t\t\t;plaintext[i]^plaintext[i+1]\n             70 LOAD_FAST                0 (plaintext)\n             72 LOAD_FAST                1 (i)\n             74 LOAD_CONST               3 (1)\n             76 BINARY_ADD\n             78 STORE_SUBSCR \t\t\t\t\t\t\t\t\t\t;plaintext[i+1]=...\n             80 JUMP_ABSOLUTE           48 (to 96) \t\t\t\t\t;跳转到绝对位置48\n             82 LOAD_FAST                0 (plaintext)\n             84 RETURN_VALUE\n\nDisassembly of <code object <listcomp> at 0x0000023C79386FA0, file \"easy_xor_and_rc4.py\", line 17>:\n 17           0 BUILD_LIST               0\n              2 LOAD_FAST                0 (.0)\n              4 FOR_ITER                12 (to 30)\n              6 STORE_FAST               1 (i)\n        >>    8 LOAD_GLOBAL              0 (ord)\n             10 LOAD_FAST                1 (i)\n             12 CALL_FUNCTION            1\n             14 LIST_APPEND              2\n             16 JUMP_ABSOLUTE            4 (to 8)\n             18 RETURN_VALUE\n\nDisassembly of <code object enc at 0x0000023C79387100, file \"easy_xor_and_rc4.py\", line 24>:\n 26           0 LOAD_GLOBAL              0 (rc4)\n              2 LOAD_FAST                0 (plaintext)\n              4 LOAD_FAST                1 (key)\n              6 CALL_FUNCTION            2\n              8 STORE_FAST               0 (plaintext) \t\t\t;plaintext=rc4(plaintext,key)\n\n 27          10 LOAD_GLOBAL              1 (xor1)\n             12 LOAD_FAST                0 (plaintext)\n             14 LOAD_FAST                2 (xor_list)\n             16 CALL_FUNCTION            2\n             18 STORE_FAST               0 (plaintext) \t\t\t;plaintext=xor1(plaintext,xor_list)\n\n 28          20 LOAD_GLOBAL              2 (xor2)\n             22 LOAD_FAST                0 (plaintext)\n             24 CALL_FUNCTION            1\n             26 STORE_FAST               0 (plaintext)      \t;plaintext=xor2(plaintext)\n             28 LOAD_FAST                0 (plaintext)\n             30 RETURN_VALUE\n\nProcess finished with exit code 0\n\n```\n\n​\t可以大概看出来，`xor1`函数是`plaintext[i]^xor_list[i]`，`xor2`是前后异或，其中数据自取。\n\n```python\ndef xor2(plain):\n    for i in range(len(plain)-1):\n        plain[i+1]^=plain[i]\n    return plain\n\ndef xor1(plain,xor_list):\n    for i in range(len(plain)):\n        plain[i] ^= i\t\t\t\t#xor_list[i]=i\n  \treturn plain\n\ndef enc(plain,key,xor_list):\n    enc(plain,key)\n    xor1(plain,xor_list)\n    xor2(plain)\n    return plain\n```\n\n​\t再看看RC4的代码，解包时，RC4函数没能成功解析出来，KSA和PRGA还是半对，烦！\n\n​\t分析一下。\n\n```assembly\n  9           0 LOAD_CONST               0 (<code object KSA at 0x000001C022376550, file \"Rc4.py\", line 1>)\n              2 LOAD_CONST               1 ('KSA')\n              4 MAKE_FUNCTION            0\n              6 STORE_NAME               0 (KSA)\n\n 19           8 LOAD_CONST               2 (<code object PRGA at 0x000001C022376E40, file \"Rc4.py\", line 9>)\n             10 LOAD_CONST               3 ('PRGA')\n             12 MAKE_FUNCTION            0\n             14 STORE_NAME               1 (PRGA)\n             16 LOAD_CONST               4 (<code object rc4 at 0x000001C022377100, file \"Rc4.py\", line 19>)\n             18 LOAD_CONST               5 ('rc4')\n             20 MAKE_FUNCTION            0\n             22 STORE_NAME               2 (rc4)\n             24 LOAD_CONST               6 (None)\n             26 RETURN_VALUE\n\nDisassembly of <code object KSA at 0x000001C022376550, file \"Rc4.py\", line 1>:\n  3           0 LOAD_CONST               1 (0)\n              2 STORE_FAST               1 (j)\n\n  4           4 LOAD_GLOBAL              0 (list)\n              6 LOAD_GLOBAL              1 (range)\n              8 LOAD_CONST               2 (256)\n             10 CALL_FUNCTION            1\n             12 CALL_FUNCTION            1\n             14 STORE_FAST               2 (S)\n\n  5          16 LOAD_GLOBAL              2 (len)\n             18 LOAD_FAST                0 (key)\n             20 CALL_FUNCTION            1\n             22 STORE_FAST               3 (key_length)\n\n  6          24 LOAD_GLOBAL              1 (range)\n             26 LOAD_CONST               2 (256)\n             28 CALL_FUNCTION            1\n             30 GET_ITER\n             32 FOR_ITER                58 (to 150)\n             34 STORE_FAST               4 (i)\n\n  7          36 LOAD_FAST                1 (j)\n             38 LOAD_FAST                2 (S)\n             40 LOAD_FAST                4 (i)\n             42 BINARY_SUBSCR\n             44 BINARY_ADD\n             46 LOAD_FAST                0 (key)\n             48 LOAD_FAST                4 (i)\n             50 LOAD_FAST                3 (key_length)\n             52 BINARY_MODULO\n             54 BINARY_SUBSCR\n             56 BINARY_ADD\n             58 LOAD_CONST               2 (256)\n             60 BINARY_MODULO\n             62 STORE_FAST               1 (j)\n\n  8     >>   64 LOAD_FAST                2 (S)\n             66 LOAD_FAST                1 (j)\n             68 BINARY_SUBSCR\n             70 LOAD_FAST                2 (S)\n             72 LOAD_FAST                4 (i)\n             74 BINARY_SUBSCR\n             76 ROT_TWO\n             78 LOAD_FAST                2 (S)\n             80 LOAD_FAST                4 (i)\n             82 STORE_SUBSCR\n             84 LOAD_FAST                2 (S)\n             86 LOAD_FAST                1 (j)\n             88 STORE_SUBSCR\n             90 JUMP_ABSOLUTE           32 (to 64)\n             92 LOAD_FAST                2 (S)\n             94 RETURN_VALUE\n\nDisassembly of <code object PRGA at 0x000001C022376E40, file \"Rc4.py\", line 9>:\n 11           0 LOAD_CONST               1 (0)\n              2 STORE_FAST               1 (i)\n\n 13           4 LOAD_CONST               1 (0)\n              6 STORE_FAST               2 (j)\n\n 14           8 LOAD_FAST                1 (i)\n             10 LOAD_CONST               2 (1)\n             12 BINARY_ADD\n             14 LOAD_CONST               3 (256)\n        >>   16 BINARY_MODULO\n             18 STORE_FAST               1 (i)\n\n 15          20 LOAD_FAST                2 (j)\n             22 LOAD_FAST                0 (S)\n             24 LOAD_FAST                1 (i)\n             26 BINARY_SUBSCR\n             28 BINARY_ADD\n             30 LOAD_CONST               3 (256)\n             32 BINARY_MODULO\n             34 STORE_FAST               2 (j)\n\n 16          36 LOAD_FAST                0 (S)\n             38 LOAD_FAST                2 (j)\n             40 BINARY_SUBSCR\n             42 LOAD_FAST                0 (S)\n             44 LOAD_FAST                1 (i)\n             46 BINARY_SUBSCR\n             48 ROT_TWO \t\t\t\t\t\t\t;[s[i],s[j]]\n             50 LOAD_FAST                0 (S)\n             52 LOAD_FAST                1 (i)\n             54 STORE_SUBSCR \t\t\t\t\t\t;s[i]=s[j]\n             56 LOAD_FAST                0 (S)\n             58 LOAD_FAST                2 (j)\n             60 STORE_SUBSCR \t\t\t\t\t\t;s[j]=t=s[i](原先的s[i])，swap了一下\n\n 17          62 LOAD_FAST                0 (S)\n             64 LOAD_FAST                1 (i)\n             66 BINARY_SUBSCR\n             68 LOAD_FAST                0 (S)\n             70 LOAD_FAST                2 (j)\n             72 BINARY_SUBSCR \t\t\t\t\t;[s[i],s[j]]\n             74 BINARY_ADD\n             76 LOAD_CONST               3 (256)\n             78 BINARY_MODULO\n             80 STORE_FAST               3 (k) \t\t\t;k=s[i]+s[j]\n             82 LOAD_FAST                3 (k)\n             84 YIELD_VALUE\n             86 POP_TOP\n             88 JUMP_ABSOLUTE            8 (to 16)\n             90 LOAD_CONST               0 (None)\n             92 RETURN_VALUE\n\nDisassembly of <code object rc4 at 0x000001C022377100, file \"Rc4.py\", line 19>:\n 21           0 SETUP_FINALLY           18 (to 38)\n\n 22           2 LOAD_CONST               1 (<code object <listcomp> at 0x000001C022376FA0, file \"Rc4.py\", line 21>)\n              4 LOAD_CONST               2 ('rc4.<locals>.<listcomp>')\n              6 MAKE_FUNCTION            0\n              8 LOAD_FAST                1 (key)\n             10 GET_ITER\n             12 CALL_FUNCTION            1\n             14 STORE_FAST               1 (key)\n             16 POP_BLOCK\n             18 JUMP_FORWARD            12 (to 44)\n\n 23          20 POP_TOP\n             22 POP_TOP\n             24 POP_TOP\n\n 24          26 POP_EXCEPT\n             28 JUMP_FORWARD             2 (to 34)\n             30 <88>\n\n 25          32 SETUP_FINALLY           18 (to 70)\n\n 26     >>   34 LOAD_CONST               3 (<code object <listcomp> at 0x000001C022377050, file \"Rc4.py\", line 25>)\n             36 LOAD_CONST               2 ('rc4.<locals>.<listcomp>')\n        >>   38 MAKE_FUNCTION            0\n             40 LOAD_FAST                0 (plaintext)\n             42 GET_ITER\n        >>   44 CALL_FUNCTION            1\n             46 STORE_FAST               0 (plaintext)\n             48 POP_BLOCK\n             50 JUMP_FORWARD            12 (to 76)\n\n 27          52 POP_TOP\n             54 POP_TOP\n             56 POP_TOP\n\n 28          58 POP_EXCEPT\n             60 JUMP_FORWARD             2 (to 66)\n             62 <88>\n\n 29          64 LOAD_GLOBAL              0 (range)\n        >>   66 LOAD_GLOBAL              1 (len)\n             68 LOAD_FAST                0 (plaintext)\n        >>   70 CALL_FUNCTION            1\n             72 CALL_FUNCTION            1\n             74 GET_ITER\n        >>   76 FOR_ITER                20 (to 118)\n             78 STORE_FAST               2 (i)\n\n 30          80 LOAD_FAST                0 (plaintext)\n             82 LOAD_FAST                2 (i)\n             84 DUP_TOP_TWO\n             86 BINARY_SUBSCR\n             88 LOAD_FAST                2 (i)\n             90 INPLACE_ADD \t\t\t\t\t\t\t;plaintext[i]+i\n             92 ROT_THREE\n             94 STORE_SUBSCR \t\t\t\t\t\t\t;plaintext[i] = plaintext[i]+i\n             96 JUMP_ABSOLUTE           76 (to 152)\n\n 31          98 LOAD_GLOBAL              2 (KSA)\n            100 LOAD_FAST                1 (key)\n            102 CALL_FUNCTION            1\n            104 STORE_FAST               3 (S) \t\t\t\t\t;S=KSA(key)\n\n 32         106 LOAD_GLOBAL              3 (PRGA)\n            108 LOAD_FAST                3 (S)\n            110 CALL_FUNCTION            1\n            112 STORE_FAST               4 (xor_value) \t\t\t\t;xor_vlaue=PRGA(S)\n\n 33         114 LOAD_GLOBAL              0 (range)\n            116 LOAD_GLOBAL              1 (len)\n        >>  118 LOAD_FAST                0 (plaintext)\n            120 CALL_FUNCTION            1\n            122 CALL_FUNCTION            1\n            124 GET_ITER\n            126 FOR_ITER                32 (to 192)\n            128 STORE_FAST               2 (i) \t\t\t\t\t;for i in range(len(plaintext)):\n\n 34         130 LOAD_FAST                0 (plaintext)\n            132 LOAD_FAST                2 (i)\n            134 DUP_TOP_TWO\n            136 BINARY_SUBSCR\n            138 LOAD_GLOBAL              4 (int)\n            140 LOAD_GLOBAL              5 (next)\n            142 LOAD_FAST                4 (xor_value)\n            144 CALL_FUNCTION            1\n            146 CALL_FUNCTION            1 \t\t\t\t\t\t;int(next(xor_value))\n            148 LOAD_CONST               4 (6)\n            150 BINARY_ADD \t\t\t\t\t\t\t\t\t\t;...+6\n        >>  152 INPLACE_XOR \t\t\t\t\t\t\t\t\t;plaintext[i]^...\n            154 ROT_THREE\n            156 STORE_SUBSCR \t\t\t\t\t\t\t\t\t;plaintext[i]=...\n            158 JUMP_ABSOLUTE          126 (to 252)\n            160 LOAD_FAST                0 (plaintext)\n            162 RETURN_VALUE\n\nDisassembly of <code object <listcomp> at 0x000001C022376FA0, file \"Rc4.py\", line 21>:\n 21           0 BUILD_LIST               0\n              2 LOAD_FAST                0 (.0)\n              4 FOR_ITER                12 (to 30)\n              6 STORE_FAST               1 (i)\n        >>    8 LOAD_GLOBAL              0 (ord)\n             10 LOAD_FAST                1 (i)\n             12 CALL_FUNCTION            1\n             14 LIST_APPEND              2\n             16 JUMP_ABSOLUTE            4 (to 8)\n             18 RETURN_VALUE\n\nDisassembly of <code object <listcomp> at 0x000001C022377050, file \"Rc4.py\", line 25>:\n 25           0 BUILD_LIST               0\n              2 LOAD_FAST                0 (.0)\n              4 FOR_ITER                12 (to 30)\n              6 STORE_FAST               1 (i)\n        >>    8 LOAD_GLOBAL              0 (ord)\n             10 LOAD_FAST                1 (i)\n             12 CALL_FUNCTION            1\n             14 LIST_APPEND              2\n             16 JUMP_ABSOLUTE            4 (to 8)\n             18 RETURN_VALUE\n\nProcess finished with exit code 0\n```\n\n​\t综合分析得到的rc4.py如下，简化了一些异常处理以及格式转换。\n\n```python\ndef KSA(key):\n    j = 0\n    S = list(range(256))\n    key_length = len(key)\n    for i in range(256):\n        j = (j + S[i] + key[i % key_length]) % 256\n        S[i],S[j] = S[j],S[i]\n        return S\n\ndef PRGA(S):\n    i = 0\n    j = 0\n    while True:\n        i = (i + 1) % 256\n    \tj = (j + S[i]) % 256\n    \tS[i],S[j] = S[j],S[i]\n    \tk = (S[i] + S[j]) % 256\n    \tyield k\n\ndef RC4(plain, key):\n    for i in range(len(plain)):\n        plain_text[i] += i\n    S = KSA(key)\n    cipher_text = []\n    prga = PRGA(S)\n    for i in range(len(plain_text)):\n        cipher_text.append(plain_text[i] ^ (int(next(prga))+6))\n    return cipher_text\n```\n\n\n\n​\t最后的解密代码如下，开始还把xor2的前后异或给解错了，应该从后往前解，还是没有理解的清清楚楚啊！\n\n```python\ncipher = [158, 31, 205, 434, 354, 15, 383, 298, 304, 351, 465, 312, 261, 442,397, 474, 310, 397, 31, 21, 78, 67, 47, 133, 168, 48, 153, 99, 103, 204, 137, 29, 22, 13, 228, 3, 136, 141, 248, 124, 26, 26, 65, 200, 7]\n\nfor i in range(len(cipher)-1,0,-1):\n    cipher[i] ^= cipher[i-1]\n\nfor i in range(len(cipher)):\n    cipher[i] ^= i\n\ndef KSA(key):\n    j = 0\n    S = list(range(256))\n    key_length = len(key)\n    for i in range(256):\n        j = (j + S[i] + key[i % key_length]) % 256\n        S[i], S[j] = S[j], S[i]\n    return S\n\ndef PRGA(S):\n    i = 0\n    j = 0\n    while True:\n        i = (i + 1) % 256\n        j = (j + S[i]) % 256\n        S[i], S[j] = S[j], S[i]\n        K = (S[i] + S[j]) % 256\n        yield K\n\ndef deRC4(plain, key):\n    S = KSA(key)\n    prga = PRGA(S)\n    for i in range(len(plain)):\n        plain[i] ^= (int(next(prga))+6)\n    for i in range(len(plain)):\n        plain[i] -= i\n    return plain\n\nkey = \"SYCFOREVER\"\nkey = [ord(i) for i in key]\nplain_text = deRC4(cipher, key)\nprint(\"\".join([chr(i) for i in plain_text]))\t\t#SYC{Bel1eve_thAt_you_a3e_Unique_@nd_tHe_beSt}\n```\n\n\n\n# 玩就行了\n\n​\tUnity逆向，玩黄金矿工小游戏，全屏还缩小不了。CE修改得分，通关后就提示“有什么东西遗漏了！”。我怎么知道。\n\n​\t然后打开**Data.txt**文件，我以敏锐的直觉看到开头的**4D5A**，这是exe程序的文件头，根本不是unity逆向！\n\n​\t无壳程序，直接拖入IDA。\n\n```c\nint __fastcall main(int argc, const char **argv, const char **envp)\n{\n  char Key[117]; // [rsp+2Bh] [rbp-55h] BYREF\n  char Myflag[108]; // [rsp+A0h] [rbp+20h] BYREF\n  int flag_len; // [rsp+10Ch] [rbp+8Ch]\n\n  sub_14000181E(argc, argv, envp);\n  strcpy(Key, \"GEEK\");\n  puts(\"WOW~~Niceeeee to see you here!!!\\n\");\n  puts(\"Welcome to GEEK Challenge!!!!!\\n\");\n  puts(\"Please input your answer~\\n\");\n  scanf(\"%s\", Myflag);\n  flag_len = strlen(Myflag);\n  sub_14000144B(Myflag, 20LL);\n  sub_140001596(Myflag, Key);\n  sub_14000161C(Myflag, &Key[5]);\n  if ( !strcmp(&Key[5], \"0A161230300C2D0A2B303D2428233005242C2D26182206233E097F133A\") )\n    puts(\"G00D!!!\");\n  else\n    puts(\"Try again.\");\n  puts(\"\\nPress any key to continue...\");\n  getchar();\n  return 0;\n}\n```\n\n​\t**sub_14000144B**函数是类凯撒密码，数字也移位了，偏移量20。\n\n​\t**sub_140001596**函数使用key异或加密。\n\n​\t**sub_14000161C**里面调用了**sub_140001408**函数，这个函数IDA反编译不太好看，其参数为buffer指针、格式化字符、字符数据。先猜测一下，别想着都搞清楚，其中有不少底层代码，该清楚很麻烦的啊，慢慢积累就好了。猜测就是进行一下格式转换，直接写脚本试试。\n\n```python\ndata = \"0A161230300C2D0A2B303D2428233005242C2D26182206233E097F133A\"\nkey = \"GEEK\"\nfor i in range(0, len(data), 2):\n    tmp = int(data[i:i+2], 16)\n    tmp ^= ord(key[(i // 2) % 4])\n    if ord('0') <= tmp <= ord('9'):\n        tmp = (tmp - ord('0') - 20) % 10 + ord('0')\n    elif ord('A') <= tmp <= ord('Z'):\n        tmp = (tmp - ord('A') - 20) % 26 + ord('A')\n    elif ord('a') <= tmp <= ord('z'):\n        tmp = (tmp - ord('a') - 20) % 26 + ord('a')\n    print(chr(tmp),end='') \t\t#SYC{cOnGraduulaTions_mIneR:D}\n```\n\n\n\n# 长颈鹿喜欢吃彩虹\n\n​\t运行一下，还挺好看。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250703124214319.png\" alt=\"image-20250703124214319\">\n\n​\tIDA打开，看到main函数，使用变量**v6**进行跳转，还没碰到过，这是什么混淆方式吧。其实一点点看，也可以分析出程序运行流程，但是先学习一下WP的方法，有一个说是**平坦化**，使用**b810插件**去除。（原来我之前安过啊）\n\n​\t这个插件下载教程可以去看[这个文章](https://lkliki.github.io/2023/09/28/ida%E6%8F%92%E4%BB%B6-d810%E5%AE%89%E8%A3%85%E5%92%8C%E4%BD%BF%E7%94%A8/)，我的IDA切换到了3.11.0版本的python（系统中的，自行下载的），然后通过`py -3.11.0 -m pip install xxx`命令安装好依赖，使用起来就是先打开插件，选择**unflattening ollvm**去平坦化的，点击start就算启动了。之后回到main函数，在汇编界面，按**U**、**C**、**P**、**F5**重新反编译一次，这时候插件就会起作用。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250703134023131.png\" alt=\"image-20250703134023131\">\n\n​\t可以看到，情况大不一样，效果很成功。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250703134312775.png\" alt=\"image-20250703134312775\">\n\n​\t这个encrypt函数平坦化之后还是挺难看的，一个变量挪动了好多位置，主要就看到一个异或操作，其中一个确定应该是输入的flag字符串，另一个贼难跟踪。当然，在异或处下断点动调（汇编指令处）应该是能看出来这两个值是什么的，但是我已经看过别人的WP了，人家直接猜的。\n\n​\t看看动调的方法吧，首先看到加密函数处，可以直接拿到Key是**BOb0m0oN**，可以确定Buffer的地址，可以选择下内存断点。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250703152243098.png\" alt=\"image-20250703152243098\">\n\n​\t看到异或处，一个是我的输入，另一个数**ecx**多看两轮就知道是逆序的Key了，规律也简单，大胆猜测，小心取值。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250703152641983.png\" alt=\"image-20250703152641983\">\n\n​\t最后看到比较处，取出加密输入和密文，我们其实可以通过输入特定的flag来确定每位的异或值是多少，这样也能解密。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250703152840984.png\" alt=\"image-20250703152840984\">\n\n​\t有点累人，真的是做题做久了，一点兴趣都没了。现在边做边记录，做了两整天了，早上起来开做，晚上结束回去睡觉，开始很有激情，不觉得累，做到这种攻坚的地方，就没精力了，缓几天再做吧。\n\n```python\nenc = [29, 54, 115, 22, 73, 45, 26, 29, 41, 6, 66, 44, 118, 7, 16, 14, 126, 57, 85, 50, 117, 3, 27, 29, 25, 95, 82, 35, 1, 3, 29, 63]\nkey = [0x42, 0x4f, 0x62, 0x30, 0x6d, 0x30, 0x6f, 0x4e]\nresult = []\nfor i in range(len(enc)):\n    print(chr((enc[i] ^ key[::-1][i % len(key)]) & 0xff), end='')\n#SYC{yOU_girAFe_L0Ve_EaT_W0bN1aR}\n```\n\n\n\n\n\n# AES!\n\n​\t无他，考察AES算法的理解。对我来说都无所谓，反正是新知识，没学过！不会可以看另一篇文章AES。\n\n​\t专门学了半天的AES，边理解边敲代码，最后还debug，搞定一些小的细节错误，终于大功告成！但是，那是密码学的知识，我们做题还得识别验证是不是标准的AES，具体看看代码的实现。\n\n​\t进入函数，输入flag后，验证长度是否是32位字节，然后使用**1C99**函数加密，~~下面的那个不知道干嘛~~，v7应该是flag的后一段，应该是反编译有问题，看汇编就很清楚了。传入参数，第一个是密钥，第二个是密钥长度，第五个是输入长度，会检查是否是16的倍数的。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250705164812604.png\" alt=\"image-20250705164812604\">\n\n​\t可以清楚的看到，是将flag分成了两次加密，第二次传入的地址都加上了偏移0x10。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250705165554915.png\" alt=\"image-20250705165554915\">\n\n​\t然后看到**sub_7FF60A701408**函数，里面是在做扩展轮密钥，先将初始16字节密钥换成4个32位字。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250705172649254.png\" alt=\"image-20250705172649254\">\n\n​\t后面的就很清晰了，就不一点点解析了，是在是有点懒了。**sub_7FF60A7016DC**是在取input的16字节复制到v7中，看汇编也能看出来**v12**是指向**v9**的。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250705173038449.png\" alt=\"image-20250705173038449\">\n\n​\t最后的解密代码如下。\n\n```python\nclass AES:\n    MIX_C = [[0x2, 0x3, 0x1, 0x1], [0x1, 0x2, 0x3, 0x1], [0x1, 0x1, 0x2, 0x3], [0x3, 0x1, 0x1, 0x2]]\n    MIX_C_INV = [[0xe, 0xb, 0xd, 0x9], [0x9, 0xe, 0xb, 0xd], [0xd, 0x9, 0xe, 0xb], [0xb, 0xd, 0x9, 0xe]]\n    RCON= [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 ,0x6c, 0xd8, 0xab, 0x4d]  # 实际只用到前10个\n    S_BOX = [[124, 202, 123, 119, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 71, 171],\n             [118, 99, 130, 201, 125, 250, 89, 240, 173, 212, 162, 175, 156, 164, 114, 192],\n             [183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21],\n             [4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117],\n             [9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132],\n             [83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207],\n             [208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168],\n             [81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210],\n             [151, 205, 12, 19, 236, 95, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115],\n             [96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219],\n             [224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121],\n             [231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8],\n             [186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138],\n             [112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158],\n             [225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 233, 206, 85, 40, 223, 140],\n             [161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22, 135]]\n\n    S_BOX_INV = [[82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 130, 242, 215, 250],\n              [124, 227, 57, 131, 155, 47, 254, 135, 52, 142, 67, 68, 196, 222, 233, 203],\n              [84, 123, 148, 50, 166, 194, 35, 61, 237, 76, 149, 11, 66, 249, 195, 78],\n              [8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37],\n              [114, 247, 245, 100, 134, 104, 152, 14, 212, 164, 92, 204, 93, 101, 182, 146],\n              [108, 112, 72, 80, 252, 236, 185, 218, 94, 22, 70, 87, 167, 141, 157, 133],\n              [144, 216, 171, 17, 140, 188, 211, 10, 246, 228, 88, 5, 184, 179, 69, 6],\n              [208, 44, 30, 143, 202, 63, 16, 3, 193, 175, 189, 2, 0, 20, 138, 107],\n              [58, 145, 18, 65, 79, 103, 220, 255, 151, 241, 207, 206, 239, 180, 230, 115],\n              [150, 172, 116, 34, 231, 173, 53, 128, 226, 248, 55, 232, 28, 117, 223, 110],\n              [71, 240, 26, 113, 29, 41, 197, 137, 111, 183, 98, 15, 170, 24, 190, 27],\n              [251, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 253, 120, 205, 90, 243],\n              [31, 221, 168, 51, 136, 7, 199, 49, 177, 19, 1, 89, 39, 129, 235, 95],\n              [96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 238],\n              [160, 224, 59, 77, 174, 42, 244, 176, 200, 234, 187, 60, 132, 83, 153, 97],\n              [23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 21, 99, 85, 33, 12, 125]]\n\n    def SubBytes(self, state, inv=False):\n        \"\"\"\n        对输入的state进行S盒置换。\n        state是一个16个字节元素的列表，以一维形式访问\n        返回值是变换后的二维列表\n        \"\"\"\n        for i,v in enumerate(state):\n            if inv == False:\n                state[i] = self.S_BOX[v>>4][v&0xf]\n            else:\n                state[i] = self.S_BOX_INV[v>>4][v&0xf]\n\n    def ShiftRows(self, state, inv=False):\n        \"\"\"\n        state是一个16个字节元素的列表，以一维形式访问\n        \"\"\"\n        for i in range(4):\n            if inv == False:\n                state[i::4] = state[i::4][i:] + state[i::4][:i] # 左移\n            else:\n                state[i::4] = state[i::4][-i:] + state[i::4][:-i]   # 右移\n\n\n    def MixColumns(self, state, inv=False):\n        def GFmul_by_2(n):\n            \"\"\"\n            这个计算是有数学意义的，不是简单的乘法运算，原理可自行了解GF域的定义。\n            :param n:\n            :return:\n            \"\"\"\n            s = (n << 1) & 0xff\n            if n & 128:\n                s ^= 0x1b\n            return s\n\n        def GFmul_by_3(n):\n            \"\"\"\n            :param n:\n            :return:\n            \"\"\"\n            return n ^ GFmul_by_2(n)\n\n        def mix_column(c):\n            return [\n                GFmul_by_2(c[0]) ^ GFmul_by_3(c[1]) ^ c[2] ^ c[3],\n                GFmul_by_2(c[1]) ^ GFmul_by_3(c[2]) ^ c[3] ^ c[0],\n                GFmul_by_2(c[2]) ^ GFmul_by_3(c[3]) ^ c[0] ^ c[1],\n                GFmul_by_2(c[3]) ^ GFmul_by_3(c[0]) ^ c[1] ^ c[2]\n            ]\n\n        if inv == False:\n            for i in range(0, 16, 4):\n                state[i:i + 4] = mix_column(state[i:i + 4])\n        else:\n            for i in range(0, 16, 4):\n                for _ in range(3):\n                    state[i:i + 4] = mix_column(state[i:i + 4])\n\n    def AddRoundKey(self, state, key):\n        for i in range(16):\n            state[i] ^= key[i]\n\n    def key_expansion(self, key):\n        key = bytearray(key)\n        for i in range(10 * 4):\n            r = key[-4:]\n            r = bytearray(r)\n            if i % 4 == 0:  # 对上一轮最后4字节，先循环左移一位，再S-box置换、轮常数异或，从而计算出当前新一轮最前4字节\n                for j, v in enumerate(r[1:] + r[:1]):\n                    r[j] = self.S_BOX[v >> 4][v & 0xf] ^ (self.RCON[i // 4] if j == 0 else 0)\n\n            for j in range(4):\n                key.append(key[-16] ^ r[j])\n\n        return key\n\n    def encrypt(self, b, expanded_key):\n        self.AddRoundKey(b, expanded_key)\n        for i in range(1, 10):\n            self.SubBytes(b)\n            self.ShiftRows(b)\n            self.MixColumns(b)\n            self.AddRoundKey(b, expanded_key[i*16:])\n\n        self.SubBytes(b)\n        self.ShiftRows(b)\n        self.AddRoundKey(b, expanded_key[-16:])\n        return b\n\n    def decrypt(self, b, expanded_key):\n        self.AddRoundKey(b, expanded_key[-16:])\n        for i in range(9, 0, -1):\n            self.ShiftRows(b, inv=True)\n            self.SubBytes(b, inv=True)\n            self.AddRoundKey(b, expanded_key[i*16:])\n            self.MixColumns(b, inv=True)\n\n        self.ShiftRows(b, inv=True)\n        self.SubBytes(b, inv=True)\n        self.AddRoundKey(b, expanded_key)\n        return b\n\n    def aes_ecb(self,type, key, msg):\n        expanded_key = self.key_expansion(key)\n        b = bytearray(msg)\n        if type == 0:\n            b = bytearray(msg+b'\\x00'*(16 - len(msg)%16))\n\n        for i in range(0, len(b), 16):\n            if type == 0:\n                b[i:i+16] = self.encrypt(b[i:i+16], expanded_key)\n            else:\n                b[i:i+16] = self.decrypt(b[i:i+16], expanded_key)\n        return bytes(b)\n\nif __name__ == '__main__':\n    key = b'SYCLOVERSYCLOVER'\n    aes = AES()\n    dec = aes.aes_ecb(1, bytearray(key), b'\\x99\\xe8\\xb8\\x01\\xc8\\x82\\x51\\x93\\x12\\xee\\x89\\x64\\xe7\\xef\\x63\\x8d\\x51\\xdf\\x5d\\x78\\x39\\xaa\\x39\\x62\\xa0\\xb4\\x50\\x30\\x47\\x30\\x21\\x06')\n    print('Decrypted:', dec)\t#SYC{B3l1eue_Th@t_y0u__l3aRn_Aes}\n```\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250705173544896.png\" alt=\"image-20250705173544896\">\n\n\n\n\n\n\n\n\n\n\n\n# blasting_master\n\n​\t\t无壳64位程序，IDA打开看到main函数，先是等待输入，然后循环，最后比较。我是调试了一遍，变量名变成了这个样子。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250706172043004.png\" alt=\"image-20250706172043004\">\n\n​\t先看循环的逻辑，进入**sub_555555555464**函数，其中有个全局变量**dword_555555558040**，初始值为0，函数每运行一次加1，**v4**存储输入字符串中的4个连续字符，其起始地址由**8040**变量决定。很明显看出来，每运行一次这个函数，就会往后1个字符。比如输入是**SYC{AAA}**，那么第一次就是取**SYC{**，第二次就是**YC{A**。\n\n​\t**sub_5555555553E2**函数里面的代码比较陌生，还是问AI才知道这是使用OpenSSL库计算MD5值的函数。\n\n```c\n__int64 __fastcall sub_5555555553E2(const char *a1, __int64 a2)\n{\n  __int64 v2; // rax\n  size_t v3; // rax\n  __int64 v5; // [rsp+18h] [rbp-8h]\n\n  v5 = EVP_MD_CTX_new();\n  v2 = EVP_md5();\n  EVP_DigestInit_ex(v5, v2, 0LL);\n  v3 = strlen(a1);\n  EVP_DigestUpdate(v5, a1, v3);\n  EVP_DigestFinal_ex(v5, a2, 0LL);\n  return EVP_MD_CTX_free(v5);\n}\n```\n\n​\t再下面就是16次循环处理得到的MD5值了，逻辑很清楚，只需要注意**s2**是字节数组。那这个函数就很清楚了，每次截取4个字符，计算MD5值，进行加密，然后存储到内存空间s2中去，**dword_555555558040**存储的就是MD5值个数。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250706172211561.png\" alt=\"image-20250706172211561\">\n\n​\t退回到main函数，循环结束条件是和**byte_5555555582DE**的值有关的，其非0即可停止循环。查看内存空间看到，该变量在s2尾部，因为每次写入的MD5是16个字节长度，即0x10，所以只有当写入`(0x82E0-0x8060)/0x10=28`个MD5值后，s2才会溢出到这个地方，使得循环退出。那我们也能得知到flag的长度就是3+28=31个字符长度。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250706173208026.png\" alt=\"image-20250706173208026\">\n\n​\t接下来的比较就没什么好说的了。取出MD5密文，解密后进行爆破即可。根据题目名称和提示也能猜到这题就是考爆破的，代码如下。\n\n```python\nimport hashlib\n\nen_md5 = \"b250a0bc3a7f546d96070f719a72eba5a0b571a46ab8bafae431c3715429a759202b1321bd675f8d653a0227084f929cb57cdf6934b8822df6ca7a659863dc512a34974ff8bc231f38a8a62fa90d644cac2ff9f52db191a8d576d92dc6ac2e6932d5641dc13cecf52c90edf4178b554ce46c3bb3da29c07b39df9273fcc9c2a86811222b643f129b95732a05d33f2e33f185ed077b868f622d7903ac80cef5b2a00cf7e1c50e6327d16523ea5a1c020b32ba1fe5c722a56677ea5be464ab8b60b6df00dcf76d93ec2f2f680750e0d11a3fc64e2ec6bbae0840d85b11b5dc15357f63493e5b9c0dfc0db680b72b00ef3c0c2feb864457749e5f1f8ba1c901f1d8f49282956f85d215221ff09fd1ab51399ab6c4dafb388de68c57195e94da57ccf0b90a4a1782fcc54f4b5aa5f4e53efa3a0af4b48e7f25847590cd3587ebc3ce812b86c9167e85682df1db8e7415cf955107885e1be937c95bba61eb9f7be48910f06ecd7571ad09745849a3f533837522951be33c48055cada86bfd41ebafc60228c65ecf36ae50ce93f270889d3f4a9f86e76764b002960cab9feb4b034492de6cf4ce324f4f38e25259ca954a11d830a27bd53ae611da3a4a3361396526d278bcedbda58b2b874c95472502ba833ddce46aad67dd22b1bd2b7c53113cd923063d20ba28c82d8951576382a0c8a8de2961c15351b0bc3704eec9358aa8a266ba6f24b63f62416d1046cb061239d90ef9dc19a765b8c040bef6999aaf0216374da5754c424b1af052da38f36ba91adcfa80b060b1fd737b78d9628326bf163371796f112fe9a7bb4646d68ff6217efc6812866bfc51c9707a74bc8f6e0b86426f5cfdf74e2771fe37e6c86247fcd56cba5cd9295a73aec38ff0469532422dd0\"\nflag = \"SYC{\"\nde_md5 = []\n\nfor i in range(len(en_md5)//32):\n    tp_str = en_md5[i*32:i*32+32]\n    t = [int(tp_str[j:j+2], 16) for j in range(0, len(tp_str), 2)]\n    for j in range(16):\n        t[j] = t[j] - (j % 15) * 82\n        t[j] = t[j] % 256\n        while (t[j] % 7 != 0):\n            t[j] += 256\n        t[j] //= 7\n        t[j] ^= (j + 42)\n    md5_str = \"\".join(hex(t[j])[2:].zfill(2) for j in range(16))\n    de_md5.append(md5_str)\n\nfor i in range(1,len(de_md5)):\n    for j in range(32,127):\n        test_str = flag[-3:] + chr(j)\n        test_md5 = hashlib.md5(test_str.encode()).hexdigest()\n        if test_md5 == de_md5[i]:\n            flag += chr(j)\n            break\n\nprint(flag)\t#SYC{W0w!y0u_@re_th3_BeSt_blasting_Exp3rt!!}\n```\n\n\n\n# ez_hook\n\n​\t无壳64位，打开看到一个简单的反调试，直接把**jz**（74）改为**jmp**（EB）。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250706185725865.png\" alt=\"image-20250706185725865\">\n\n​\t然后看到**sub_4016E4**函数，调试分析其输出的**v6**变量，应该是对flag进行顺序打乱的，这个简单，通过测试输入，得到输出就可以固定“映射方式”。\n\n​\t然后准备调试**sub_4017E0**函数的时候，发现根本没进去，怎么回事！原来在4016E4函数的结尾对内存中的函数进行了修改，在**sub_4017E0**函数头加了个jmp跳转，相对跳转（E9），跳到了**sub_4018B4**函数头。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250706190048229.png\" alt=\"image-20250706190048229\">\n\n```c\nBOOL __fastcall sub_401911(_BYTE *a1, int a2)\n{\n  __int64 v3; // [rsp+2Bh] [rbp-15h]\n  DWORD flOldProtect; // [rsp+34h] [rbp-Ch] BYREF\n  SIZE_T dwSize; // [rsp+38h] [rbp-8h]\n\n  dwSize = 5LL;\t\t//表示将要操作的内存区域大小\n    \n    //修改内存保护，改变内存区域 a1 所指向的 5 字节的保护属性，0x40u表示将内存区域设为可写（PAGE_EXECUTE_READWRITE），这样就可以修改内存。\n  VirtualProtect(a1, 5uLL, 0x40u, &flOldProtect);\n    \n    //构造指令，E9是jmp的操作码，后一行是在算地址偏移，-5是因为程序写入跳转指令已经占据了5字节。\n  LOBYTE(v3) = 0xE9;\n  *(_DWORD *)((char *)&v3 + 1) = a2 - (_DWORD)a1 - 5;\n    \n    //修改内存内容，先写4字节，再写1字节。\n  *(_DWORD *)a1 = v3;\n  a1[4] = BYTE4(v3);\n    \n    //恢复内存保护。\n  return VirtualProtect(a1, dwSize, flOldProtect, &flOldProtect);\n}\n```\n\n​\t而**sub_4018B4**函数很明显看出来是异或7，所以解密脚本如下。\n\n```python\nenc = \"zoXpih^lhX6soX7lr~DTHtGpX|\"\ninput = \"SYC{abcdefghijklmnopqrstu}\"\nencst = \"}rnjfbYusqomkigecaCStplhd{\"\t\t#调试提取v6的值得到\nenflag = \"\"\nfor i in range(len(enc)):\n    enflag += chr(ord(enc[i]) ^ 7)\nflag = \"\"\nfor i in range(len(enflag)):\n    flag += enflag[encst.index(input[i])]\nprint(flag)\t\t\t\t\t\t\t\t#SYC{you_kn0w_wh@t_1s_hoOk}\n```\n\n​\t其实也可以看看**sub_4016E4**函数的置换逻辑，首先外循环是3轮，**v7**是步长，先后是4、2、0。**Enflag**（简称e）是从下标0开始，到结束依次赋值的，**v12**就是其下标。\n\n​\t算了，细究起来发现前面的**sub_40167D**函数对flag也进行了打乱，4016E4是进行第二次打乱了。有点复杂，不想看啊，不想调了，就这样吧！\n\n​\t找了一个别人的脚本，包括顺序还原的，随便看看吧。\n\n```python\nc='zoXpih^lhX6soX7lr~DTHtGpX|'\ndef reverse_flag(a3, a2):\n    v8 = len(a3)  # a3 的长度\n    a1 = [''] * v8  # 初始化 a1 为长度为 v8 的空字符串列表\n    v12 = 0  # 计数器，用于跟踪读取 a3 的位置\n \tfor i in range(a2):\n        v9 = i\n        v7 = 2 * (a2 - i - 1)\n        j = 2 * i\n        while v9 < v8:\n            if v7:\n                a1[v9] = a3[v12]\n                v12 += 1\n            v10 = v7 + v9\n            if v10 >= v8:\n                break\n            if j:\n                a1[v10] = a3[v12]\n                v12 += 1\n            v9 = j + v10\n    return a1\na2 = 3  # 已知的 a2 值\na3=[0]*len(c)\nfor i in range(len(c)):\n    a3[i]=ord(c[i]) ^ 7\nreversed_flag = reverse_flag(a3, a2)\nflag=''\nfor a in reversed_flag:\n    flag+=chr(a)\nprint(\"Reversed flag:\", flag[::-1])\n```\n\n\n\n# 致我的星星\n\n​\t**好玩好玩！！！不玩包后悔的！！！强烈建议多做一会，这样就能少后悔一点。最好自己做出来**\n\n​\t**js**逆向，第一次做，看到**index.js**，没有使用很难的东西，基础语法会点就能看懂了。还是解析一下。\n\n​\t**funclick**函数是点击后更新界面的函数，然后**fl**被设置为处理键盘输入的响应函数，我们可以看到其比较MD5值后会调用**typewrite**函数，这是输出成功后提示信息的函数。所以我们的目标就是搞定这个MD5的字符串是什么。但是MD5爆破是不成功的（直接爆的也是狠人），只有继续看剩下的代码也没有什么提示了。\n\n​\t从197行开始，其实就是“多余”的代码，当然，没有必要肯定是不会放这段代码的（**反正我是没自己做出了，中间有脑洞没风暴成功！最后我是这样告诉自己的。**）很明显，221行到274行是在做迷宫的初始化，~~这我都明白~~，为什么告诉了行列是10*20，结果data只有180个字符，还得自己补？这是我的第一个犹豫点，我也做过补了的尝试，继续往后看。\n\n​\t第259到274行是纯提示选手自己计算出S和Y的坐标，但是有两个S和Y，我脑残了，这没能和后面联系起来，我的问题，短时间刷题刷多了是这样的。\n\n​\tmd，使用z3-solver还出了个错，之前脑残下了个z3包（不知道干嘛的），删也没删干净，污染了python环境，处理又浪费我的时间。\n\n```python\nfrom z3 import *\n\n#声明整数变量\na1, a2, a3, a4, a5, a6, a7, a8 = Ints('a1 a2 a3 a4 a5 a6 a7 a8')\n\n# 创建求解器\ns = Solver()\n\n# 添加方程组\ns.add(43654*a1 - 57003*a2 -3158*a3 + 30120*a4 -58621*a5 -41947*a6 +122237*a7 +129534*a8 == 2594143)\ns.add(-48022*a1 + 18308*a2 + 52478*a3 + 69397*a4  +49696*a5 + 12288*a6 -40437*a7 -23154*a8 == 651137)\ns.add(124109*a1  +58952*a2 + 16645*a3 -17531*a4 + 53139*a5  +49937*a6  + 3282*a7   +7656*a8 == 2071815)\ns.add(108286*a1 + 118886*a2 +116876*a3   +2281*a4 -64590*a5  -3021*a6 + 13386*a7 -56070*a8 == 703)\ns.add(105983*a1 + 8794*a2 + 31851*a3 -35052*a4  -7880*a5  + 2183*a6 + 47575*a7 +107236*a8 == 2511919)\ns.add(-38005*a1 -6833*a2 +107897*a3 +119771*a4 +124322*a5 + 13335*a6+ 121590*a7 -17434*a8 == 4816084)\ns.add(60696*a1 +95253*a2 +101581*a3 + 93822*a4 +112989*a5  +65643*a6  +45639*a7 + 26705*a8 == 5330538)\ns.add(49019*a1 +72343*a2 -21814*a3  +85020*a4 -62332*a5  +99828*a6  +  587*a7 -65119*a8 ==  505173)\n\n# 检查可解性\nif s.check() == sat:\n    model = s.model()\n    for v in [a1, a2, a3, a4, a5, a6, a7, a8]:\n        print(f\"{v} = {model[v]}\")\nelse:\n    print(\"无解\")\n    \n\"\"\"\na1 = 3\na2 = 4\na3 = 6\na4 = 8\na5 = 13\na6 = 13\na7 = 15\na8 = 15\n\"\"\"\n```\n\n​\t考脑洞吗？？？😅😅😅~~我咋感觉这个index.js文件里面的逻辑都有问题啊，执行起来根本通关不了。~~\n\n​\t从277行到结尾都是在做走迷宫的部分了，但是代码逻辑就是有问题，你会发现xy坐标根本没有更新。选手要从错误的代码中，猜出出题人正确的思路！\n\n​\t在**findtheway**函数中会直接进入死循环，输入正确的答案，**findtheway**控制台调用也会进入死循环，这就不是让我玩的，是让我看的！\n\n​\t这也就算了，从明显的错误中猜到正确的思路，像我这种小白都能看出错误，难道出题人看不出来吗？~~这里不算什么，我也能看出来要跑两次。~~实际上，第一次做这种题，被他这个错误代码逻辑给吓住了，我都想举报题错了，很难有继续思考的想法了，很想找WP验证我的“举报”是正确的！\n\n​\t无所谓，我其实还在尝试，两个迷宫就两个迷宫，输两次就输两次。但是**最完蛋的是**迷宫的提示信息我没转过弯来，忘记了**第i行对应的是数组中第(i-1)行，第i列对应的是数组中的第(i-1)列**，导致我迷宫复现错误，这种东西一时半会真反应不过来，也可能是前面也就脑子过载了，我就不想浪费时间了，就直接看WP了。\n\n​\t挺遗憾的，没自己独立做出了，少了一份感动......\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250706215042186.png\" alt=\"image-20250706215042186\">\n\n​\t以上是我的思维过程和一些吐槽，下面是完美做法。\n\n​\t先补充完data到200字节，补“#”。然后求解出S和Y的坐标，编写**js**脚本得到迷宫字符串，我喜欢通过python输出迷宫。\n\n```javascript\nlet data = [\n    '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#',\n    '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#',\n    '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#',\n    '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#',\n    '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#',\n    '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#',\n    '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#',\n    '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#',\n    '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#',\n    '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#', '#'\n];\n\nlet coordinates = [\n    [1, 11], [1, 12], [1, 13], [1, 14],\n    [2, 1], [2, 4], [2, 11], [2, 12], [2, 14],\n    [3, 4], [3, 14],\n    [5, 7], [5, 8], [5, 12], [5, 14], [5, 15], [5, 18],\n    [6, 1], [6, 2], [6, 4], [6, 5], [6, 7], [6, 8], [6, 11], [6, 15],\n    [7, 1], [7, 5], [7, 11], [7, 12], [7, 13], [7, 14], [7, 15], [7, 16],\n    [8, 1], [8, 12], [8, 13], [8, 15], [8, 18],\n    [9, 3], [9, 4], [9, 6], [9, 7], [9, 8]\n];\n\nlet cols = 20;\nlet rows = 10;\n\ncoordinates.forEach(([row, col]) => {\n   \n    const index = row * cols + col;\n    \n    if (index >= 0 && index < data.length) {\n        data[index] = '*';\n    }\n});\n\ndata[2*cols + 12] = 'S';\ndata[7*cols + 12] = 'S';\ndata[3*cols + 14] = 'Y';\ndata[5*cols + 14] = 'Y';\n\nlet map = data.slice();\nconsole.log(map.join(''));\n```\n\n​\t得到迷宫后自己能够手写出来路径，第一个是STTAAARRRR，第二个迷宫是AAATTTTS，合在一起就得到了应该输入的input字符串**STTAAARRRRAAATTTTS**，flag为**SYC{STTAAARRRRAAATTTTS}**。\n\n​\t可以通过计算一下MD5值验证一下，实际上是要在网页中按下这些字符，然后才能跳转到正确提示页面。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250706215937333.png\" alt=\"image-20250706215937333\">\n\n\n\n\n\n\n\n# LinkedListModular\n\n​\t\t这题就应该放在密码板块，后面单独出一篇文章吧。\n\n> ​\t公司职员发现关键数据被加密了，请帮忙解密出来，注意e和phi。flag为输入的256长度的hex字符串的md5值，并包裹flag{}提交。该题需要一些逆向基础(C实现的程序，内含链表、gmp库相关)，可与队友联合解题，也可学习些二进制基础，对以后有益。\n\n​\t还是无壳，打开IDA查看，进到**check**函数分析。\n\n​\t**saveinp**分析很简单看出来，是把256位分成4个64位块，形成链表结构。\n\n​\t**__gmp_randinit_default**函数没见过，问下AI。\n\n\n\n------\n\n\n\n> `__gmp_randinit_default` 是 GNU MP（GMP）库中的一个函数，用于**初始化默认的伪随机数生成器（PRNG）状态对象**。这个函数是 GMP 的一部分，而 GMP 是一个用于高精度整数、浮点数和有理数运算的 C/C++ 数学库。\n>\n> 函数原型：void __gmp_randinit_default(gmp_randstate_t state);\n>\n> 初始化后，你可以使用这个状态对象来生成伪随机 GMP 整数，例如通过 `mpz_urandomb` 或 `mpz_urandomm`。\n\n​\t**__gmpz_urandomb**函数生成长度为n的随机大整数。\n\n​\t**__gmpz_nextprime**用于查找一个给定数的下一个素数。\n\n​\t**__gmpz_sub_ui**用于执行大整数减去一个无符号长整数的操作，函数原型：`void __gmpz_sub_ui(mpz_ptr result, mpz_srcptr op1, unsigned long int op2);`。\n\n​\t**__gmpz_mul**实行大整数的乘法运算，参数1是result。\n\n​\t**__gmpz_gcd**计算两个大整数的最大公约数。\n\n​\t**__gmpz_divexact**用于计算两个大整数的整除，前提是被除数能够被除数整除（即没有余数），否则会报错。\n\n​\t**__gmpz_invert**计算模逆元，参数为result、op1、op2，其中op2是模数。\n\n​\t**__gmpz_get_ui**函数获取 `mpz_t` 类型大整数的低位无符号整数部分，返回一个 `unsigned long` 值。如果大整数超出 `unsigned long` 的范围，只返回低位部分（截断高位）。\n\n​\t**__gmpz_init_set_str**用于初始化一个大整数变量并用字符串来设置它的值。\n\n​\t**__gmpz_powm**用于计算大整数的**模幂运算**，标准接口原型：`void mpz_powm(mpz_t result, const mpz_t base, const mpz_t exp, const mpz_t mod);`。\n\n​\t<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250707102347257.png\" alt=\"image-20250707102347257\">\n\n​\t**__gmpz_get_str**用于将 GMP 的多精度整数（`mpz_t` 类型）转换为字符串。\n\n<img src=\"/pictures/af78d0f39e337f6562dcfb2001f2d726/image-20250707102512708.png\" alt=\"image-20250707102512708\">\n\n​\t\n\n```c\n//使用示例\n#include <gmp.h>\n\nint main() {\n    gmp_randstate_t state;\t//定义一个 GMP 随机数生成器的“状态对象”\n    mpz_t rand_num;\t\t\t//定义一个 GMP 多精度整数变量 rand_num，用于存储我们要作为种子的值（这里是 123456）。\n\n    // 初始化随机数生成器 state，使用 GMP 默认算法（通常是线性同余生成器 LCG）。\n    __gmp_randinit_default(state);\t\n\n    // 设置种子\n    mpz_init_set_ui(rand_num, 123456);\t//初始化 rand_num 为 GMP 整数，并赋值为 123456\n    gmp_randseed(state, rand_num);\t//设置随机数生成器 state 的种子为 rand_num（即 123456）。\n\n    // 生成一个最大为 100 的随机数\n    mpz_t result;\n    mpz_init(result);\t//定义并初始化一个 GMP 多精度整数 result，用于存放生成的随机数。\n    mpz_urandomm(result, state, rand_num);  //使用 state 中的随机状态生成一个随机大整数 result，满足 0 <= result < rand_num（即小于 123456）\n\n    gmp_printf(\"Random number: %Zd\\n\", result);\n\n    // 清理内存\n    mpz_clear(result);\n    mpz_clear(rand_num);\n    gmp_randclear(state);\n\n    return 0;\n}\n```\n\n​\t**sprintf**是用来把格式化的数据写入字符串（字符数组）中，而不是直接输出到屏幕。\n\n​\t**fprintf**是用于将格式化的数据写入指定的文件流。\n\n------\n\n​\tWC，密码！哎呀，难办哦。数学课，数学课！\n\n​\t会不了一点，加密算法都认不出来，直接看WP吧。\n\n\n\n","tags":["Reverse"],"categories":["CTF"]},{"title":"初识SEH","url":"/2025/07/07/初识SEH/SEH/","content":"\n## 前言\n\n​\t本文的初衷是因为一个逆向题目中的疑难问题，同时也解决对SEH机制的理解。\n\n​\t大佬博客文章都讲的非常详细了，那么我建议直接去看参考文章，下面正文算是我的一些疑问和特别知识点的记录吧，会比较零碎。\n\n\n\n## 正文\n\n​\t**SetThreadContext**函数是一个**Windows API**函数，可以修改一个**现有线程**的执行上下文，其**lpContext**指向一个结构体，里面存储着线程环境，包括各种寄存器值、EIP和堆栈信息等等。我们可以修改EIP的值，实现远程代码注入，而不需要创建新的线程。\n\n```c\nBOOL SetThreadContext(\n  HANDLE hThread,            // 线程的句柄\n  CONST CONTEXT* lpContext   // 要设置的上下文结构体（CULTEXT）\n);\n```\n\n​\t一般代码注入的思路就是：获取目标进程的句柄，然后分配内存（用VirtualAllocEx）写入DLL路径（我们的代码），压入栈顶，然后获取**LoadLibraryA**函数地址，获取线程上下文，设置EIP为LoadLibraryA，恢复线程，让它执行。DLL文件被加载后，系统会自动调用它的入口函数**DllMain**（其在多种情况下会被调用，比如被进程加载、被进程卸载、被线程加载、被线程卸载等等），我们就可以在其中写入“主动执行”的代码。\n\n```c\n1.OpenThread     打开一个线程\n2.SuspendThread 暂定这个线程\n3.VirtualAllocEX    申请空间\n4.WriteProcessMemory  写入DLL路径\n5.修改Eip\n6.ResumeThread  启动线程\n```\n\n​\t\n\n------\n\n​\t**段寄存器（Segment Register）** 是 x86 架构中的一种特殊寄存器，用来表示不同类型的内存区域（段）。这些寄存器是用来帮助 CPU 访问内存中的不同部分的。比如说段式管理下，程序分为代码段（CS）、数据段（DS）、栈段（SS）、附加段（ES）、附加段1（FS）、附加段2（GS），其段寄存器起到存储基址的作用，具体访问时是**内存地址 = 段寄存器 * 16 + 偏移量**。\n\n\n\n​\t**节**这个概念也很常见，是程序在编译时分割的内存区域，通常用于表示程序中不同的内容。\n\n​\t**节与段的不同**：段主要用于运行时内存的组织（CPU通过段寄存器来定位），而节是程序在编译、链接时的内存划分，用来表示不同类型的代码和数据。在编译和链接阶段，编译器和链接器会把程序分成不同的节，并指定它们在最终可执行文件中的位置。\n\n​\t\n\n------\n\n​\t内联汇编反调试例子，这个反调试思路是检测到调试就让程序崩溃，不能使用**ExitProcess**退出，因为容易被别人据此API函数跟踪找到反调试的地方。崩溃的思路可以是，开一个新线程，然后给NULL指针赋值。\n\n```c\n#include \"stdafx.h\"\n#include <STDLIB.H>\nint main(int argc, char* argv[])\n{\n    char isDbg;\n    __asm\n    {\n        mov eax,fs:[0x18]            //找到teb的位置\n        mov eax,[eax + 0x30]        //teb + 30找到PEB的位置,对其取内容得到第一个首地址\n        mov eax,[eax+0x2]            //首地址 + 偏移找到debug的位置对其取内容\n        mov isDbg,al                //求出是否在调试 ,因为BeingDebugged是UChar类型，所以使用al                         \t\t\n         //或者直接找peb查看\n         //mov eax,fs:[0x30]\n\t\t//mov eax,[eax +0x2]\n\t\t//mov isdbg,al\n    }\n    printf(\"%d\\r\\n\",isDbg);\n    system(\"pause\");\n}\n```\n\n​\t另外，PEB中还存储着Windows 系统中的模块链表，通常是由其Ldr（Loader）字段表示的，我们可以遍历模板链表，找到目标板块后，可以通过修改链表指针将该节点删除，从而让操作系统和其他工具看不到整个板块。按道理，程序还能正常运行的，但是调试器可能会依赖这个链表信息，所以调试可能会失败。\n\n------\n\n​\t**C05**或**C0005**是Windows系统的一个错误代码，表示 **\"Access Violation\"**，即访问违规。这通常发生在程序尝试访问它不应该访问的内存位置时。例如，程序可能试图读取一个空指针或写入只读内存。\n\n​\t常见情况：空指针引用、堆栈溢出或堆内存破坏、数组越界、访问权限问题。\n\n------\n\n​\t前置知识：FS段的信息如下。\n\n<img src=\"/pictures/d728253053486fc8f09f9fab7374373e/image-20250707153320830.png\" alt=\"image-20250707153320830\">\n\n​\t通过windbg查看FS段的信息如下。\n\n<img src=\"/pictures/d728253053486fc8f09f9fab7374373e/image-20250707153413085.png\" alt=\"image-20250707153413085\">\n\n​\t继续看**_NT_TIB**的指向的内容，偏移0处是异常链表，偏移4就是回调函数了（函数指针）。系统为每一个函数都注册了异常处理回调函数，是依次通过链表来查找使用的。\n\n<img src=\"/pictures/d728253053486fc8f09f9fab7374373e/image-20250707153514506.png\" alt=\"image-20250707153514506\">\n\n​\t下面是一个异常处理的代码注册的代码，重点讲解一下其中注册的地方——第一个内联汇编处，先将函数地址压栈，然后将**FS:[0]**压栈，再将esp的值传给**FS:[0]**，那么在调用异常处理函数时，通过**[FS:[0]+0x4]**得到的函数地址就是我们之前push进去的函数地址了，而继续找回调函数就是通过**[FS:[0]]**来得到下一个节点的地址，刚好esp指向的是原来的FS:[0]，那么程序还能继续正常运行，我们相当于往链表最开头插入了一个节点。\n\n```c\n#include \"stdafx.h\"\n#include <WINDOWS.H>\n#include <STDLIB.H>\n#include <WINNT.H>\n \nEXCEPTION_DISPOSITION __cdecl HANDLER1(\n                                       struct _EXCEPTION_RECORD *ExceptionRecord,\n                                       void * EstablisherFrame,\n                                       struct _CONTEXT *ContextRecord,\n                                       void * DispatcherContext)\n{\n \n    MessageBox(NULL,\"我处理了异常\\r\\n\",NULL,NULL);\n    return ExceptionContinueSearch;\n}\nvoid fun1()\n{\n    __asm\n    {\n        push offset HANDLER1\n        push fs:[0]\n        mov fs:[0],esp\n    }\n     char *p = NULL;\n     *p = 1;\n    __asm\n    {\n        pop fs:[0]\t\t//还原原来的结构\n        add esp,4\n        ret\n    }\n}\nint main(int argc, char* argv[])\n{    \n    fun1();    \n    system(\"pause\");\n}\n```\n\n------\n\n​\tC++中的函数**func1**调用了**func2**，**func1**有回调函数，**func2**没有注册异常处理，现在**func2**运行时出现异常后，会往上一层寻找找到**func1**的回调函数。\n\n​\t如下面的代码。\n\n```c\n// SEHecpt.cpp : Defines the entry point for the console application.\n//\n\n#include \"stdafx.h\"\n#include <WINDOWS.H>\n#include <STDLIB.H>\n#include <WINNT.H>\n\nvoid fun2();\n\nEXCEPTION_DISPOSITION __cdecl HANDLER1(\n                                       struct _EXCEPTION_RECORD *ExceptionRecord,\n                                       void * EstablisherFrame,\n                                       struct _CONTEXT *ContextRecord,\n                                       void * DispatcherContext)\n{\n\n    MessageBox(NULL,\"我处理了异常\\r\\n\",NULL,NULL);\n    return ExceptionContinueSearch;\t\t\t\t\t//返回继续搜索，表示当前回调函数处理不了，需要往上一层再找回调函数处理。\n}                   \nvoid fun1()\n{\n    __asm\n    {\n       \n        push offset HANDLER1\n        push fs:[0]\n        mov fs:[0],esp\n    }\n\n    fun2();\n     char *p = NULL;\n     *p = 1;\n    __asm\n    {\n        pop fs:[0]\n        add esp,4\n        ret\n    }\n}\nvoid fun2()\n{\n    char *p =NULL;\n    *p = 1;\n}\n\nint main(int argc, char* argv[])\n{\n    fun1();    \n    system(\"pause\");\n}\n```\n\n​\t\n\n------\n\n​\t什么是**异常展开**？\tAI的解释是：“**异常展开**”是指在程序发生异常时，操作系统或运行时环境**从当前异常点逐层向上查找处理该异常的地方**，并在这个过程中清理资源、撤销函数调用栈的过程。\n\n> ​\t简单来说就是 fun1 调用fun2 fun2出现了异常,自己的异常链表来不及卸载（func2和func1写一样的注册和卸载）,此时只能交给fun1去处理,那么现在我们应该把链表的位置重置为fun1的异常链表,fun2的不在需要了.否则操作系统调用的时候则是调用了一个错误的地址。\n>\n> ​\t说到释放的时候我们上面说了,操作系统会根据错误标志2,来接着调用一次我们的异常回调函数,这就是因为在操作系统帮我们卸载这个异常链表,但是会依次的调用一次我们的回调函数,通知我们,该释放资源的释放资源,该处理的处理,给我们一次释放资源的机会。\n\n------\n\n> 异常处理处理发生的时候,会有顺序的\n>\n> ​\t1.系统首先发送给调试器 调试器优先级最高\n>\n> ​\t2.如果没有调试器,系统会继续查找线程相关的异常处理,\n>\n> ​\t3.每个线程相关的异常处理例程,可以处理或者不处理这个异常,如果不处理,并且安装了多个线程相关的处理例程,可交给连起来的其它例程处理\n>\n> ​\t4.不处理这个异常,在判断程序是否在调试状态,如果在就接着给调试器\n>\n> ​\t5.如果没有的话,或者不处理,那么操作系统就会调用筛选器异常\n>\n> ​\t6.如果没有,那么系统会调用默认的异常处理,也就是崩溃的的界面\n>\n> ​\t7.在终结之前,对其展开操作,然后依次调用设置的SEH链表中的回调函数,给予一次最后清理的机会.\n\n\n\n​\tthrow语句抛出异常也是使用API，前两个参数分别是错误代码、错误标志，后两个是用户自定义的。\n\n```c\nvoid RaiseException(DWORD dwExeptionCode,\n　　　　　　　　　DWORD   dwExceptionFlages\n　　　　　　 　　 DWORD nNumberOfArguments,\n　　　　　　  　　Const DWORD * lpArguments)\n```\n\n\n\n\n\n\n\n\n\n## 参考文章\n\n​\t[异常处理第一讲](https://www.cnblogs.com/iBinary/p/7566380.html)、[异常处理第二讲](https://www.cnblogs.com/iBinary/p/7596199.html)、[异常处理第三讲](https://www.cnblogs.com/iBinary/p/7599713.html)。还有一个IDA的[功能详解](https://leeyuxun.github.io/IDA%E5%9F%BA%E7%A1%80%E5%8A%9F%E8%83%BD%E6%80%BB%E7%BB%93.html)，感觉挺好的，忘了可以再查。","tags":["Reverse","Windows"],"categories":["CTF"]},{"title":"初识AES","url":"/2025/07/06/初识AES/AES/","content":"\n## 前言\n\n\n\n​\t使用python实现，主要是熟悉加密流程，并且加强python编程能力。[参考文章1](https://sxyz.blog/aes-from-scratch/)，[参考文章2](https://blog.csdn.net/qq_28205153/article/details/55798628)，小白就是喜欢记录学习过程，为省时就边学边写，很多想法都是第一反应，如有错误望指出。\n\n\n\n## python知识点\n\n​\tpython中的参数传递，分为可变对象传递和不可变对象传递，本质上是引用传递。\n\n​\t可变对象传参，如list、dict、set等类型对象，参数传递的是对象的引用，因此函数内能够修改传入的变量。\n\n```python\ndef foo(a):\n    a.append(10)\n\nlst = [1, 2, 3]\nfoo(lst)\nprint(lst)  # 输出: [1, 2, 3, 10]\n```\n\n​\t不可变对象传参，如int、str、tuple等类型对象，函数内部修改参数，是不会影响外部的变量的。\n\n```python\ndef foo(a):\n    a = a + 1\n\nx = 5\nfoo(x)\nprint(x)  # 输出: 5\n#a = a + 1 实际是重新绑定了局部变量 a，外面的 x 不受影响。\n```\n\n​\t如果重新绑定参数名，是不会影响外部变量的。\n\n```python\ndef foo(a):\n    a = [4, 5, 6]  # 给a重新赋值\n\nlst = [1, 2, 3]\nfoo(lst)\nprint(lst)  # 输出: [1, 2, 3]\n```\n\n\n\n\n\n## AES 128位密钥  ECB模式加密\n\n​\tAES是分组加密算法，每次加密的输入是128位，也就是分块大小。输出也是128位，8*16，可表示为16个字节。\n\n\n\n### 1. 加密流程\n\n​\t共十轮加密，除却**开头的一次轮密钥加**（不算在十轮中）和最后一轮，剩余9轮操作是一样的。\n\n​\t中间的9轮都是进行**字节替换、行移位、列混淆、轮密钥**加四个操作，最后一轮没有**列混淆**这一步骤。\n\n​\t在代码中，输入state是以一维列表形式存储的，key也是以一维列表形式存储的，但是其表示的矩阵是如下的，我们之后讨论的操作都是在这种排列的矩阵基础上进行的。\n\n<img src=\"/pictures/初识AES/image-20250705115307045.png\" alt=\"image-20250705115307045\">\n\n​\t其中S盒是一个16*16的二维列表，其正常表示即`S[0][1]`表示第0行第1列的元素。\n\n#### 字节替换\n\n​\t我们知道`state[i]`都是一个字节元素，取前4位作为行号，后4位作为列号，然后按照行列号取S盒中的元素来替代state[i]。\n\n​\t这是可逆操作，其逆操作就是根据S盒算出逆S盒（S盒生成和逆盒原理可以自行学习），然后进行同样的替换。\n\n```python\n    def SubBytes(self, state, inv=False):\n        \"\"\"\n        对输入的state进行S盒置换。\n        state是一个16个字节元素的列表，以一维形式访问\n        返回值是变换后的二维列表\n        \"\"\"\n        for i,v in enumerate(state):\n            if inv == False:\n                state[i] = self.S_BOX[v>>4][v&0xf]\n            else:\n                state[i] = self.S_BOX_INV[v>>4][v&0xf]\n```\n\n\n\n\n\n#### 行移位\n\n​\t针对前图中的state矩阵，运行规则是：第i行的元素左循环移位(i-1)位，行数从1开始，例如第二行1、5、9、13就会变成5、9、13、1。\n\n​\t其逆操作就是循环右移同样的位数。\n\n​\t我们通过切片操作实现，`state[i::4]`就是从下标i开始，按步长4取值，正好得到第i行元素。`state[i::4][-i:]`表示取第i行的后面（i-1）个元素，例如当i=1时，其为state[13]，当i=2时，其为`state[10],state[14]`。\n\n```python\n    def ShiftRows(self, state, inv=False):\n        \"\"\"\n        state是一个16个字节元素的列表，以一维形式访问\n        \"\"\"\n        for i in range(4):\n            if inv == False:\n                state[i::4] = state[i::4][i:] + state[i::4][:i] # 左移\n            else:\n                state[i::4] = state[i::4][-i:] + state[i::4][:-i]   # 右移\n```\n\n​\t\n\n\n\n#### 列混淆\n\n​\t列混淆是对上面矩阵的每一列与一个**特定的矩阵M**（一般是固定的，如下图）做乘法运算，得到新的值，针对的还是上面的那个矩阵。\n\n<img src=\"/pictures/初识AES/image-20250705124744021.png\" alt=\"image-20250705124744021\">\n\n​\t因为特定的矩阵存在下面的性质，所以解密就是重复三次加密。\n$$\n\\\nM^4 = M \\cdot M^{-1} = E\n$$\n<img src=\"/pictures/初识AES/image-20250705122301118.png\" alt=\"image-20250705122301118\">\n\n```python\n    def MixColumns(self, state, inv=False):\n        def GFmul_by_2(n):\n            \"\"\"\n            这个计算是有数学意义的，不是简单的乘法运算，原理可自行了解GF域的定义。\n            :param n:\n            :return:\n            \"\"\"\n            s = (n << 1) & 0xff\n            if n & 128:\t\t\t\t\t#注意，这里不要抄错了！！！\n                s ^= 0x1b\n            return s\n\n        def GFmul_by_3(n):\n            \"\"\"\n            :param n:\n            :return:\n            \"\"\"\n            return n ^ GFmul_by_2(n)\n\n        def mix_column(c):\n            return [\n                GFmul_by_2(c[0]) ^ GFmul_by_3(c[1]) ^ c[2] ^ c[3],\n                GFmul_by_2(c[1]) ^ GFmul_by_3(c[2]) ^ c[3] ^ c[0],\n                GFmul_by_2(c[2]) ^ GFmul_by_3(c[3]) ^ c[0] ^ c[1],\n                GFmul_by_2(c[3]) ^ GFmul_by_3(c[0]) ^ c[1] ^ c[2]\n            ]\n\n        if inv == False:\n            for i in range(0, 16, 4):\n                state[i:i + 4] = mix_column(state[i:i + 4])\n        else:\n            for _ in range(3):\n                for i in range(0, 16, 4):\n                    state[i:i + 4] = mix_column(state[i:i + 4])\n```\n\n\n\n#### 轮密钥加\n\n​\t将对应的密钥**列表**与状态**列表**的元素进行异或即可。\n\n<img src=\"/pictures/初识AES/image-20250705130308252.png\" alt=\"image-20250705130308252\">\n\n```python\n    def AddRoundKey(self, state, key):\n        for i in range(16):\n            state[i] ^= key[i]\n```\n\n\n\n\n\n### 2. 密钥扩展算法\n\n​\tAES系列算法的密钥可能位数为128、192、256，以128为例，`W[i]`是由`K[i:i+4]`组成的32位，我们会由初始的`W[0:4]`这四个字通过密钥扩展得到后面的40个字`W[4:44]`，其中每一轮会用到`W[i:i+4]`四个字进行轮密钥加操作。初始的4个字是用在第一轮前的轮密钥加的。\n\n<img src=\"/pictures/初识AES/image-20250705125157750.png\" alt=\"image-20250705125157750\">\n\n​\t具体计算过程就是，从i=4开始，👍如果i不是4的倍数，那么W[i]就是W[i-1]^W[i-4]。等价成字节操作就是，每4个key一组，若对应的W[i]的i不是4的倍数，那么`key[-16]^r[j]`就是`W[i-1]^W[i-4]`的逐字节操作，其中key[-16]对应W[i-4]中的字节，r[i]对应W[i-1]中的字节。✌️如果是4的倍数，则要对最后的4字节进行一系列加密，`r[1:] + r[:1]`就是将r切片左移一位，其他也很显然。需要注意的是，轮密钥常数也有写成**0x01000000**这种形式的，这种是在字的级别进行操作的，我们是在逐字节处理，所以要通过`if j == 0 else 0`来补充00。\n\n​\t注意，其中`r = key[-4:]`得到的是一个新的切片对象，修改r不会影响key中的值。\n\n```python\n    def key_expansion(self, key):\n        for i in range(10 * 4):\n            r = key[-4:]\n            if i % 4 == 0:  # 对上一轮最后4字节自循环、S-box置换、轮常数异或，从而计算出当前新一轮最前4字节\n                for j, v in enumerate(r[1:] + r[:1]):\n                    r[j] = self.S_BOX[v >> 4][v & 0xf] ^ (self.RCON[i // 4] if j == 0 else 0)\n\n            for j in range(4):\n                key.append(key[-16] ^ r[j])\n\n        return key\n```\n\n\n\n\n\n\n\n\n\n### 3. 整体加解密代码\n\n```python\nclass AES:\n    MIX_C = [[0x2, 0x3, 0x1, 0x1], [0x1, 0x2, 0x3, 0x1], [0x1, 0x1, 0x2, 0x3], [0x3, 0x1, 0x1, 0x2]]\n    MIX_C_INV = [[0xe, 0xb, 0xd, 0x9], [0x9, 0xe, 0xb, 0xd], [0xd, 0x9, 0xe, 0xb], [0xb, 0xd, 0x9, 0xe]]\n    RCON= [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 ,0x6c, 0xd8, 0xab, 0x4d]  # 实际只用到前10个\n    S_BOX = [[124, 202, 123, 119, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 71, 171],\n             [118, 99, 130, 201, 125, 250, 89, 240, 173, 212, 162, 175, 156, 164, 114, 192],\n             [183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21],\n             [4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117],\n             [9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132],\n             [83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207],\n             [208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168],\n             [81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210],\n             [151, 205, 12, 19, 236, 95, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115],\n             [96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219],\n             [224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121],\n             [231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8],\n             [186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138],\n             [112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158],\n             [225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 233, 206, 85, 40, 223, 140],\n             [161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22, 135]]\n\n    S_BOX_INV = [[82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 130, 242, 215, 250],\n              [124, 227, 57, 131, 155, 47, 254, 135, 52, 142, 67, 68, 196, 222, 233, 203],\n              [84, 123, 148, 50, 166, 194, 35, 61, 237, 76, 149, 11, 66, 249, 195, 78],\n              [8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37],\n              [114, 247, 245, 100, 134, 104, 152, 14, 212, 164, 92, 204, 93, 101, 182, 146],\n              [108, 112, 72, 80, 252, 236, 185, 218, 94, 22, 70, 87, 167, 141, 157, 133],\n              [144, 216, 171, 17, 140, 188, 211, 10, 246, 228, 88, 5, 184, 179, 69, 6],\n              [208, 44, 30, 143, 202, 63, 16, 3, 193, 175, 189, 2, 0, 20, 138, 107],\n              [58, 145, 18, 65, 79, 103, 220, 255, 151, 241, 207, 206, 239, 180, 230, 115],\n              [150, 172, 116, 34, 231, 173, 53, 128, 226, 248, 55, 232, 28, 117, 223, 110],\n              [71, 240, 26, 113, 29, 41, 197, 137, 111, 183, 98, 15, 170, 24, 190, 27],\n              [251, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 253, 120, 205, 90, 243],\n              [31, 221, 168, 51, 136, 7, 199, 49, 177, 19, 1, 89, 39, 129, 235, 95],\n              [96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 238],\n              [160, 224, 59, 77, 174, 42, 244, 176, 200, 234, 187, 60, 132, 83, 153, 97],\n              [23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 21, 99, 85, 33, 12, 125]]\n\n    def SubBytes(self, state, inv=False):\n        \"\"\"\n        对输入的state进行S盒置换。\n        state是一个16个字节元素的列表，以一维形式访问\n        返回值是变换后的二维列表\n        \"\"\"\n        for i,v in enumerate(state):\n            if inv == False:\n                state[i] = self.S_BOX[v>>4][v&0xf]\n            else:\n                state[i] = self.S_BOX_INV[v>>4][v&0xf]\n\n    def ShiftRows(self, state, inv=False):\n        \"\"\"\n        state是一个16个字节元素的列表，以一维形式访问\n        \"\"\"\n        for i in range(4):\n            if inv == False:\n                state[i::4] = state[i::4][i:] + state[i::4][:i] # 左移\n            else:\n                state[i::4] = state[i::4][-i:] + state[i::4][:-i]   # 右移\n\n\n    def MixColumns(self, state, inv=False):\n        def GFmul_by_2(n):\n            \"\"\"\n            这个计算是有数学意义的，不是简单的乘法运算，原理可自行了解GF域的定义。\n            :param n:\n            :return:\n            \"\"\"\n            s = (n << 1) & 0xff\n            if n & 128:\n                s ^= 0x1b\n            return s\n\n        def GFmul_by_3(n):\n            \"\"\"\n            :param n:\n            :return:\n            \"\"\"\n            return n ^ GFmul_by_2(n)\n\n        def mix_column(c):\n            return [\n                GFmul_by_2(c[0]) ^ GFmul_by_3(c[1]) ^ c[2] ^ c[3],\n                GFmul_by_2(c[1]) ^ GFmul_by_3(c[2]) ^ c[3] ^ c[0],\n                GFmul_by_2(c[2]) ^ GFmul_by_3(c[3]) ^ c[0] ^ c[1],\n                GFmul_by_2(c[3]) ^ GFmul_by_3(c[0]) ^ c[1] ^ c[2]\n            ]\n\n        if inv == False:\n            for i in range(0, 16, 4):\n                state[i:i + 4] = mix_column(state[i:i + 4])\n        else:\n            for _ in range(3):\n                for i in range(0, 16, 4):\n                    state[i:i + 4] = mix_column(state[i:i + 4])\n\n    def AddRoundKey(self, state, key):\n        for i in range(16):\n            state[i] ^= key[i]\n\n    def key_expansion(self, key):\n        key = bytearray(key)\n        for i in range(10 * 4):\n            r = key[-4:]\n            r = bytearray(r)\n            if i % 4 == 0:  # 对上一轮最后4字节，先循环左移一位，再S-box置换、轮常数异或，从而计算出当前新一轮最前4字节\n                for j, v in enumerate(r[1:] + r[:1]):\n                    r[j] = self.S_BOX[v >> 4][v & 0xf] ^ (self.RCON[i // 4] if j == 0 else 0)\n\n            for j in range(4):\n                key.append(key[-16] ^ r[j])\n\n        return key\n\n    def encrypt(self, b, expanded_key):\n        self.AddRoundKey(b, expanded_key)\n        for i in range(1, 10):\n            self.SubBytes(b)\n            self.ShiftRows(b)\n            self.MixColumns(b)\n            self.AddRoundKey(b, expanded_key[i*16:])\n\n        self.SubBytes(b)\n        self.ShiftRows(b)\n        self.AddRoundKey(b, expanded_key[-16:])\n        return b\n\n    def decrypt(self, b, expanded_key):\n        self.AddRoundKey(b, expanded_key[-16:])\n        for i in range(9, 0, -1):\n            self.ShiftRows(b, inv=True)\n            self.SubBytes(b, inv=True)\n            self.AddRoundKey(b, expanded_key[i*16:])\n            self.MixColumns(b, inv=True)\n\n        self.ShiftRows(b, inv=True)\n        self.SubBytes(b, inv=True)\n        self.AddRoundKey(b, expanded_key)\n        return b\n\n    def aes_ecb(self,type, key, msg):\n        expanded_key = self.key_expansion(key)\n        b = bytearray(msg)\n        if type == 0:\n            b = bytearray(msg+b'\\x00'*(16 - len(msg)%16))\n\n        for i in range(0, len(b), 16):\n            if type == 0:\n                b[i:i+16] = self.encrypt(b[i:i+16], expanded_key)\n            else:\n                b[i:i+16] = self.decrypt(b[i:i+16], expanded_key)\n        return bytes(b)\n\nif __name__ == '__main__':\n    key = b'sxyz.blog foobar'\n    aes = AES()\n    enc = aes.aes_ecb(0, bytearray(key), b'Gonna find the answer, how to clear this up')\n    dec = aes.aes_ecb(1, bytearray(key), enc)\n    print('Encrypted:', enc)\n    print('Decrypted:', dec)\n```\n\n\n\n<img src=\"/pictures/初识AES/image-20250705164453636.png\" alt=\"image-20250705164453636\">\n\n​\t验证成功！","tags":["crypto"],"categories":["CTF"]},{"title":"XYCTF2025","url":"/2025/07/04/XYCTF2025/XYCTF2025RE/","content":"\n\n\n\n\n\n\n\n# 前言\n\n​\t复现了4、5个题后，就感觉难度有点太大了，好几个题都涉及到没学过的技术，由于我的Windows基础很差，我的知识一直很琐碎，做题的时候感觉也只是能跑个脚本，思路根本没有领悟，而且没有深入的学习知识，没有收获，只是在动手能力方面强了一点点，性价比太低了。\n\n​\t学习路线还未确定，每天就只有复现题目，很难受，看不到前进的方向。我考量着，本来要考研复习了，有很多事情等着我去忙，我都是推了其他事情，拿出考试周后的几天来全神贯注的学习做题，但是自己自学逆向越往后越难了，基础太重要了，开发经验也很重要。我是不是需要合理的计划一下我的学习了，减少无谓刷题的时间，以考研复习为中心，有空余就做一做题，这样也许心态会好很多。成为逆向大佬也不是一蹴而就的事情，一年、两年甚至数十年，这是一个爱好，我要尝试没有逆向的时期了。\n\n​\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t——2025 06 14\n\n\n\n------\n\n\n\n# WARMUP(附件VBS)\n\n​\t这是一个vbs程序，通过`wscript.echo`函数输出代码，但是设置的窗口太大，又不知道怎么修改。于是使用python脚本提取出chr字段，在python中运行输出代码。\n\n> 学习一下`vbs`语言的基础知识：Dim是声明变量的关键字，数组标识为`s(255)`形式，字符串下标是从1开始的。字符串拼接是使用&符号，Right(str,n)函数表示对字符串从右向左取n位。\n\n```python\nimport re\n\n\ndef decode_vbs_chr_obfuscation_and_output(input_vbs_file, output_txt_file):\n    \"\"\"\n    读取 VBScript 文件，提取 chr() 形式的混淆字符，\n    计算出其对应的 ASCII 码值和实际字符，\n    并将解码后的结果输出到指定的文本文件。\n\n    Args:\n        input_vbs_file (str): 包含混淆 VBScript 代码的输入文件路径（例如 'chal.vbs'）。\n        output_txt_file (str): 存储解码结果的输出文件路径（例如 'code.txt'）。\n    \"\"\"\n    decoded_string_parts = []\n\n    try:\n        with open(input_vbs_file, 'r', encoding='utf-8', errors='ignore') as f:\n            vbs_code = f.read()\n    except FileNotFoundError:\n        print(f\"错误: 输入文件 '{input_vbs_file}' 未找到。请确保文件路径正确。\")\n        return\n    except Exception as e:\n        print(f\"读取文件 '{input_vbs_file}' 时发生错误: {e}\")\n        return\n\n    # 正则表达式来匹配 chr() 中的数学表达式\n    # 捕获组 ([0-9\\s\\+\\-\\*\\/\\.]+) 会提取 chr() 括号内的内容\n    chr_pattern = re.compile(r\"chr\\(\\s*([0-9\\s\\+\\-\\*\\/\\.]+)\\s*\\)\", re.IGNORECASE)\n\n    # 查找所有匹配项\n    matches = chr_pattern.findall(vbs_code)\n\n    if not matches:\n        print(f\"在 '{input_vbs_file}' 中未找到 'chr()' 形式的混淆表达式。\")\n        with open(output_txt_file, 'w', encoding='utf-8') as outfile:\n            outfile.write(\"未在 VBScript 文件中找到可解码的 'chr()' 表达式。\\n\")\n        return\n\n    for expression_str in matches:\n        try:\n            # 使用 eval() 计算数学表达式\n            # 注意：eval() 存在安全风险，仅在信任输入来源时使用\n            ascii_value = int(eval(expression_str))\n\n            # 将 ASCII 码值转换为字符\n            character = chr(ascii_value)\n\n            decoded_string_parts.append(character)\n        except Exception as e:\n            print(f\"警告: 计算表达式 '{expression_str}' 时出错: {e}。该部分将被跳过或显示为错误。\")\n\n    # 将所有解码出的字符连接起来形成最终的字符串\n    decoded_full_string = \"\".join(decoded_string_parts)\n\n    try:\n        with open(output_txt_file, 'w', encoding='utf-8') as outfile:\n            outfile.write(decoded_full_string)\n\n        print(f\"成功解码并输出结果到 '{output_txt_file}'。\")\n\n    except Exception as e:\n        print(f\"写入文件 '{output_txt_file}' 时发生错误: {e}\")\n\n\nif __name__ == \"__main__\":\n    # 定义输入和输出文件名\n    input_file_name = r\"F:\\StudyFiles\\CTF\\Review_CTF\\XYCTF2025\\RE\\VBS\\chal.vbs\"\n    output_file_name = r\"F:\\StudyFiles\\CTF\\Review_CTF\\XYCTF2025\\RE\\VBS\\code.txt\"\n    # 调用函数执行解码和输出\n    decode_vbs_chr_obfuscation_and_output(input_file_name, output_file_name)\n\n    print(\"-\" * 40)\n    print(\"处理完成。\")\n```\n\n```vbscript\nMsgBox \"Dear CTFER. Have fun in XYCTF 2025!\"\nflag = InputBox(\"Enter the FLAG:\", \"XYCTF\")\nwefbuwiue = \"90df4407ee093d309098d85a42be57a2979f1e51463a31e8d15e2fac4e84ea0df622a55c4ddfb535ef3e51e8b2528b826d5347e165912e99118333151273cc3fa8b2b3b413cf2bdb1e8c9c52865efc095a8dd89b3b3cfbb200bbadbf4a6cd4\"\nqwfe = \"rc4key\"\n\n\nFunction RunRC(sMessage, strKey)\n    Dim kLen, i, j, temp, pos, outHex\n    Dim s(255), k(255)\n    \n    kLen = Len(strKey)\n    For i = 0 To 255\n        s(i) = i\n        k(i) = Asc(Mid(strKey, (i Mod kLen) + 1, 1)) \n    Next\n    \n\n    j = 0\n    For i = 0 To 255\n        j = (j + s(i) + k(i)) Mod 256\n        temp = s(i)\n        s(i) = s(j)\n        s(j) = temp\n    Next\n    \n   \n    i = 0 : j = 0 : outHex = \"\"\n    For pos = 1 To Len(sMessage)\n        i = (i + 1) Mod 256\n        j = (j + s(i)) Mod 256\n        temp = s(i)\n        s(i) = s(j)\n        s(j) = temp\n        \n        \n        Dim plainChar, cipherByte\n        plainChar = Asc(Mid(sMessage, pos, 1)) \n        cipherByte = s((s(i) + s(j)) Mod 256) Xor plainChar\n        outHex = outHex & Right(\"0\" & Hex(cipherByte), 2)\n    Next\n    \n    RunRC = outHex\nEnd Function\n\n\nIf LCase(RunRC(flag, qwfe)) = LCase(wefbuwiue) Then\n    MsgBox \"Congratulations! Correct FLAG!\"\nElse\n    MsgBox \"Wrong flag.\"\nEnd If\n```\n\n​\t赛博厨子一把梭哈RC4，就行了。得到`flag{We1c0me_t0_XYCTF_2025_reverse_ch@lleng3_by_th3_w@y_p3cd0wn's_chall_is_r3@lly_gr3@t_&_fuN!}`\n\n按要求得到md5值。\n\n\n\n\n\n\n\n# Moon\n\n\n\n​\t这是一个pyd文件的逆向，对我来说相当难。.pyd文件是Python动态模块的一种，它本质上是一个Windows下的动态链接库（DLL）文件，但是扩展名为.pyd，以便Python能够识别和导入。\n\n​\t.pyd文件运行你使用c或c++等编译型语言编写Python模块，然后作为一个模块供python导入和调用，就像是普通的Python文件一样。\n\n​\tpython版本大多数情况下可以在IDA的字符串中看到。\n\n​\t不知道该怎么解，直接看源码也只能瞎猜，而且源码审计还得熟悉对应的函数才好跟踪，我都没经验。\n\n### 复现\t\n\n​\t直接学习WP，看到了，多半也是猜的，没有很逻辑性的分析。\n\n![image-20250609102034211](/pictures/XYCTF2025/image-20250609102034211.png)\n\n​\t猜测就是随机数生成流密钥，然后异或加密。所以去找密文就行。\n\n​\t但是开始我使用C写的脚本生成的随机数不对劲，然后看了一眼WP，是python的随机数生成。\n\n​\t现在我的脚本基本上都是AI写的了，虽然正确率高、速度快，但是我自身的代码能力下降了很多。\n\n```python\nimport random\n\ndef solve_xor_cipher():\n    seed = 1131796\n    random.seed(seed)\n\n    enflag = \"426b87abd0ceaa3c58761bbb0172606dd8ab064491a2a76af9a93e1ae56fa84206a2f7\"\n\n    decoded_bytes = bytearray()\n\n    for i in range(0, len(enflag), 2):\n        hex_byte_str = enflag[i:i + 2]\n\n        en_byte = int(hex_byte_str, 16)\n\n        random_num = random.randint(0, 255)\n\n        decoded_byte = en_byte ^ random_num\n\n        decoded_bytes.append(decoded_byte)\n\n    try:\n        flag = decoded_bytes.decode('ascii')\n        print(f\"Decoded Flag: {flag}\")\n    except UnicodeDecodeError:\n        print(\"Decoded Flag (might contain non-ASCII characters):\")\n        print(decoded_bytes.hex())\n\n\nif __name__ == \"__main__\":\n    solve_xor_cipher()\n```\n\n​\t下面是我写的，AI还是太格式化了。\n\n```py\nimport random\nenflag = \"426b87abd0ceaa3c58761bbb0172606dd8ab064491a2a76af9a93e1ae56fa84206a2f7\"\nseed = 1131796\nrandom.seed(seed)\nfor i in range(0,len(enflag),2):\n    data = int(enflag[i:i+2], 16)\n    data = data ^ random.randint(0, 255)\n    print(chr(data), end='')\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n# Dragon\n\n​\t拿到一个`bc`后缀文件，先使用虚拟机中的LLVM环境将文件反汇编为.ll文件，所使用命令为`llvm -dis filename`。**.ll**文件是LLVM的中间表示语言，是一种使用文本方式写的LLVM中间代码，可视作“**高级汇编**”。\n\n​\t然后使用`sublime`打开反汇编文件，看到main函数，\n\n​\t这是`for`循环的初始化过程，循环字符串长度除以2次。\n\n![image-20250609204824158](/pictures/XYCTF2025/image-20250609204824158.png)\n\n​\t看到for循环的主体，先调用calculate_crc64_direct函数，然后将返回值和密文比对，按照enc名称即可找到密文。\n\n![image-20250609204928826](/pictures/XYCTF2025/image-20250609204928826.png)\n\n![image-20250609205043827](/pictures/XYCTF2025/image-20250609205043827.png)\n\n​\t下一步看一下CRC64函数，看看具体的计算过程，其实就是这个算法。\n\n![image-20250609205917935](/pictures/XYCTF2025/image-20250609205917935.png)\n\n​\t得到经验，`for.cond`表示循环的初始化，`for.body`代表循环的主要逻辑，`for.inc`表示程序循环参数的自加，`for.end`表示循环的解释，很好理解。\n\n​\t整体的思路就是使用同样的计算CRC64的方法，去爆破结果。这个crc64计算函数的汇编代码非常简单，看汇编代码完全能一点点写出来，也不长。\n\n```c\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n\nuint64_t calculate_crc64(const uint8_t *data, int len)\n{\n    uint64_t crc = 0xFFFFFFFFFFFFFFFF;\n    for(int i = 0; i < len; i++)\n    {\n        crc ^= (uint64_t)(data[i]) << 56;\n        for(int j=0; j<8; j++)\n        {\n            if(crc & 0x8000000000000000)\n            {\n                crc = (crc << 1) ^ 0x42F0E1EBA9EA3693;\n            }else{\n                crc <<= 1;\n            }\n        }\n    }\n    return crc ^ 0xFFFFFFFFFFFFFFFF;\n}\n\nint main()\n{\n    uint64_t enc[] = {0xDC63E34E419F7B47,0x31EF8D4E7B2BFC6,0x12D62FBC625FD89E,0x83E8B6E1CC5755E8,0xfc7bb1eb2ab665cc,0x9382ca1b2a62d96b,0xb1fff8a07673c387,0xda81627388e05e1,0x9ef1e61ae8d0aab7,0x92783fd2e7f26145,0x63c97ca1f56fe60b,0x9bd3a8b043b73aab};\n    for(size_t i =0; i<sizeof(enc)/sizeof(enc[0]); i++)\n    {\n        for(uint16_t j=0x2020; j<0xffff; j++)\n        {\n            uint64_t crc = calculate_crc64((uint8_t*)&j, 2);\n            if(crc == enc[i])\n            {\n                printf(\"%c%c\", j&0xff, j>>8);\n            }\n        }\n    }\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n# Lake\n\n​\t无壳，Pascal语言编写，IDA反编译出来都是无符号解析的，只能动态分析了。\n\n​\t根据程序运行时的特定，可以跟踪sleep函数到主逻辑函数`sub_100001B70`。调试时很容易发现`sub_10000C760`是输出语句的地方，`sub_10000CB90`是输入flag的地方。\n\n![image-20250610123522648](/pictures/XYCTF2025/image-20250610123522648.png)\n\n​\t第一次加密，是利用一个类似虚拟机一样的东西进行处理，取出操作码发现，只有128三种操作，其他都没使用。\n\n![image-20250610123623209](/pictures/XYCTF2025/image-20250610123623209.png)\n\n​\t第二次加密函数`sub_1000019B0`，里面很清晰的移位加密，等价于`v5[i] = (v3[i+1] << 3) | (v3[i+2] >> 5)`\n\n`v5[i+1] =  (v3[i+2]<<3) | (v3[i+3] >> 5)` `v5[i+2] =  (v3[i+3]<<3) | (v3[i] >> 5)` `v5[i+3] =  (v3[i]<<3) | (v3[i+1] >> 5)`。\n\n![image-20250610123756995](/pictures/XYCTF2025/image-20250610123756995.png)\n\n​\t最后进行密文比对，逻辑很清晰了，写解密脚本就行了。这题唯一的难点就在于无符号解析，函数名和变量巨丑陋，需要自己动调+静态分析，体力活。\n\n![image-20250610124019036](/pictures/XYCTF2025/image-20250610124019036.png)\n\n\n\n\n\n​\t我又复习到了C语言的长度计算函数——`sizeof`函数。\n\n> ​\t`sizeof`返回操作数所占用的内存空间大小，以字节为单位，一个字节通常是8位，但是具体位数由CHAR_BIT宏定义（在limits.h中）。返回的结果是一个无符号整型，通常是size_t类型，定义在`<stddef.h>`（以及其他标准头文件）中。因此，在使用`sizeof`的结果时，推荐使用`size_t`类型变量来存储。\n>\n> ​\t当`sizeof`应用于一个表达式时，它只会分析表达式的类型，而不会真正执行该表达式。例如，`sizeof(x++)`会返回`x`的类型大小，但`x`的值不会因此而增加。唯一的例外是当操作数是一个可变长度数组（VLA）时，它会在运行时求值。\n>\n> ​\t`sizeof(myArray)`: 返回整个数组的总字节数，即`元素数量 * 单个元素大小`。计算数组元素个数: `sizeof(myArray) / sizeof(myArray[0])` 是计算数组元素个数的常用方法。\n>\n> ​\t`sizeof(myPointer)`: 返回指针本身在内存中占用的字节数，而不是它所指向的数据的大小。这通常是4或8字节，取决于系统架构（32位或64位）。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n\n//这个函数需要主动传入opr数组的大小，因为在该函数里面sizeof(opr)只能得到8，也就是指针的内存空间大小。\nvoid decrypt1(uint8_t *enc, uint8_t *opr, int opr_len)\n{\n    uint8_t a,b,c;\n    for(int i=opr_len-3; i>=0 ;i-=3)\n    {\n        a = opr[i];\n        b = opr[i+1];\n        c = opr[i+2];\n        //这里是因为已经分析出了操作码只有1、2、8三种类型。\n        switch(a)\n        {\n            case 1:\n                enc[b] -= c;\n                break;\n            case 2:\n                enc[b] += c;\n                break;\n            case 8:\n                enc[b] ^= c;\n                break;\n            default:\n                printf(\"Error\\n\");\n                break;     \n        }\n    }\n}\n\nvoid decrypt2(uint8_t *enc, uint8_t *flag)\n{\n    for(int i=0;i<40;i+=4)\n    {\n        flag[i] = (enc[i+3]>>3) | (enc[i+2]<<5);\n        flag[i+1] = (enc[i]>>3) | (enc[i+3]<<5);\n        flag[i+2] = (enc[i+1]>>3) | (enc[i]<<5);\n        flag[i+3] = (enc[i+2]>>3) | (enc[i+1]<<5);\n    }\n}\n\n\nint main()\n{\n    uint8_t enc[] = {74, 171, 155, 27, 97, 177, 243, 50, 209, 139, 115, 235, 233, 115, 107, 34, 129, 131, 35, 49, 203, 27, 34, 251, 37, 194, 129, 129, 115, 34, 250, 3, 156, 75, 91, 73, 151, 135, 219, 81};\n    uint8_t opr_sequ[] = {2, 2, 12, 1, 26, 85, 1, 35, 12, 2, 14, 9, 1, 27, 6, 8, 6, 5, 8, 1, 5, 2, 27, 14, 2, 25, 3, 2, 26, 4, 8, 4, 8, 1, 3, 12, 2, 12, 10, 1, 37, 2, 1, 32, 2, 1, 9, 12, 8, 26, 5, 2, 4, 13, 8, 8, 15, 2, 10, 14, 1, 16, 7, 1, 12, 7, 8, 34, 8, 8, 21, 10, 1, 39, 126, 2, 7, 2, 8, 15, 3, 8, 10, 10, 1, 34, 11, 2, 18, 8, 2, 25, 9, 8, 14, 6, 8, 0, 5, 1, 10, 8, 8, 27, 7, 8, 13, 6, 8, 13, 4, 8, 23, 12, 8, 34, 14, 2, 18, 52, 1, 38, 119};\n    uint8_t flag[40] = {0};\n    decrypt2(enc,flag);\n    decrypt1(flag,opr_sequ,sizeof(opr_sequ));\n    for(int i=0;i<40;i++)\n    {\n        printf(\"%c\",flag[i]);\n    }\n    return 0;\n}\n```\n\n\n\n\n\n# CrackMe\n\n​\tIDA查看，非MFC程序，xspy找不到按键对应的函数。调试的时候，提交按键被禁止了，需要找到对应的逻辑patch掉。\n\n​\t看WP，考察的方向是win32窗口程序逆向、反调试对抗、多线程和异步。\n\n​\tcs东西，x64dbg一点调试不明白。自己重新学win32窗口程序。做了，也逆不了，代码混淆的太恶心了，ida的插件还装不上，x64dbg一直到不了check点，一点点我崩溃了，花几天都解决不了的题，说明这根本不是我这个阶段能掌握的题。还是中等!\n\n------\n\n​\t既然无法自己完整复现，更别提自己思考，那么我就跟着学一下算法逆向吧，锻炼一下代码能力好了。总不能一直卡住吧，后面的路还很远，我不能在这里停下。\n\n------\n\n### 复现\n\n​\t里面有个特别有特征的函数，我看不懂，直接全部问AI。\n\n> ### 总结\n>\n> - **这段代码是一个基于导出函数名哈希的动态API调用器。**\n> - 它通过参数决定加载哪个系统DLL，从该DLL导出表里用哈希匹配函数名，找到函数指针后调用，并返回结果。\n> - 结合前面代码，感觉整体代码是个复杂的“保护壳”或“自定义API调用层”，有防调试+动态调用机制。\n\n![image-20250612220942036](/pictures/XYCTF2025/image-20250612220942036.png)\n\n​\t因为这个防护，所以我们无法通过导入函数的交叉引用来切入程序，但是我理解了这个是调用函数的地方（而且启同样功能，相同的代码的这个函数有很多名称，IDA在不同地方都取了不同的名称，但是点进去看是极为相似的），知道了这一点很重要，我以前不了解，只会感到太复杂，太可怕。现在我明白了，它调用函数的功能后，我就清楚类似下面这种代码就是函数调用，调用的就是`sub_7FF6D7FF1320`。\n\n![image-20250612222609678](/pictures/XYCTF2025/image-20250612222609678.png)\n\n​\t而像这种，就不是什么主要操作，多半是赋值啊等等无关的底层操作。\n\n![image-20250612222847321](/pictures/XYCTF2025/image-20250612222847321.png)\n\n\n\n​\t像`_CheckForDebuggerJustMyCode`这种函数，我开始以为是出题人写的反调试部分，检索才知道是系统代码，应该是VS程序自带的一个和调试有关的东西，我还没有深入了解，但是确认了这个函数对做题无影响。\n\n\n\n​\t我也找到了PEB的反调试代码，是在`TlsCallback_0`——`sub_7FF6D7FF2370`——`sub_7FF6D7FF1320`——`sub_7FF6D7FEE7E0`——`sub_7FF6D7FEF280`处，是真难找啊，我还是跟着大佬翻源码找到的。\n\n![image-20250612222252435](/pictures/XYCTF2025/image-20250612222252435.png)\n\n\n\n​\t本以为简单的下个断点，改一次标志位就能绕过，但是情况并非如此，IDA直接卡死了，连退出命令都没有效果了，调试器直接不起作用了。看WP学习到，这是题目使⽤`NtSetInformationThread` 设置线程属性 `ThreadHideFromDebugger` 来不让调试器调试，有关的特征就是这个`0x11`数。\n\n![image-20250613194110999](/pictures/XYCTF2025/image-20250613194110999.png)\n\n​\t这次的反调试对抗，绕过技巧是修改标志0x11为其他值，同时修改对`BeingDebugded`的判断逻辑，可以将等于1改为0，如下图即可。\n\n![image-20250613195146488](/pictures/XYCTF2025/image-20250613195146488.png)\n\n​\t`sub_7FF65DFA1320`函数还有调用`NtSetInformationThread`函数的地方，修改为其他值，如下图即可。\n\n![image-20250613195106815](/pictures/XYCTF2025/image-20250613195106815.png)\n\n\n\n​\t修改如上三个位置后，就能成功正常调试了，按键不会“灰”了。**(≧∀≦)ゞ**，接下来就可以愉快的调试程序了，查看加密验证逻辑了。\n\n------\n\n​\t`sub_7FF65DF9E7E0`函数相当于`WndProc`函数，断点下在这个函数头几行即可，输入后首先进入case0，这里是初始化窗口，然后再进入case4，再进入case5，后面还得回case0验证最后一步，总共分三个部分验证。\n\n\n\n​\t在case4里面，异或加密验证嘛，检查前5位的`flag{`。\n\n![image-20250613203657885](/pictures/XYCTF2025/image-20250613203657885.png)\n\n​\t看到case5里面调用的函数，先生成一个固定的数组，也就是替换box，然后通过异或、替换等操作进行加密，最后进行比较。我们可以直接拿到这个替换盒，然后爆破这七位。\n\n![image-20250613204251325](/pictures/XYCTF2025/image-20250613204251325.png)\n\n​\t提取数据IDA脚本。\n\n```python\ndata = []\nbase = 0xF33A8FF0C0\nfor i in range(256):\n    addr = base + i * 4\n    data.append(get_wide_dword(addr))\n\nprint(data)\n```\n\n​\t爆破脚本，得到第二段是`moshui_`。还让我又复习了一遍python运算符的基础知识，好好好！\n\n```python\nbox = [0, 3233442988, 1510334235, 2596254647, 3020668470, 1957810842, 3993919789, 783551873, 3009837615, 1943803523, 3915621684, 702138776, 124634137, 3352799413, 1567103746, 2647816110, 3183342109, 2097651377, 3887607046, 654459306, 162941995, 3373015175, 1404277552, 2466906012, 249268274, 3462522014, 1423857449, 2489596805, 3134207492, 2053790376, 3772115231, 544179635, 2685067897, 1622183637, 4195302754, 984961486, 335633487, 3569037539, 1308918612, 2394877944, 325883990, 3554079994, 1231636301, 2312317921, 2808555104, 1742555852, 4251122043, 1037604311, 498536548, 3708648648, 1202900863, 2265490387, 2847714898, 1762050814, 4089016649, 855842277, 2932959819, 1852507879, 4107580752, 879679996, 450548861, 3663771857, 1088359270, 2154129354, 2607071921, 1541320221, 3244367274, 31158534, 795835527, 4023717931, 1969922972, 3050360624, 671266974, 3904427058, 1913087877, 2998733609, 2617837224, 1555261956, 3322730931, 112637215, 651767980, 3865271296, 2094854071, 3160834843, 2463272602, 1382605366, 3369554305, 141376813, 2512341635, 1426400815, 3485111704, 251722036, 565507253, 3775830041, 2075208622, 3138078466, 997073096, 4224994404, 1634467795, 2714866559, 2405801726, 1340076626, 3579855333, 366619977, 2282248935, 1219638859, 3524101628, 314042704, 1006888145, 4240017533, 1711684554, 2797360998, 2262029013, 1181335161, 3705015758, 476864866, 853044451, 4066508879, 1759359992, 2825379668, 901097722, 4111451222, 1873836001, 2936675149, 2176718540, 1090812512, 3686517207, 453092731, 3988292385, 755167117, 3082640442, 1996959894, 1504918807, 2567524795, 62317068, 3272380064, 1591671054, 2657392034, 81470997, 3294710457, 3939845944, 711928724, 2966460451, 1886057615, 1342533948, 2428444048, 167816743, 3401237131, 3826175754, 615818150, 3188396049, 2125561021, 3814918931, 601450431, 3110523912, 2044508324, 1466479909, 2547177865, 225274430, 3453421202, 1303535960, 2366115316, 397917763, 3608007407, 4189708142, 956543938, 2747007093, 1661365465, 4275313527, 1047427035, 2765210732, 1684777152, 1256170817, 2321926637, 282753626, 3495958262, 4027552581, 817233897, 2852801630, 1789927666, 1141124467, 2227061215, 503444072, 3736837828, 1131014506, 2211677638, 426522225, 3654703837, 4150417244, 936918000, 2909243463, 1843258603, 1994146192, 3060149564, 752459403, 3965973031, 3268935590, 40735498, 2563907773, 1483230225, 3317316543, 83908371, 2680153252, 1594198024, 1907459465, 2970347813, 733239954, 3943577150, 3412177805, 198958881, 2439277718, 1373503546, 2137656763, 3218104599, 628085408, 3855990284, 2013776290, 3099436302, 570562233, 3803740693, 3423369108, 213261112, 2517215375, 1454621731, 3604390889, 376229701, 2362670322, 1281953886, 1658658271, 2724688243, 953729732, 4167216744, 1706088902, 2768942442, 1068828381, 4279200369, 3518719984, 285281116, 2344532203, 1258607687, 1802195444, 2882616664, 829329135, 4057260611, 3747672002, 534414190, 2238001369, 1172266101, 3624741851, 414664567, 2181625024, 1119000684, 1812370925, 2898065729, 906185462, 4139329114]\n\nenc = [0x46A95BAD,0x1CAC84B6,0xA67CB2B2,0x32188937,0x4872D39F,0xF2A2E59B,0x11B94D2]\n\nfor i in range(len(enc)):\n    for j in range(32, 127):\n        tmp = j ^ 0x79 & 0xff\n        \n        #更好的选择是 ((~box[tmp] ^ 0xB0E0E879) & 0xffffffff)，下面这个是个有冗余的代码。\n        #因为python中优先级：取反>与>异或，使用下面的代码是先算括号，然后算后面的与，然后才算异或的。\n        #也就是说最后的与根本没起作用，限制不了前面括号的数，它直接和0xB0E0E879爆了。\n        if ((~box[tmp] & 0xffffffff) ^ 0xB0E0E879 & 0xffffffff) == enc[i]:\n            print(chr(j), end='')\n            break\n```\n\n​\t\n\n​\t最后一段，通过断点，也可以发现，是在TLS回调函数这里的一个线程里面，它一直在while(1)循环，等待前两部分验证通过才会进入进入第三部分的验证的，这里应该是通过共享全局变量标志位和if语句来实现这个效果的。\n\n\n\n![image-20250613215606861](/pictures/XYCTF2025/image-20250613215606861.png)\n\n\n\n​\t下面生成了一个128位的密钥，一个循环5一个循环7，可以猜到是使用前两段flag来生成密钥啊。直接提取就可以了。\n\n![image-20250613220005888](/pictures/XYCTF2025/image-20250613220005888.png)\n\n![image-20250613220123411](/pictures/XYCTF2025/image-20250613220123411.png)\n\n\n\n​\t后面又在验证末尾是不是}符号，不是就进入if，处理错误逻辑。同时根据+28这个偏移，我们能够猜到flag总长度为29个字节，前面12个已经验证，后面再验证17个字符（包括结尾的}）。\n\n![image-20250613220329827](/pictures/XYCTF2025/image-20250613220329827.png)\n\n​\t看到后面的加密函数和验证代码，v7就是密文。`sub_7FF65DFA1500`参数有密钥、输入的flag、长度、输出缓冲区。\n\n![image-20250613220636641](/pictures/XYCTF2025/image-20250613220636641.png)\n\n​\t里面又有一些密钥操作，然后加密0x10000次，但是因为加密的明文和密文保存在两个不同的数组，所以其实和加密一次一样，每次都是同样的结果写入密文的缓冲区。\n\n![image-20250613220840974](/pictures/XYCTF2025/image-20250613220840974.png)\n\n​\t学习大佬的WP，里面是一个IDEA加密算法，我是菜鸡，都没有碰到过这个算法，好好学学。烦的一批，怎么现在这个AI还是这么煞笔啊，给出的代码全是错的，越改越差，垃圾狗屎AI。\n\n​\t学习下大佬的代码吧，我现在还是不会写代码，算法都不太能理解，数学能力很差了，代码能力也很差了。我感觉我要去练算法题了，哈哈，有时间一定去练好吧。\n\n```c++\n#include <iostream>\n#include <bitset>\n#include <cmath>\n#include <windows.h>\n#include <algorithm>\nusing namespace std;\n\ntypedef bitset<16> code;\ntypedef bitset<128> key;\n\nbitset<16> sub_key[52];\nbitset<16> inv_sub_key[52];\n\ncode XOR(code code_1, code code_2)\n{\n    return code_1 ^ code_2;\n}\n\ncode Plus(code code_1, code code_2)\n{\n    int tmp = 0;\n    for (int i = 0; i < 16; i++)\n    {\n        tmp += code_1[i] * pow(2, i) + code_2[i] * pow(2, i);\n    }\n    tmp %= 65536;\n    return bitset<16>(tmp);\n}\n\ncode invPlus(code code_in)\n{\n    int tmp = 0;\n    for (int i = 0; i < 16; i++)\n        tmp += code_in[i] * pow(2, i);\n    tmp = 65536 - tmp;\n    return bitset<16>(tmp);\n}\n\ncode Times(code code_1, code code_2)\n{\n    long long tmp_1 = 0, tmp_2 = 0;\n    for (int i = 0; i < 16; i++)\n    {\n        tmp_1 += code_1[i] * pow(2, i);\n        tmp_2 += code_2[i] * pow(2, i);\n    }\n    if (tmp_1 == 0)\n        tmp_1 = 65536;\n    if (tmp_2 == 0)\n        tmp_2 = 65536;\n    long long tmp = (tmp_1 * tmp_2) % 65537;\n    return bitset<16>(tmp == 65536 ? 0 : tmp);\n}\n\nvoid Exgcd(int a, int b, int &x, int &y)\n{\n    if (!b)\n        x = 1, y = 0;\n    else\n        Exgcd(b, a % b, y, x), y -= a / b * x;\n}\n\ncode invTimes(code code_in)\n{\n    int tmp = 0;\n    for (int i = 0; i < 16; i++)\n        tmp += code_in[i] * pow(2, i);\n    int x, y;\n    int p = 65537;\n    Exgcd(tmp, p, x, y);\n    x = (x % p + p) % p;\n    return bitset<16>(x);\n}\n\nvoid subkeys_get(code keys_input[8])\n{\n    key keys;\n    for (int i = 0; i < 8; i++)\n        for (int j = 0; j < 16; j++)\n            keys[j + 16 * i] = keys_input[7 - i][j];\n\n    for (int i = 0; i < 8; i++)\n        for (int j = 0; j < 16; j++)\n            sub_key[i][15 - j] = keys[127 - (j + 16 * i)];\n\n    for (int i = 0; i < 5; i++)\n    {\n        key tmp_keys = keys >> 103;\n        keys = (keys << 25) | tmp_keys;\n        for (int j = (8 + 8 * i); j < (8 * (i + 2)); j++)\n            for (int k = 0; k < 16; k++)\n                sub_key[j][15 - k] = keys[127 - (k + 16 * (j - 8 - 8 * i))];\n    }\n\n    key tmp_keys = keys >> 103;\n    keys = (keys << 25) | tmp_keys;\n    for (int i = 48; i < 52; i++)\n        for (int j = 0; j < 16; j++)\n            sub_key[i][15 - j] = keys[127 - (j + 16 * (i - 48))];\n}\n\nvoid inv_subkeys_get(code sub_key[52])\n{\n    for (int i = 6; i < 48; i += 6)\n    {\n        inv_sub_key[i] = invTimes(sub_key[48 - i]);\n        inv_sub_key[i + 1] = invPlus(sub_key[50 - i]);\n        inv_sub_key[i + 2] = invPlus(sub_key[49 - i]);\n        inv_sub_key[i + 3] = invTimes(sub_key[51 - i]);\n    }\n\n    for (int i = 0; i < 48; i += 6)\n    {\n        inv_sub_key[i + 4] = sub_key[46 - i];\n        inv_sub_key[i + 5] = sub_key[47 - i];\n    }\n\n    inv_sub_key[0] = invTimes(sub_key[48]);\n    inv_sub_key[1] = invPlus(sub_key[49]);\n    inv_sub_key[2] = invPlus(sub_key[50]);\n    inv_sub_key[3] = invTimes(sub_key[51]);\n\n    inv_sub_key[48] = invTimes(sub_key[0]);\n    inv_sub_key[49] = invPlus(sub_key[1]);\n    inv_sub_key[50] = invPlus(sub_key[2]);\n    inv_sub_key[51] = invTimes(sub_key[3]);\n}\n\nbitset<64> dencrypt(bitset<64> cipher)\n{\n    bitset<16> I_1, I_2, I_3, I_4;\n    for (int i = 0; i < 16; i++)\n    {\n        I_1[15 - i] = cipher[63 - i];\n        I_2[15 - i] = cipher[47 - i];\n        I_3[15 - i] = cipher[31 - i];\n        I_4[i] = cipher[i];\n    }\n    for (int i = 0; i < 48; i += 6)\n    {\n        bitset<16> tmp_1 = Times(inv_sub_key[i], I_1);\n        bitset<16> tmp_2 = Plus(inv_sub_key[i + 1], I_2);\n        bitset<16> tmp_3 = Plus(inv_sub_key[i + 2], I_3);\n        bitset<16> tmp_4 = Times(inv_sub_key[i + 3], I_4);\n        bitset<16> tmp_5 = XOR(tmp_1, tmp_3);\n        bitset<16> tmp_6 = XOR(tmp_2, tmp_4);\n        bitset<16> tmp_7 = Times(inv_sub_key[i + 4], tmp_5);\n        bitset<16> tmp_8 = Plus(tmp_6, tmp_7);\n        bitset<16> tmp_9 = Times(tmp_8, inv_sub_key[i + 5]);\n        bitset<16> tmp_10 = Plus(tmp_7, tmp_9);\n        I_1 = XOR(tmp_1, tmp_9);\n        I_2 = XOR(tmp_3, tmp_9);\n        I_3 = XOR(tmp_2, tmp_10);\n        I_4 = XOR(tmp_4, tmp_10);\n    }\n    bitset<16> Y_1 = Times(I_1, inv_sub_key[48]);\n    bitset<16> Y_2 = Plus(I_3, inv_sub_key[49]);\n    bitset<16> Y_3 = Plus(I_2, inv_sub_key[50]);\n    bitset<16> Y_4 = Times(I_4, inv_sub_key[51]);\n\n    bitset<64> plaint;\n    for (int i = 0; i < 16; i++)\n    {\n        plaint[i] = Y_4[i];\n        plaint[i + 16] = Y_3[i];\n        plaint[i + 32] = Y_2[i];\n        plaint[i + 48] = Y_1[i];\n    }\n    return plaint;\n}\n\nint main()\n{\n    unsigned int box1[] = {\n        0x00000000, 0xC0BA6CAC, 0x5A05DF1B, 0x9ABFB3B7, 0xB40BBE36, 0x74B1D29A,\n        0xEE0E612D, 0x2EB40D81, 0xB3667A2F, 0x73DC1683, 0xE963A534, 0x29D9C998, 0x076DC419, 0xC7D7A8B5,\n        0x5D681B02, 0x9DD277AE, 0xBDBDF21D, 0x7D079EB1, 0xE7B82D06, 0x270241AA, 0x09B64C2B, 0xC90C2087,\n        0x53B39330, 0x9309FF9C, 0x0EDB8832, 0xCE61E49E, 0x54DE5729, 0x94643B85, 0xBAD03604, 0x7A6A5AA8,\n        0xE0D5E91F, 0x206F85B3, 0xA00AE279, 0x60B08ED5, 0xFA0F3D62, 0x3AB551CE, 0x14015C4F, 0xD4BB30E3,\n        0x4E048354, 0x8EBEEFF8, 0x136C9856, 0xD3D6F4FA, 0x4969474D, 0x89D32BE1, 0xA7672660, 0x67DD4ACC,\n        0xFD62F97B, 0x3DD895D7, 0x1DB71064, 0xDD0D7CC8, 0x47B2CF7F, 0x8708A3D3, 0xA9BCAE52, 0x6906C2FE,\n        0xF3B97149, 0x33031DE5, 0xAED16A4B, 0x6E6B06E7, 0xF4D4B550, 0x346ED9FC, 0x1ADAD47D, 0xDA60B8D1,\n        0x40DF0B66, 0x806567CA, 0x9B64C2B1, 0x5BDEAE1D, 0xC1611DAA, 0x01DB7106, 0x2F6F7C87, 0xEFD5102B,\n        0x756AA39C, 0xB5D0CF30, 0x2802B89E, 0xE8B8D432, 0x72076785, 0xB2BD0B29, 0x9C0906A8, 0x5CB36A04,\n        0xC60CD9B3, 0x06B6B51F, 0x26D930AC, 0xE6635C00, 0x7CDCEFB7, 0xBC66831B, 0x92D28E9A, 0x5268E236,\n        0xC8D75181, 0x086D3D2D, 0x95BF4A83, 0x5505262F, 0xCFBA9598, 0x0F00F934, 0x21B4F4B5, 0xE10E9819,\n        0x7BB12BAE, 0xBB0B4702, 0x3B6E20C8, 0xFBD44C64, 0x616BFFD3, 0xA1D1937F, 0x8F659EFE, 0x4FDFF252,\n        0xD56041E5, 0x15DA2D49, 0x88085AE7, 0x48B2364B, 0xD20D85FC, 0x12B7E950, 0x3C03E4D1, 0xFCB9887D,\n        0x66063BCA, 0xA6BC5766, 0x86D3D2D5, 0x4669BE79, 0xDCD60DCE, 0x1C6C6162, 0x32D86CE3, 0xF262004F,\n        0x68DDB3F8, 0xA867DF54, 0x35B5A8FA, 0xF50FC456, 0x6FB077E1, 0xAF0A1B4D, 0x81BE16CC, 0x41047A60,\n        0xDBBBC9D7, 0x1B01A57B, 0xEDB88321, 0x2D02EF8D, 0xB7BD5C3A, 0x77073096, 0x59B33D17, 0x990951BB,\n        0x03B6E20C, 0xC30C8EA0, 0x5EDEF90E, 0x9E6495A2, 0x04DB2615, 0xC4614AB9, 0xEAD54738, 0x2A6F2B94,\n        0xB0D09823, 0x706AF48F, 0x5005713C, 0x90BF1D90, 0x0A00AE27, 0xCABAC28B, 0xE40ECF0A, 0x24B4A3A6,\n        0xBE0B1011, 0x7EB17CBD, 0xE3630B13, 0x23D967BF, 0xB966D408, 0x79DCB8A4, 0x5768B525, 0x97D2D989,\n        0x0D6D6A3E, 0xCDD70692, 0x4DB26158, 0x8D080DF4, 0x17B7BE43, 0xD70DD2EF, 0xF9B9DF6E, 0x3903B3C2,\n        0xA3BC0075, 0x63066CD9, 0xFED41B77, 0x3E6E77DB, 0xA4D1C46C, 0x646BA8C0, 0x4ADFA541, 0x8A65C9ED,\n        0x10DA7A5A, 0xD06016F6, 0xF00F9345, 0x30B5FFE9, 0xAA0A4C5E, 0x6AB020F2, 0x44042D73, 0x84BE41DF,\n        0x1E01F268, 0xDEBB9EC4, 0x4369E96A, 0x83D385C6, 0x196C3671, 0xD9D65ADD, 0xF762575C, 0x37D83BF0,\n        0xAD678847, 0x6DDDE4EB, 0x76DC4190, 0xB6662D3C, 0x2CD99E8B, 0xEC63F227, 0xC2D7FFA6, 0x026D930A,\n        0x98D220BD, 0x58684C11, 0xC5BA3BBF, 0x05005713, 0x9FBFE4A4, 0x5F058808, 0x71B18589, 0xB10BE925,\n        0x2BB45A92, 0xEB0E363E, 0xCB61B38D, 0x0BDBDF21, 0x91646C96, 0x51DE003A, 0x7F6A0DBB, 0xBFD06117,\n        0x256FD2A0, 0xE5D5BE0C, 0x7807C9A2, 0xB8BDA50E, 0x220216B9, 0xE2B87A15, 0xCC0C7794, 0x0CB61B38,\n        0x9609A88F, 0x56B3C423, 0xD6D6A3E9, 0x166CCF45, 0x8CD37CF2, 0x4C69105E, 0x62DD1DDF, 0xA2677173,\n        0x38D8C2C4, 0xF862AE68, 0x65B0D9C6, 0xA50AB56A, 0x3FB506DD, 0xFF0F6A71, 0xD1BB67F0, 0x11010B5C,\n        0x8BBEB8EB, 0x4B04D447, 0x6B6B51F4, 0xABD13D58, 0x316E8EEF, 0xF1D4E243, 0xDF60EFC2, 0x1FDA836E,\n        0x856530D9, 0x45DF5C75, 0xD80D2BDB, 0x18B74777, 0x8208F4C0, 0x42B2986C, 0x6C0695ED, 0xACBCF941,\n        0x36034AF6, 0xF6B9265A, 0xCCCCCCCC, 0xCCCCCC00, 0x00000100, 0x00000000, 0xF6B9265A, 0xCCCCCCCC,\n        0x00000008, 0x00000000};\n\n    uint32_t enc1[]{\n        0x46A95BAD,\n        0x1CAC84B6,\n        0xA67CB2B2,\n        0x32188937,\n        0x4872D39F,\n        0xF2A2E59B,\n        0x011B94D2,\n    };\n\n    // 爆破前7字节\n    for (int i = 0; i < 7; i++)\n    {\n        for (int c = 28; c < 132; c++)\n        {\n            if ((~box1[(uint8_t)c ^ 0x79] ^ 0xB0E0E879) == enc1[i])\n            {\n                printf(\"%c\", c);\n                break;\n            }\n        }\n    }\n\n    // 后16字节进行IDEA解密\n    unsigned char enc2[16] = {\n        0x5C, 0x2F, 0xD0, 0xEC, 0x82, 0x0E, 0x67, 0x57,\n        0x6A, 0x9F, 0x91, 0xF6, 0x95, 0xA4, 0xAC, 0x90};\n    // unsigned int key[4] = {\n    //     0x42B2986C, 0x12345678, 0x0D6D6A3E, 0x89ABCDEF};\n    unsigned int key[4] = {\n        0x6C98B242, 0x78563412, 0x3E6A6D0D, 0xEFCDAB89};\n\n    code keys_input[8];\n    for (int i = 0; i < 4; i++)\n    {\n        keys_input[2 * i + 1] = key[i] & 0xFFFF;\n        keys_input[2 * i] = (key[i] >> 16) & 0xFFFF;\n    }\n\n    unsigned char result[16];\n    bitset<64> cipher1, cipher2;\n    for (int i = 0; i < 8; i++)\n    {\n        for (int j = 0; j < 8; j++)\n        {\n            cipher1[63 - (i * 8 + j)] = (enc2[i] >> (7 - j)) & 1;\n            cipher2[63 - (i * 8 + j)] = (enc2[i + 8] >> (7 - j)) & 1;\n        }\n    }\n    subkeys_get(keys_input);\n    inv_subkeys_get(sub_key);\n\n    bitset<64> plain1 = dencrypt(cipher1);\n    bitset<64> plain2 = dencrypt(cipher2);\n\n    uint64_t plain1_val = plain1.to_ullong();\n    uint64_t plain2_val = plain2.to_ullong();\n\n    uint8_t dec2[16]{};\n    memcpy(dec2, &plain2_val, 8);\n    memcpy(dec2 + 8, &plain1_val, 8);\n    reverse(dec2, dec2 + 16);\n\n    printf(\"%.16s\\n\", dec2);\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n# ezVM（附件chal）\n\n\n\n​\t无壳64位ELF程序，程序有异常，IDA分析蛮久才结束。\n\n​\t根据字符串引用找到主逻辑，先进行长度比对，然后加密，最后check，密文在`unk_1639E40`处。\n\n![image-20250614130136465](/pictures/XYCTF2025/image-20250614130136465.png)\n\n​\t里面的函数呢，就算了，又是太无语的代码，一堆垃圾，看不清楚一点。学习WP，反正是学新东西。\n\n\n\n### 复现liv大佬的WP\n\n\n\n​\t学习知道这是一个使用**unicorn**框架执行虚拟代码的程序，我们要使用**bindiff**来恢复一些被丢弃的函数符号信息。具体操作就是，先搞到对应架构的动态库文件（Windows就是dll文件），然后通过**bindiff**可以进行函数级别的比较，这会帮助你**识别目标程序中哪些函数是 Unicorn 的实现**，并可以**导入函数名**。\n\n​\t但是动态库文件需要自己编译啊，很难找到现成的。又打消了我的积极性啊。\n\n\n\n------\n\n​\t在Ubuntu24虚拟机中安装Unicorn框架，建议方式：\n\n- 使用**python3-venv**虚拟环境，在其中使用`pip install unicorn`直接下载。之后可以通过`from unicorn import *`、 `from unicorn.x86_const import *`的方式导入模块，不熟悉的同学可以通过`help(unicorn)`查看其模块信息。\n\n```python\n# unicorn_example.py\nfrom unicorn import *\nfrom unicorn.x86_const import *\n\n# 创建一个 Unicorn 引擎\nuc = Uc(UC_ARCH_X86, UC_MODE_64)\n\n# 为程序分配内存（这里选择了0x1000地址起始的内存区）\nuc.mem_map(0x1000, 2 * 1024 * 1024)\n\n# 向内存写入代码（简单的汇编代码）\ncode = b\"\\x48\\x31\\xc0\"  # x86_64 汇编：xor rax, rax\nuc.mem_write(0x1000, code)\n\n# 设置程序的起始地址\nuc.reg_write(UC_X86_REG_RIP, 0x1000)\n\n# 执行模拟（最多执行 1 步）\nuc.emu_start(0x1000, 0x1000 + len(code))\n\n# 获取并输出结果（此处我们查询 RAX 寄存器的值）\nresult = uc.reg_read(UC_X86_REG_RAX)\nprint(f\"RAX = {result}\")\n```\n\n\n\n- 如果有网联通github，可以通过`git clone https://github.com/unicorn-engine/unicorn.git`命令拉取预编译文件，然后`cd unicorn`、`mkdir build`、`cd build`、`cmake ..`、`make`，编译好了之后， 可以编写cpp文件了，编写完后，通过g++编译链接出可执行程序。命令示例如下：`g++ -o unicorn_test /home/ubuntu/桌面/unicorn_test.cpp     -I/home/ubuntu/桌面/unicorn/include     -L/home/ubuntu/桌面/unicorn/build     -lunicorn`。有可能会报错找不到共享库文件，可以使用命令`export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/ubuntu/桌面/unicorn/build`，其中的路径自行修改。\n\n```c++\n#include <iostream>\n#include <unicorn/unicorn.h>\n\n#define ADDRESS 0x1000000  // 起始地址\n\nint main() {\n    uc_engine *uc;\n    uc_err err;\n\n    // 初始化 Unicorn 模拟器\n    err = uc_open(UC_ARCH_X86, UC_MODE_64, &uc);\n    if (err != UC_ERR_OK) {\n        std::cerr << \"Failed to initialize Unicorn engine!\" << std::endl;\n        return -1;\n    }\n\n    // 映射 2MB 的内存区域，设置可读、可写、可执行权限\n    err = uc_mem_map(uc, ADDRESS, 2 * 1024 * 1024, UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC);\n    if (err != UC_ERR_OK) {\n        std::cerr << \"Failed to map memory!\" << std::endl;\n        return -1;\n    }\n\n    // 将一段简单的机器码写入内存（如 `int 0x80` 中断指令）\n    uint8_t code[] = { 0xCD, 0x80 }; // x86 中断指令\n    err = uc_mem_write(uc, ADDRESS, code, sizeof(code));\n    if (err != UC_ERR_OK) {\n        std::cerr << \"Failed to write code to memory!\" << std::endl;\n        return -1;\n    }\n\n    // 执行该段代码\n    err = uc_emu_start(uc, ADDRESS, ADDRESS + sizeof(code), 0, 0); // 添加timeout和count\n    if (err != UC_ERR_OK) {\n        std::cerr << \"Failed to start emulation!\" << std::endl;\n        return -1;\n    }\n\n    // 释放 Unicorn 引擎\n    uc_close(uc);\n\n    std::cout << \"Emulation completed successfully!\" << std::endl;\n    return 0;\n}\n\n```\n\n------\n\n​\t其实，在unicorn编译后，在build目录下面有很多架构的示例文件，如sample_x86、sample_arm64等等，如果只是恢复符号的话，可以使用这些例子，不需要自己码了。但是，在我的环境下编译出来的ELF程序进行bindiff，完全比对不上，恢复不了对应的函数名。就先这样吧，直接抄大佬恢复的符号吧。\n\n​\t\n\n\n\n​\t然后将以上调用write写入的数据提取（5个全部提取），随便找一个ARM64框架（**因为根据反编译代码看出来是使用unicorn模拟执行ARM64的指令**）的.so（**安卓app程序都有这种ARM64的so程序**）复制到对应地址，以便反编译看代码。\n\n![image-20250627220457369](/pictures/XYCTF2025/image-20250627220457369.png)\n\n​\tok，写入这个四个数据后，就可以反编译出来了。注意，data_2是会重新覆盖Code_Arm中的，必须覆盖掉那一部分。我也是终于看到这个函数了！（**还是有个问题，我的MEMORY[]地址和大佬的还不一样，是哪里错了吗？**）\n\n​\t大佬说这是虚拟机执行函数，最后还是通过hook模拟执行，看汇编分析逻辑。\n\n![image-20250627220713636](/pictures/XYCTF2025/image-20250627220713636.png)\n\n​\t在Hook模拟时，由于在ubuntu系统下， 我小改了一下程序，修改了一下windows.h的替代，结果编译出来就死循环了😥。真难受。改Windows的python-unicorn，还是死循环，开在启动模拟的输出就没了，希望哪个师傅能够指点一下。\n\n​\t经过重新尝试，我将code的字节保存到了一个二进制文件中，然后在程序中读取，这样就能够正常跑了。好玄学，是不是这种文本太长了，**Typora**保存出错啊，还是风水问题，这个取数据的操作，我重复了至少五次！\n\n​\t也有可能是**010Editor**的问题，大量字节数据复制粘贴时就给我强行换成文本模式，非得先保存二进制数据到另一个文件中，然后再通过“文件插入”功能，把字节数据放进去。\n\n​\t下面的终于能跑了！\n\n```python\n#demo_2\nData1 = [0x00,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x50,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe4,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe4,0xff,0xff,0xff,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xd8,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe4,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe4,0xff,0xff,0xff,0x01,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x29,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe4,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xd8,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xd4,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xd4,0xff,0xff,0xff,0x20,0x00,0x00,0x00,0x0f,0x00,0x00,0x00,0x5b,0x00,0x00,0x00,0x11,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe0,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb0,0xff,0xff,0xff,0x53,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb1,0xff,0xff,0xff,0x68,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb2,0xff,0xff,0xff,0x6f,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb3,0xff,0xff,0xff,0x77,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb4,0xff,0xff,0xff,0x6d,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb5,0xff,0xff,0xff,0x61,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb6,0xff,0xff,0xff,0x6b,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb7,0xff,0xff,0xff,0x65,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb8,0xff,0xff,0xff,0x72,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb9,0xff,0xff,0xff,0x5f,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xba,0xff,0xff,0xff,0x6d,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xbb,0xff,0xff,0xff,0x61,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xbc,0xff,0xff,0xff,0x64,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xbd,0xff,0xff,0xff,0x65,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xbe,0xff,0xff,0xff,0x69,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xbf,0xff,0xff,0xff,0x74,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xb0,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf4,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xd0,0xff,0xff,0xff,0x19,0x19,0xa0,0xa0,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf4,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xcc,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf4,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xc8,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf4,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xc4,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x12,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf4,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x08,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xc0,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf8,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,0x37,0x01,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf8,0xff,0xff,0xff,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf8,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf8,0xff,0xff,0xff,0x08,0x00,0x00,0x00,0x13,0x00,0x00,0x00,0x68,0x02,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf8,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe0,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xec,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf8,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe0,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x0a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe8,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf0,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xdc,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,0x83,0x01,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xdc,0xff,0xff,0xff,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xdc,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xdc,0xff,0xff,0xff,0x48,0x00,0x00,0x00,0x14,0x00,0x00,0x00,0x3b,0x02,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe8,0xff,0xff,0xff,0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe8,0xff,0xff,0xff,0x08,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x06,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe8,0xff,0xff,0xff,0x05,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x44,0x33,0x22,0x11,0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf0,0xff,0xff,0xff,0x0d,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf4,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf0,0xff,0xff,0xff,0x05,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x12,0x12,0xab,0xab,0x05,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xec,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xec,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf0,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xd0,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf0,0xff,0xff,0xff,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xec,0xff,0xff,0xff,0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xec,0xff,0xff,0xff,0x08,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x07,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xec,0xff,0xff,0xff,0x05,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x88,0x77,0x66,0x55,0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf0,0xff,0xff,0xff,0x07,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x0d,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf4,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x09,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf0,0xff,0xff,0xff,0x05,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x66,0x55,0x23,0x23,0x05,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe8,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe8,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,0x75,0x01,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf8,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe0,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xec,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x0b,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xf8,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe0,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0xe8,0xff,0xff,0xff,0x02,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,0x02,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x03,0x00,0x00,0x00,0x0c,0x00,0x00,0x00,0x29,0x01,0x00,0x00,0x02,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x05,0x00,0x00,0x00,0x04,0x00,0x00,0x00,0x01,0x00,0x00,0x00,0x00,0x00,0x00,0x00]\nData2 = [0x00,0x00,0x00,0x00,0x81,0x08,0x00,0x00,0x4d,0x00,0x00,0x00,0x07,0x04,0x00,0x00,0x14,0x03,0x00,0x00,0x7c,0x04,0x00,0x00,0x29,0x07,0x00,0x00,0x97,0x07,0x00,0x00,0x0b,0x08,0x00,0x00,0xdd,0x05,0x00,0x00,0xa5,0x06,0x00,0x00,0x7f,0x08,0x00,0x00,0xe5,0x06,0x00,0x00,0x68,0x05,0x00,0x00,0x7f,0x08,0x00,0x00,0xc5,0x06,0x00,0x00,0x11,0x07,0x00,0x00,0x24,0x07,0x00,0x00,0x60,0x07,0x00,0x00,0xf3,0x06,0x00,0x00,0x8a,0x06,0x00,0x00]\nData3 = [0x28,0x4a,0x1,0,0,0,0,0]\n```\n\n```python\nfrom unicorn import *\nfrom unicorn.arm64_const import *\nimport demo_2\n\nBase = 0x1000000\nStack = 0x7F0000\nInputAddr = 0x14C28\nInput = b'XYCTF{fun_un1c0rn_with_4rm64_VM}'\n\n\ndef hook_code(uc, address, size, user_data):\n    if address == 0x1FAC:\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        print(f\"W3 = W1 ^ W0 --- {w1:#x} ^ {w0:#x} = {w1 ^ w0:#x}\")\n    elif address == 0x2054:\n        w3 = uc.reg_read(UC_ARM64_REG_W3)\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        print(f\"W2 = W0 ^ W3 --- {w0:#x} ^ {w3:#x} = {w3 ^ w0:#x}\")\n    elif address == 0x2180:\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        w4 = uc.reg_read(UC_ARM64_REG_W4)\n        print(f\"W1 = W1 ^ W4 --- {w1:#x} ^ {w4:#x} = {w1 ^ w4:#x}\")\n    elif address == 0x2238:\n        w3 = uc.reg_read(UC_ARM64_REG_W3)\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        print(f\"W2 = W0 ^ W3 --- {w0:#x} ^ {w3:#x} = {w3 ^ w0:#x}\")\n    elif address == 0x2BE4:\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        print(f\"W3 = W1 >> W0 --- {w1:#x} >> {w0:#x} = {(w1 >> w0):#x}\")\n    elif address == 0x2CD4:\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        print(f\"W2 = W1 >> W0 --- {w1:#x} >> {w0:#x} = {(w1 >> w0):#x}\")\n    elif address == 0x2EA4:\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        print(f\"W2 = W1 << W0 --- {w1:#x} << {w0:#x} = {(w1 << w0):#x}\")\n    elif address == 0x2DB4:\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        print(f\"W2 = W1 << W0 --- {w1:#x} << {w0:#x} = {(w1 << w0):#x}\")\n    elif address == 0x232C:\n        w3 = uc.reg_read(UC_ARM64_REG_W3)\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        print(f\"W2 = W0 & W3 --- {w0:#x} & {w3:#x} = {w0 & w3:#x}\")\n    elif address ==0x241C:\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        print(f\"W2 = W0 & W1 --- {w0:#x} & {w1:#x} = {w0 & w1:#x}\")\n    elif address == 0x1CC4:\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        print(f\"W2 = W1 + W0 --- {w1:#x} + {w0:#x} = {w1 + w0:#x}\")\n    elif address == 0x1A0C:\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        print(f\"W2 = W1 + W0 --- {w1:#x} + {w0:#x} = {w1 + w0:#x}\")\n    elif address == 0x1AB4:\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        w3 = uc.reg_read(UC_ARM64_REG_W3)\n        print(f\"W2 = W0 + W3 --- {w0:#x} + {w3:#x} = {w0 + w3:#x}\")\n    elif address == 0x1BE0:\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        w4 = uc.reg_read(UC_ARM64_REG_W4)\n        print(f\"W1 = W1 + W4 --- {w1:#x} + {w4:#x} = {w1 + w4:#x}\")\n    elif address == 0x1E98:\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        w1 = uc.reg_read(UC_ARM64_REG_W1)\n        print(f\"W2 = W1 - W0 --- {w1:#x} - {w0:#x} = {w1 - w0:#x}\")\n    elif address == 0x1DA8:\n        w0 = uc.reg_read(UC_ARM64_REG_W0)\n        w3 = uc.reg_read(UC_ARM64_REG_W3)\n        print(f\"W2 = W0 - W3 --- {w0:#x} - {w3:#x} = {w0 - w3:#x}\")\n\n        \ndef main():\n    try:\n        with open('code', 'rb') as f:\n            Code = f.read()\n        Data1 = bytes(demo_2.Data1)\n        Data2 = bytes(demo_2.Data2)\n        Data3 = bytes(demo_2.Data3)\n        mu = Uc(UC_ARCH_ARM64, UC_MODE_ARM)  # 架构+模式\n\n        #映射内存\n        mu.mem_map(0,Base,UC_PROT_ALL)\n        #mu.mem_map(Stack-4096,0x4000,UC_PROT_ALL)\n\n        mu.hook_add(UC_HOOK_CODE, hook_code)\n\n        mu.mem_write(InputAddr,Input)\n        mu.mem_write(0xC70,Code)\n        mu.mem_write(0x14010,Data1)\n        mu.mem_write(0x30F0,Data2)\n        mu.mem_write(0x149E8,Data3)\n\n        mu.reg_write(UC_ARM64_REG_X0, InputAddr)\n        mu.reg_write(UC_ARM64_REG_SP, Stack)\n\n        mu.emu_start(0x0C70,0x2EF4)\n\n        result = mu.mem_read(InputAddr,48)\n        for i in range(32):\n            print(f\"{result[i]:02x} \", end='')\n        print()\n    except UcError as e:\n        print(\"Unicorn error: %s\" % e)\n\nif __name__ == '__main__':\n    main()\n```\n\n​\t现在的问题还有两个：一就是这个**关键计算地址究竟是怎么筛选出来的**，还有其他的计算处没有添加进去啊？其二就是看输出的**计算过程分析加密算法**了。\n\n​\t也没有人能回答，我猜就是随便挑了一些计算出来，懒得全写。上面我已经补全了所有的计算指令地址，更美味的享受吧。\n\n​\t随便看看这个计算过程，很明显是有规律的，很像是个循环，循环多少轮呢，老实数吧。\n\n![image-20250704183341268](/pictures/XYCTF2025/image-20250704183341268.png)\n\n​\t先从最基础的一轮开始看起，可以先看两轮，确定其中的常数项，然后由参数开始逐渐定义变量来还原计算过程，并且多次验证。唯一的缺点就是，轮数太🐔儿多，让人望而生畏，不是有flag的诱惑，谁干这么苦逼的活，当然我们RE✌是不会这么吃亏的，每一轮的长度是22行，加上计数的一行，我们可以复制到另一个强大的文本编辑器去快速计算轮数。\n\n​\t看规律的东西还是太鸡儿不爽了，太折磨没有耐心的我啊。\n\n```python\nW3 = W1 >> W0 --- 0x75667b46 >> 0x5 = 0x3ab33da\t\t\t\t\t#v1 >> 5\nW2 = W1 << W0 --- 0x75667b46 << 0x6 = 0x1d599ed180\t\t\t\t#v1 << 6\nW3 = W1 ^ W0 --- 0x3ab33da ^ 0x599ed180 = 0x5a35e25a \t\t\t#(v1>>5) ^ (v1 << 6 & 0xfffffffff)\nW2 = W0 ^ W3 --- 0x75667b46 ^ 0x11223344 = 0x64444802\t\t\t#v1 ^ key0\nW2 = W1 + W0 --- 0x5a35e25a + 0x64444802 = 0xbe7a2a5c\t\t\t#t1 = ((v1>>5) ^ ...) + (v1 ^ key0)\nW2 = W0 & W3 --- 0x0 & 0x3 = 0x0\t\t\t\t\t\t\t\nW2 = W1 + W0 --- 0x776f6853 + 0x0 = 0x776f6853\t\t\t\t\nW2 = W0 ^ W3 --- 0x776f6853 ^ 0xabab1212 = 0xdcc47a41\t\t\t#t2\nW3 = W1 ^ W0 --- 0xbe7a2a5c ^ 0xdcc47a41 = 0x62be501d\t\t\t#t1 ^ t2\nW2 = W1 + W0 --- 0x62be501d + 0x54435958 = 0xb701a975\t\t\t#v0 = t2 + ?\nW2 = W1 - W0 --- 0x0 - 0xa0a01919 = -0xa0a01919\t\t\t\t\t#sum-=delta ,  =0x5f5fe6e7\nW3 = W1 >> W0 --- 0xb701a975 >> 0x4 = 0xb701a97\t\t\t\t\nW2 = W1 << W0 --- 0xb701a975 << 0x7 = 0x5b80d4ba80\nW3 = W1 ^ W0 --- 0xb701a97 ^ 0x80d4ba80 = 0x8ba4a017\t\t\t#t3 = (v0>>4)+(v0<<7)\nW2 = W0 ^ W3 --- 0xb701a975 ^ 0x55667788 = 0xe267defd\t\t\t#t4 = v0^key1\nW2 = W1 + W0 --- 0x8ba4a017 + 0xe267defd = 0x16e0c7f14\t\t\t#t3 + (v0^key1)\nW3 = W1 >> W0 --- 0x5f5fe6e7 >> 0xb = 0xbebfc\t\t\t\t\t#sum>>11\nW2 = W0 & W3 --- 0xbebfc & 0x3 = 0x0\t\t\t\t\t\t\t#(sum>>11)&3\nW2 = W1 + W0 --- 0x776f6853 + 0x5f5fe6e7 = 0xd6cf4f3a\t\t\t\nW2 = W0 ^ W3 --- 0xd6cf4f3a ^ 0x23235566 = 0xf5ec1a5c\t\t\t#t2\nW3 = W1 ^ W0 --- 0xf5ec1a5c ^ 0x6e0c7f14 = 0x9be06548 \t\t\t#t5 = t2^(t3 + (v0^key1))\nW2 = W1 + W0 --- 0x9be06548 + 0x75667b46 = 0x11146e08e\t\t\t#v1= t5 + v1\nW2 = W0 + W3 --- 0x0 + 0x1 = 0x1\t\t\t\t\t\t\t#-------------------------------------计数，分解线\nW3 = W1 >> W0 --- 0x1146e08e >> 0x5 = 0x8a3704 \t\t\t\t\t#v1>>5\nW2 = W1 << W0 --- 0x1146e08e << 0x6 = 0x451b82380\nW3 = W1 ^ W0 --- 0x8a3704 ^ 0x51b82380 = 0x51321484\nW2 = W0 ^ W3 --- 0x1146e08e ^ 0x11223344 = 0x64d3ca\nW2 = W1 + W0 --- 0x51321484 + 0x64d3ca = 0x5196e84e\nW2 = W0 & W3 --- 0x5f5fe6e7 & 0x3 = 0x3\nW2 = W1 + W0 --- 0x74696564 + 0x5f5fe6e7 = 0xd3c94c4b\nW2 = W0 ^ W3 --- 0xd3c94c4b ^ 0xabab1212 = 0x78625e59\nW3 = W1 ^ W0 --- 0x5196e84e ^ 0x78625e59 = 0x29f4b617\nW2 = W1 + W0 --- 0x29f4b617 + 0xb701a975 = 0xe0f65f8c\nW2 = W1 - W0 --- 0x5f5fe6e7 - 0xa0a01919 = -0x41403232\nW3 = W1 >> W0 --- 0xe0f65f8c >> 0x4 = 0xe0f65f8\nW2 = W1 << W0 --- 0xe0f65f8c << 0x7 = 0x707b2fc600\nW3 = W1 ^ W0 --- 0xe0f65f8 ^ 0x7b2fc600 = 0x7520a3f8\nW2 = W0 ^ W3 --- 0xe0f65f8c ^ 0x55667788 = 0xb5902804\nW2 = W1 + W0 --- 0x7520a3f8 + 0xb5902804 = 0x12ab0cbfc\nW3 = W1 >> W0 --- 0xbebfcdce >> 0xb = 0x17d7f9\nW2 = W0 & W3 --- 0x17d7f9 & 0x3 = 0x1\nW2 = W1 + W0 --- 0x656b616d + 0xbebfcdce = 0x1242b2f3b\nW2 = W0 ^ W3 --- 0x242b2f3b ^ 0x23235566 = 0x7087a5d\nW3 = W1 ^ W0 --- 0x7087a5d ^ 0x2ab0cbfc = 0x2db8b1a1\nW2 = W1 + W0 --- 0x2db8b1a1 + 0x1146e08e = 0x3eff922f\nW2 = W0 + W3 --- 0x1 + 0x1 = 0x2 \t\t\t\t\t\t#-------------------------------------计数，分解线\nW3 = W1 >> W0 --- 0x3eff922f >> 0x5 = 0x1f7fc91\nW2 = W1 << W0 --- 0x3eff922f << 0x6 = 0xfbfe48bc0\n```\n\n​\t大佬总结出来了加密代码。\n\n```c\nvoid encipher(uint32_t v[2], const uint32_t key[4])\n{\n    unsigned int i;\n    uint32_t v0 = v[0], v1 = v[1], sum = 0, delta = 0x5f5fe6e7;\n    for (i = 0; i < 72; i++)\n    {\n        auto tmp = (((v1 << 6) ^ (v1 >> 5)) + (v1 ^ 0x11223344));\n        auto tmp2 = (((key[sum & 3] + sum) ^ 0xabab1212) ^ tmp);\n        v0 += tmp2;\n        sum += delta;\n        auto tmp3 = (((v0 << 7) ^ (v0 >> 4)) + (v0 ^ 0x55667788));\n        auto tmp4 = ((key[(sum >> 11) & 3] + sum) ^ 0x23235566 ^ tmp3);\n        v1 += tmp4;\n    }\n    v[0] = v0;\n    v[1] = v1;\n}\n```\n\n​\t然后写解密脚本即可。\n\n\n\n\n\n\n\n\n\n# EzObf\n\n​\t这种逆向题就是第一次没头绪，就完全不想做了。。\n\n### 复现WP\n\n​\t首先熟悉一下不熟悉的汇编指令。\n\n> **pushfq**\n>\n> **作用**：将 **RFLAGS（64位）/EFLAGS（32位）寄存器的值压入栈中**。\n>\n> **用途**：保存当前的标志寄存器状态，常用于函数调用前保存状态，或者处理中断、上下文切换时保护标志寄存器。\n>\n> \n>\n> **popfq**就是对应恢复的指令。\n>\n> **call    $+5** 其中$代表当前指令的地址，作用就是：跳转到当前指令地址往后5字节处执行代码，同时把返回地址压入栈。\n>\n> **rol**指令是循环左移。\n\n\n\n​\t可以看到pushfq和popfq是对称的，等价于都不起作用。push和pop也是对称的，也可以nop掉，真实有效执行指令只有一条。\n\n![image-20250628142121006](/pictures/XYCTF2025/image-20250628142121006.png)\n\n​\t原理比较清晰了，看到大手子师傅给的IDC脚本，直接自动化nop掉并且计算出新的跳转指令，tql！**ψ(｀∇´)ψ**\n\n![image-20250628144934914](/pictures/XYCTF2025/image-20250628144934914.png)\n\n​\t自己再手动nop掉上面的几行push，然后**apply patches to input files**，不保存**i64**文件，重新导入IDA分析，F5就能反编译出来了。师傅太强了，膜拜！\n\n​\t好好学习欣赏一下师傅的IDC脚本，其实后面真实汇编混淆的格式都一样，只有第一个特殊一点，需要手动patch掉一部分。下次碰到就可以边研究边模仿写了。\n\n```cpp\n//从addr开始nop掉长度为length个字节\nstatic NopCode(Addr, Length)\n{\n    auto i;\n    for (i = 0; i < Length; i++)\n    {\n        PatchByte(Addr + i, 0x90);\n    }\n}\n\n//计算循环移位\nstatic rol(value, count, bits = 32)\n{\n    count = count % bits;\n    return ((value << count) | (value >> (bits - count))) & ((1 << bits) - 1);\n}\n\n// 搜索真实汇编代码的下一条指令地址\nstatic FindEnd(Addr)\n{\n    auto i;\n    for (i = 0; i < 0x90; i++)\n    {\n        auto v = Dword(Addr + i);\n        if (v == 0x5153509C)\n        {\n            return Addr + i;\n        }\n    }\n    return 0;\n}\n\n// 搜索最后的jmp rax指令\nstatic FindJmpRax(Addr)\n{\n    auto i;\n    for (i = 0; i < 0x90; i++)\n    {\n        auto v = Word(Addr + i);\n        if (v == 0xE0FF)\n        {\n            return Addr + i;\n        }\n    }\n    return 0;\n}\n\n// 搜索call $+5\nstatic FindCall(Addr)\n{\n    auto i;\n    for (i = 0; i < 0x90; i++)\n    {\n        auto v = Dword(Addr + i);\n        if (v == 0xE8)\n        {\n            return Addr + i;\n        }\n    }\n    return 0;\n}\n\nstatic main()\n{\n    auto StartAddr = 0x1401F400D;\n    while (1)\n    {\n        // 搜索真实汇编代码的下一个指令地址\n        auto EndAddr = FindEnd(StartAddr);\n        if (EndAddr == 0)\n        {\n            break;\n        }\n        // 真实汇编代码的字节长度\n        auto CodeLength = EndAddr - StartAddr - 13;\n        // 搜索Call $+5\n        auto CallAddr = FindCall(StartAddr + 13 + CodeLength);\n        if (CallAddr == 0)\n        {\n            break;\n        }\n        // call $+5的下一条指令地址，即call时push到栈的返回地址\n        auto CalcAddr = CallAddr + 5;\n        auto ebx = Dword(CalcAddr + 2);\n        auto rol_Value = Byte(CalcAddr + 8);\n        auto Mode = Dword(CalcAddr + 9);\n        ebx = rol(ebx, rol_Value);\n\n        // 搜索最尾部的jmp rax指令地址\n        auto JmpRaxAddr = FindJmpRax(StartAddr);\n        if (JmpRaxAddr == 0)\n        {\n            break;\n        }\n        // 第一部分垃圾指令长度\n        auto TrushCodeLength_1 = CallAddr - (StartAddr + 13 + CodeLength);\n        // 第二部分垃圾指令长度\n        auto TrushCodeLength_2 = JmpRaxAddr - CallAddr + 2;\n        // Nop掉无用的所有代码\n        \n        NopCode(StartAddr, 13);\n       \n        NopCode(StartAddr + 13 + CodeLength, TrushCodeLength_1);\n        \n        NopCode(CallAddr, TrushCodeLength_2);\n        // 一共两种地址计算，加和减\n        if (Mode == 0xffC32B48)\n        {\n            CalcAddr = CalcAddr - ebx;\n        }\n        if (Mode == 0xffC30348)\n        {\n            CalcAddr = CalcAddr + ebx;\n        }\n        auto JmpCodeAddr = EndAddr;\n        // 计算相对跳转地址\n        auto JmpOffset = CalcAddr - JmpCodeAddr + 5;\n        // 写入jmp指令\n        PatchByte(JmpCodeAddr, 0xE9);\n        PatchDword(JmpCodeAddr + 1, JmpOffset);\n        // jmp的地址为下一次deobf起始地址\n        StartAddr = CalcAddr;\n    }\n}\n```\n\n​\t下面第n次重新学习xxtea算法，🐽，迟早我要出一篇算法的专栏，收集到较丰富的python脚本，以后直接梭哈！\n\n```c\n//标准加解密代码\n#include <stdio.h>\n#include <stdint.h>\n#define DELTA 0x9e3779b9\n#define MX (((z>>5^y<<2) + (y>>3^z<<4)) ^ ((sum^y) + (key[(p&3)^e] ^ z)))\n \nvoid btea(uint32_t *v, int n, uint32_t const key[4])\n{\n    uint32_t y, z, sum;\n    unsigned p, rounds, e;\n    if (n > 1)            /* Coding Part */\n    {\n        rounds = 6 + 52/n;\n        sum = 0;\n        z = v[n-1];\n        do\n        {\n            sum += DELTA;\n            e = (sum >> 2) & 3;\n            for (p=0; p<n-1; p++)\n            {\n                y = v[p+1];\n                z = v[p] += MX;\n            }\n            y = v[0];\n            z = v[n-1] += MX;\n        }\n        while (--rounds);\n    }\n    else if (n < -1)      /* Decoding Part */\n    {\n        n = -n;\n        rounds = 6 + 52/n;\n        sum = rounds*DELTA;\n        y = v[0];\n        do\n        {\n            e = (sum >> 2) & 3;\n            for (p=n-1; p>0; p--)\n            {\n                z = v[p-1];\n                y = v[p] -= MX;\n            }\n            z = v[n-1];\n            y = v[0] -= MX;\n            sum -= DELTA;\n        }\n        while (--rounds);\n    }\n}\n \n \nint main()\n{\n    uint32_t v[2]= {1,2};\n    uint32_t const k[4]= {2,2,3,4};\n    int n= 2; //n的绝对值表示v的长度，取正表示加密，取负表示解密\n    // v为要加密的数据是两个32位无符号整数\n    // k为加密解密密钥，为4个32位无符号整数，即密钥长度为128位\n    printf(\"加密前原始数据：%u %u\\n\",v[0],v[1]);\n    btea(v, n, k);\n    printf(\"加密后的数据：%u %u\\n\",v[0],v[1]);\n    btea(v, -n, k);\n    printf(\"解密后的数据：%u %u\\n\",v[0],v[1]);\n    return 0;\n}\n```\n\n​\t反编译的代码，需要仔细看，一行行分析。\n\n```c\nint __fastcall main_0(int argc, const char **argv, const char **envp)\n{\n  __int64 i; // rcx\n  int result; // eax\n  _DWORD *v5; // rdi\n  HANDLE CurrentProcess; // rax\n  __int64 v7; // [rsp-20h] [rbp-468h] BYREF\n  _DWORD v8[2]; // [rsp+0h] [rbp-448h] BYREF\n  _BYTE v9[64]; // [rsp+8h] [rbp-440h] BYREF\n  _BYTE *v10; // [rsp+48h] [rbp-400h]\n  unsigned int v11; // [rsp+64h] [rbp-3E4h]\n  int v12; // [rsp+84h] [rbp-3C4h]\n  unsigned int v13; // [rsp+A4h] [rbp-3A4h]\n  int v14; // [rsp+C4h] [rbp-384h]\n  int v15; // [rsp+E4h] [rbp-364h]\n  unsigned int k; // [rsp+104h] [rbp-344h]\n  int v17; // [rsp+124h] [rbp-324h]\n  int v18; // [rsp+144h] [rbp-304h]\n  int v19; // [rsp+164h] [rbp-2E4h]\n  _DWORD v20[11]; // [rsp+188h] [rbp-2C0h] BYREF\n  unsigned __int16 v21; // [rsp+1B4h] [rbp-294h]\n  BOOL v22; // [rsp+1D4h] [rbp-274h] BYREF\n  unsigned __int64 j; // [rsp+1F8h] [rbp-250h]\n  unsigned __int64 v24; // [rsp+218h] [rbp-230h]\n  _DWORD v25[16]; // [rsp+238h] [rbp-210h]\n  unsigned __int64 m; // [rsp+278h] [rbp-1D0h]\n  int v27; // [rsp+404h] [rbp-44h]\n  unsigned int v28; // [rsp+408h] [rbp-40h]\n  int v29; // [rsp+40Ch] [rbp-3Ch]\n  __int64 v30; // [rsp+410h] [rbp-38h]\n  int v31; // [rsp+418h] [rbp-30h]\n  unsigned __int64 v32; // [rsp+420h] [rbp-28h]\n\n  v5 = v8;\n  for ( i = 174LL; i; --i )\n    *v5++ = 0xCCCCCCCC;\n  v32 = (unsigned __int64)v8 ^ 0x1401D9000LL;\n  j___CheckForDebuggerJustMyCode(0x1401ED101LL);\n  memset(v9, 0, 0x20uLL);\n  sub_140087C02(0x1401A1190LL);\n  if ( !IsDebuggerPresent() )\n  {\n    sub_1400868E3();\n    v10 = v9;\n    memset(v20, 0, 0x10uLL);\n    v21 = 8;\n    v27 = 8;\n    v18 = 12;\n    v13 = 0;\n    v14 = 0x61C88646;\n    v19 = 0x95664B48;\n    v17 = 7;\t\t\t\t\t\t//循环轮数改为了7\n    v22 = 0;\n    CurrentProcess = GetCurrentProcess();\n    CheckRemoteDebuggerPresent(CurrentProcess, &v22);\n    if ( !v22 )\n    {\n      j_srand(0xAABBu);\n      for ( j = 0LL; j < 4; ++j )\n        v20[j] = j_rand();\t\t\t\t//密钥是128位，4*32\n      while ( 1 )\n      {\n        v27 = v17--;\n        v28 = v27 != 0;\n        if ( !v28 )\n          break;\n        v13 += v14;\t\t\t\t\t\t//delta是v14，sum是v13\n        v15 = (v13 >> 2) & 3;\t\t\t//参数e\n        for ( k = 0; k < v21; ++k )\t\t//对应的是明文长度，明文每32位为一个元素，主要就是计算MX的过程\n        {\n          v24 = __rdtsc();\t\t\t//获取CPU的时间戳计数\n          v11 = *(_DWORD *)&v10[4 * ((k + 1) % v21)];\t\t//取到v[p+1]\n          v27 = (4 * v11) ^ (*(_DWORD *)&v10[4 * ((k + v21 - 1) % v21)] >> 5);\t//v[p+1]<<2 ^ v[p-1]>>5\n          v28 = k + v21 - 1;\t\t\t\t\t//p-1\n          v29 = ((16 * *(_DWORD *)&v10[4 * (v28 % v21)]) ^ (v11 >> 3)) + v27;\t//v[p-1]<<4 ^ v[p+1]>>3 + v27\n          v30 = ((unsigned __int8)v15 ^ (unsigned __int8)k) & 3;\t\t//(e^p)&3 \n            //key[(p&3)^e] ^  v[p-1]    +   (sum^v[p+1])   + v[p]\n          v31 = (((*(_DWORD *)&v10[4 * (v28 % v21)] ^ v20[v30]) + (v11 ^ v13)) ^ v29) + *(_DWORD *)&v10[4 * k];\n          *(_DWORD *)&v10[4 * k] = v31;\t//v[p] = ...\n          v12 = v31;\n          if ( __rdtsc() - v24 > 0x83C0 )\t\t//基于时间的反调试\n            goto LABEL_21;\n        }\n      }\n      v25[0] = 0xA9934E2F;\n      v25[1] = 0x30B90FA;\n      v25[2] = 0xDCBF1D3;\n      v25[3] = 0x328B5BDE;\n      v25[4] = 0x44FAB4E;\n      v25[5] = 0x1DCF0051;\n      v25[6] = 0x85EBBE55;\n      v25[7] = 0x93AA773A;\n      for ( m = 0LL; m < 4; ++m )\n      {\n        if ( v25[m] != v8[m + 2] )\t\t//验证flag\n        {\n          sub_140087C02(0x1401A11A8LL);\n          j_system(byte_1401A11A0);\n          goto LABEL_21;\n        }\n      }\n      sub_140087C02(0x1401A11C0LL);\n      j_system(byte_1401A11A0);\n    }\n  }\nLABEL_21:\n  j__RTC_CheckStackVars(&v7, (_RTC_framedesc *)&unk_1401A1140);\n  j___security_check_cookie((unsigned __int64)v8 ^ v32);\n  return result;\n}\n```\n\n​\t改参数的xxTea，加解密逻辑一样。\n\n```c++\n//大佬的解密脚本\n#include <iostream>\n#define DELTA 0x61C88646\n#define MX (((z >> 5 ^ y << 2) + (y >> 3 ^ z << 4)) ^ ((sum ^ y) + (key[(p & 3) ^ e] ^ z)))\n\nvoid xxtea(uint32_t *v, int n, uint32_t const key[4])\n{\n    uint32_t y, z, sum;\n    unsigned p, rounds, e;\n    if (n > 1) /* Coding Part */\n    {\n        rounds = 7;\n        sum = 0;\n        z = v[n - 1];\n        do\n        {\n            sum += DELTA;\n            e = (sum >> 2) & 3;\n            for (p = 0; p < n - 1; p++)\n            {\n                y = v[p + 1];\n                z = v[p] += MX;\n                if (z == 0xA4F41487)\n                    printf(\"11\\n\");\n                if (y == 0xA4F41487)\n                    printf(\"11\\n\");\n            }\n            y = v[0];\n            z = v[n - 1] += MX;\n\n        } while (--rounds);\n    }\n    else if (n < -1) /* Decoding Part */\n    {\n        n = -n;\n        rounds = 7;\n        sum = rounds * DELTA;\n        y = v[0];\n        do\n        {\n            e = (sum >> 2) & 3;\n            for (p = n - 1; p > 0; p--)\n            {\n                z = v[p - 1];\n                y = v[p] -= MX;\n            }\n            z = v[n - 1];\n            y = v[0] -= MX;\n            sum -= DELTA;\n        } while (--rounds);\n    }\n}\n\nint main()\n{\n    srand(0xAABB);\n    uint32_t key[4]{};\n    uint32_t Enc[]{\n        0xa9934e2f, 0x30b90fa, 0xdcbf1d3, 0x328b5bde,\n        0x44fab4e, 0x1dcf0051, 0x85ebbe55, 0x93aa773a};\n\n    for (int i = 0; i < 4; i++)\n    {\n        key[i] = rand();\n    }\n    xxtea(Enc, -8, key);\n    printf(\"%.32s\\n\", Enc);\n    return 0;\n}\n\n```\n\n\n\n\n\n\n\n\n\n\n\n# Summer\n\n### 复现WP\n\n​\tHaskell语言编写，不看了，去找大佬的WP学习吧，太雷人了，我要快点结束这一part。经典题以后再做也没事，现在就吸取一下经验。\n\n\n\n\n\n\n\n\n\n\n\n# MDriver（无解，我也不看了）\n","tags":["复现WP","Reverse"],"categories":["CTF"]},{"title":"DSBCTF2024","url":"/2025/06/29/DSBCTF2024/DSBCTF/","content":"\n## \t前言\n\n​\t比赛是CTFSHOW平台的DSBCTF2024，[官方WP](https://ctf-show.feishu.cn/docx/R6udd58bxoQGQMxFphncZq8rn5e)如示。\n\n## easyRE\n\n​\t`jar`程序，第一次见到，好好学习一下。[有个入门文章](https://www.skfwe.cn/p/%E9%80%86%E5%90%91-jar-e.g-dvt/)，看看。\n\n​\t第一步使用JD-GUI打开jar程序，看到Application类，里面有个长段的base64，解码得到程序主要逻辑函数。\n\n![image-20250612163448413](/pictures/DSBCTF2024/image-20250612163448413.png)\n\n```java\nimport javax.crypto.Cipher;\nimport javax.crypto.spec.SecretKeySpec;\nimport java.nio.charset.StandardCharsets;\nimport java.security.SecureRandom;\nimport java.util.*;\n\npublic class D8yDSBCTF {\n\n    private static final String P3WSSK = \"AES/ECB/PKCS5Padding\";\n    private static final String C89SYS__ = \"abcdefghijklmnopqrstuvwxyz\";\n    private static final String C7yyfggl = C89SYS__.toUpperCase();\n    private static final String N9SSCRT = \"0123456789\";\n    private static final String D9UUSACR = C89SYS__ + C7yyfggl + N9SSCRT;\n    private static SecureRandom rf3ffc = new SecureRandom();\n    public  void start() throws Exception {\n        String key =  b3f7a__0x337f2a(a98fac77f__3c2a(1<<4)).get(1);\n        String e3yfbbglsk = b3f7a__0x337f2a(a98fac77f__3c2a(1<<4)).get(0);\n        Scanner scanner = new Scanner(System.in);\n        System.out.println(\"please input password:\");\n        String i3clscwyt = scanner.nextLine();\n        if (e3c7go_to(i3clscwyt,key).equals(e3yfbbglsk)) {\n            System.out.println(\"Login Successful\");\n        } else {\n            System.out.println(\"Login Failed\");\n        }\n    }\n    private  List<String> b3f7a__0x337f2a(String a783c_7fxf__) {\n        final String f37xcrxedrd_ = \"jvjeTQVGcDGPgFeC+E90Pz6wYzjcBK49YDx2W+6YFTjk/wma7Oa5J3O2ns8OptbxyNgIvYJf/J4BRJOat0LY2A==\";\n        StringBuilder c0fybbg = new StringBuilder();\n        List<String> l2crsys = new ArrayList<String>();\n        char[] f117xc = f37xcrxedrd_.toCharArray();\n        for (char c : f117xc) {\n            c0fybbg.append((char)(((c >>> 4 ^ (c << 4) ^ (c >>> 4))) >> 4));\n        }\n        l2crsys.add(c0fybbg.substring(0,c0fybbg.length()-24));\n        l2crsys.add(c0fybbg.substring(l2crsys.get(0).length(),c0fybbg.length()));\n        return l2crsys;\n    }\n    public  String a98fac77f__3c2a(int length) {\n        if (length < 1) throw new IllegalArgumentException(\"Length must be positive\");\n\n        StringBuilder s7cyscrs = new StringBuilder(length);\n        for (int i = 0; i < length; i++) {\n            int randomIndex = rf3ffc.nextInt(D9UUSACR.length());\n            s7cyscrs.append(D9UUSACR.charAt(randomIndex));\n        }\n        return s7cyscrs.toString();\n    }\n    public  String e3c7go_to(String coysc21k, String k89csbbv) throws Exception {\n        while (k89csbbv.getBytes(StandardCharsets.UTF_8).length < 16) {\n            k89csbbv += k89csbbv;\n        }\n        byte[] keyBytes = k89csbbv.substring(0, 16).getBytes(StandardCharsets.UTF_8);\n        SecretKeySpec s88vfy = new SecretKeySpec(keyBytes, \"AES\");\n        Cipher c1ppy = Cipher.getInstance(P3WSSK);\n        c1ppy.init(Cipher.ENCRYPT_MODE, s88vfy);\n        byte[] encryptedBytes = c1ppy.doFinal(coysc21k.getBytes(StandardCharsets.UTF_8));\n        return Base64.getEncoder().encodeToString(encryptedBytes);\n    }\n}\n```\n\n​\t幸好学过一点点JAVA语法，并且有Chatgpt的辅助，我很顺利的理解了函数逻辑。`a98fac77f__3c2a`是生成指定长度的随机字符串，字符表就是`D9UUSACR`；`b3f7a__0x337f2a`就是对`f37xcrxedrd_`字符串进行分割，后面24位为数组第二个元素，前面的字符串为数组第一个元素，也就是密文；`e3c7go_to`加密方式就是将key取前16位，然后对输入进行AES加密，对应模式如`P3WSSK`，最后转base64表示。\n\n​\t所以和随机数一点关系没有，只是个迷惑项，赛博厨子一把梭。\n\n![image-20250612171208129](/pictures/DSBCTF2024/image-20250612171208129.png)\n\n\n\n\n\n\n\n\n\n\n\n## 送单身的自己一束（64朵）花\n\n​\t熟悉的exe黑框框程序，国际惯例先查壳，无壳白茶。**(ゝ∀･)**\n\n​\t程序表面看上去比较简单，很容易追踪到主要逻辑，但是就是加密过程看的很难受，函数里面套好几个函数，还都没有正经名称，功能分析太麻烦了。**(╥﹏╥)**\n\n​\t太难了，动调都看不出来，真的是无语住了。我好像不太适合天天做题了，都做不出来，完全都没思路，和我的能力都不在一个水平上啊。\n\n​\t\n\n\n\n​\t还是慢慢来吧，我定了一个策略：碰到一个题后，如果是新题型（新语言或者是新技术），一定尽量自己先写一个demo出来看一看熟悉一下其逆向，然后会事半功倍。\n\n\n\n​\t看到check里面的长度比较，密文长度是**0x38**，而且我们输入字符串长度39个时为0x34，40对应0x38，42对应0x38，43对应0x3C。根据这个特征，我们推断出，其中很可能有base64的变换。\n\n​\t**小伙籽，如果无法找到哪些是用户代码，就动调吧，别怕，这题大多数是系统代码。**😂\n\n![image-20250626161812242](/pictures/DSBCTF2024/image-20250626161812242.png)\n\n​\t![image-20250626162116531](/pictures/DSBCTF2024/image-20250626162116531.png)\n\n\n\n​\t我们的输入长度就是40、41和42了，密文是`[121, 84, 114, 67, 35, 83, 42, 76, 36, 84, 74, 116, 122, 119, 86, 65, 120, 82, 65, 77, 36, 120, 106, 80, 122, 119, 78, 67, 120, 82, 110, 70, 37, 104, 114, 86, 120, 81, 121, 77, 36, 120, 106, 94, 114, 67, 77, 77, 36, 83, 118, 79, 35, 84, 81, 97]`，即**yTrC#S*L$TJtzwVAxRAM$xjPzwNCxRnF%hrVxQyM$xj^rCMM$SvO#TQa**。\n\n​\t替换表为**abcdefghijklmnopqrstuvwxyz!@#$%^&*()ABCDEFGHIJKLMNOPQRSTUVWXYZ<>a**。\n\n\n\n​\t看了半天就一个换表的base64加密，中间一堆不知道是啥的东西，有自动补**\\0**结束符的，有验证下标的。我直接被吓退了！\n\n​\t有点搞自己心态了。\n\n![image-20250626161332933](/pictures/DSBCTF2024/image-20250626161332933.png)\n\n​\t原来开头还有一个简单的花指令啊。\n\n\n\n\n\n\n\n\n\n\n\n\n\n## 破解飞机大战\n\n​\t有一个新颖的反调试技术，当在调试时，a1=1，会除以0，导致程序崩溃；没有调试时，a1=0, 计算 (a1 - 1) = -1，转换为无符号后是很大的数（0xFFFFFFFF），0 除以任何非零数都是 0 → 返回 0，程序正常运行。\n\n```c\nint __usercall sub_4120A0@<eax>(unsigned __int64 a1@<edx:eax>)\n{\n  LODWORD(a1) = NtCurrentPeb()->BeingDebugged;\n  LODWORD(a1) = a1 / (unsigned int)(a1 - 1);\n  return a1;\n}\n```\n\n​\t全部手动nop也太麻烦了，学习WP中直接NOP掉这个函数的方法。\n\n```python\ndebugfun = b\"\\x64\\xA1\\x30\\x00\\x00\\x00\\x0F\\xB6\\x40\\x02\\x89\\xC3\\x83\\xEB\\x01\\xF7\\xF3\"\t#这个函数所有的字节\n\nwith open(\"a.exe\", \"rb\") as f:\n    data = f.read()\n\n# 替换并接住返回值\npatched_data = data.replace(debugfun, b\"\\x90\" * len(debugfun))\n\nwith open(\"b.exe\", \"wb\") as f2:\n    f2.write(patched_data)\n```\n\n\n\n​\tIDA打开后，正常从**_main**函数开始分析，先看到三个函数，**sub_416900**应该是初始化部分。\n\n```c\nint sub_416900()\n{\n  int i; // ebx\n  int result; // eax\n\n  result = dword_432038;\t\t//静态变量防止重复执行\n  if ( !dword_432038 )\n  {\n    dword_432038 = 1;\n    for ( i = 0; dword_418B30[i + 1]; ++i )\n      ;\n    for ( ; i; --i )\n      ((void (*)(void))dword_418B30[i])();\t\t//倒序遍历函数指针数组并调用\n    result = sub_4014C0(sub_416870);\t\t//调用注册类函数\n  }\n  return result;\n}\n```\n\n------\n\n\n\n> `RegisterClassA` 是 Windows API 提供的一个函数，用于**向操作系统注册一个窗口类（Window Class）**，以便后续调用 `CreateWindow` 或 `CreateWindowEx` 创建该类的窗口。\n\n> 🧠 为什么这么做？它的用途是什么？\n>\n> 这是所谓的 **函数指针传递**，目的是：\n>\n> - **延迟调用**：我先告诉你该调用哪个函数，以后再执行；\n> - **回调机制（callback）**：我把你告诉我的函数记下来，等事件触发时自动调用；\n> - **模块化设计**：让程序的某个部分（比如初始化、清理、响应某个状态）能被“灵活替换”。\n\n例如：\n\n```c\nvoid callLater(void (*func)(void)) {\n    printf(\"准备调用你给我的函数！\\n\");\n    func();  // 调用传入的函数\n}\n\nvoid sayHello() {\n    printf(\"你好，我是你传入的函数！\\n\");\n}\n\ncallLater(sayHello);\n```\n\n------\n\n​\t看到**sub_415291**，明显的win32窗口程序代码，其作用就是创建主窗口，加载资源（图片），设置控件，初始化一些逻辑组件。\n\n\n\n![image-20250629145153137](/pictures/DSBCTF2024/image-20250629145153137.png)\n\n\n\n​\t**sub_41677B**函数是Windows消息循环处，是程序的“主循环”。**sub_415D40**函数进入看到几百行函数调用，绝大多数都是被nop掉的反调试函数，不过也几个其他关键函数，太懒了，就不要一个个翻了。\n\n```c\nint sub_41677B()\n{\n  int result; // eax\n\n  while ( 1 )\n  {\n    result = dword_42F98C;\t\t//运行控制开关变量\n    if ( !dword_42F98C )\n      break;\n    result = sub_414BC5();\n    if ( result > 9999 )\n      break;\n    if ( PeekMessageA(&Msg, 0, 0, 0, 1u) )\t\t//查询消息（非阻塞）\n    {\n      TranslateMessage(&Msg);\t\t//处理按键等\n      sub_415BEA();\n      sub_41574F();\n      DispatchMessageA(&Msg);\t\t//分发给窗口过程\n    }\n    sub_415D40();\t\t//自定义每帧逻辑\n  }\n  return result;\n}\n```\n\n​\t根据小游戏的提示，得分为10000即可通关，可见**sub_414BC5**函数是返回得分了，进去看看。\n\n```C\nint sub_414BC5()\n{\n  return 12345 - dword_42F99C;\t\t//该静态变量本身初始化为12345，保证起始得分为0.\n}\n```\n\n​\t但是通过交叉引用，可以发现有其他函数在调用它查询分数，跟过去看看**sub_415C43**，查看交叉引用，发现该函数刚好在消息循环的**sub_415D40**函数里面，可以猜测这是通关后逻辑的代码。\n\n​\t它在干嘛呢？先读取用户输入密钥，然后对加密代码进行异或解密，然后通过`VirtualProtect` 将这块内存区域的保护属性改成 `0x40`，也就是 `PAGE_EXECUTE_READWRITE`，允许代码执行，最后调用解密后的函数。密钥是多少呢？根据函数结尾是**retn**指令（**C3**）的特征，查看到最后一个加密字节是**0Fh**，我们得出密钥是**204**。\n\n​\t由于主循环里面每当到10000了程序就直接退出了，根本无法到这一块，所以我们IDA手动改变一下跳转，让这个函数执行一下。\n\n```c\nint sub_415C43()\n{\n  void *v1; // eax\n  int v2; // [esp+4h] [ebp-34h]\n  int v3; // [esp+8h] [ebp-30h]\n  int v4; // [esp+Ch] [ebp-2Ch]\n  int v5; // [esp+10h] [ebp-28h]\n  DWORD flOldProtect; // [esp+14h] [ebp-24h] BYREF\n  int v7[3]; // [esp+18h] [ebp-20h] BYREF\n  int v8; // [esp+28h] [ebp-10h]\n  unsigned int i; // [esp+2Ch] [ebp-Ch]\n  int v10; // [esp+30h] [ebp-8h]\n  int v11; // [esp+34h] [ebp-4h]\n  int savedregs; // [esp+38h] [ebp+0h]\n\n  if ( sub_414BC5() == 10000 )\n  {\n    scanf(\"%d\", v7);\n    HIBYTE(v8) = v7[0];\n    for ( i = 0; i <= 0x16917; ++i )\n      *((_BYTE *)sub_419060 + i) ^= HIBYTE(v8);\n    VirtualProtect(sub_419060, 0x16918u, 0x40u, &flOldProtect);\n    v1 = malloc(0x100000u);\n    sub_419060(v1, v2, v3, v4, v5, flOldProtect, v7[0], v7[1], v7[2], v1, v8, i, v10, v11, savedregs);\n  }\n  return 0;\n}\n```\n\n​\t执行完之后就出现了一个**res.jpg**图片，得到**ctfshow{162dfd79-b4bf-455a-9065-16105e421687}**。\n\n![res.jpg](/pictures/DSBCTF2024/res.jpg)\n\n\n\n\n\n## 没时间好好爱你，所以选择单身\n\n​\t国际惯例，先查壳。无壳，64位程序。\n\n​\tIDA究极好读代码，第一个迷宫**sddssdsssdd**，第二个是做数独（开始还看不出来），看到第三个绷不住了，又tm考魔方，我这魔方就过不去了呗。**RRuFFRRFFUUFFRRFFuRR**。（可以去[网站](https://rubiks-cube-solver.com/)查）\n\n![image-20250629164104513](/pictures/DSBCTF2024/image-20250629164104513.png)\n\n​\t最后的答案是**sddssdsssdd513749862RRuFFRRFFUUFFRRFFuRR**。\n\n​\t打开压缩包里面的txt文件，看到最下面的**ctfshow{After_all_I'm_t0o_busy_to h@ve_t1me_to_l0ve_y0u_we11}**。\n\n\n\n> ​\t这里不得不补一点魔方的基础知识了，国际比赛标准魔方是：**上面白色，前面绿色，下面黄色，后面蓝色，右面红色，左面橙色**。\n>\n> ​\t魔方选择符号，**R表示右面顺时针**，**F表示前面顺时针**，**U表示上面顺时针**，**r(R')表示右面逆时针**，**f(F')表示前面逆时针**，**u(U')表示上面逆时针**。\n\n![image-20250629162655820](/pictures/DSBCTF2024/image-20250629162655820.png)\n\n​\t可以看一个“F”对应的代码，先保存前面的数组数据，然后进行重新赋值。但是，这个代码高低有点问题啊，因为它只修改了前面，没有给周围的四个面更新，不能表示完整的F操作啊，所以说这个函数应该只能说是起一个“提示”的作用。（反正输入正确与否都是一样的提示信息，它也没检查）\n\n```c\n__int64 __fastcall rotateFaceClockwise(int a1)\t\t//a1可能值为0、1、2，因为FRU操作主要\n{\n  __int64 result; // rax\n  _DWORD v2[12]; // [rsp+0h] [rbp-40h]\n  int m; // [rsp+30h] [rbp-10h]\n  int k; // [rsp+34h] [rbp-Ch]\n  int j; // [rsp+38h] [rbp-8h]\n  int i; // [rsp+3Ch] [rbp-4h]\n\n  for ( i = 0; i <= 2; ++i )\n  {\n    for ( j = 0; j <= 2; ++j )\n    {\n      result = j + 3LL * i;\n      v2[result] = cube[9 * a1 + 3 * i + j];\n    }\n  }\n  for ( k = 0; k <= 2; ++k )\n  {\n    for ( m = 0; m <= 2; ++m )\n    {\n      result = m + 9LL * a1 + 3LL * k;\n      cube[result] = v2[3 * (2 - m) + k];\n    }\n  }\n  return result;\n}\n```\n\n","tags":["复现WP","Reverse"],"categories":["CTF"]},{"title":"XYCTF2024","url":"/2025/06/29/XYCTF2024/XYCTF2024/","content":"\n# 聪明的信使\n\n```python\nenc = \"oujp{H0d_TwXf_Lahyc0_14_e3ah_Rvy0ac@wc!}\"\n\nfor i in range(len(enc)):\n    if enc[i].isalpha():\n        if ord(enc[i]) >= 97 and ord(enc[i]) <= 122:\n            print(chr((ord(enc[i]) - 97 - 9) % 26 + 97), end=\"\")\n        else:\n            print(chr((ord(enc[i]) - 65 - 9) % 26 + 65), end=\"\")\n    else:\n        print(enc[i], end=\"\")\n```\n\n\n\n# easy language\n\n​\t自己分析不出来，WP说还是得下插件。\n\n​\t今天晚上最大的收获：下载好了`IDA PRO 7.5`绿色版本，免安装的，下载即用，还能适配易语言反编译器插件，还配置好了设置中文函数名的配置文件问题和DLL文件问题（用大佬的），都能用，太适配了，没有奇怪的环境问题，我太爱了，还顺带遇到一个分享IDA“皮肤”的大佬，我的IDA又升级了，太爽了！\n\n​\tIDA9.0也下载了一个反制控制流平坦化的插件，也太棒了！\n\n​\t简单记录一下我的分析，先根据易语言插件反编译的函数名找到真正的输入框所在的逻辑函数。这里先是通过读取组件的属性来获取文本框的内容，然后使用AES-ECB加密一次，\n\n![image-20250604094838934](/pictures/XYCTF2024/image-20250604094838934.png)\n\n​\t在SUB_403E67函数中调用了SUB_403EE7函数，进行了似于base64的移位、与或操作。\n\n![image-20250604095033633](/pictures/XYCTF2024/image-20250604095033633.png)\n\n​\t回到原函数，后面进行了字符比对和提示信息输出。虽然代码没有过多的混淆，但是还是太难看了，WP上都是猜出来的。我只能先就这样了，取密文base64和AES-ECB解密即可，去找字符串即可。\n\n![image-20250604095318810](/pictures/XYCTF2024/image-20250604095318810.png)\n\n​\t赛博厨子解密如下。\n\n![image-20250604100537143](/pictures/XYCTF2024/image-20250604100537143.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 喵喵喵的flag碎了一地\n\n`flag{My_fl@g_h4s_br0ken_4parT_Bu7_Y0u_c@n_f1x_1t!}`\n\n\n\n\n\n# 给阿姨倒一杯卡布奇诺\n\n​\t逻辑很清晰，没什么新知识，就是又重新熟悉了一般tea的逆向算法。\n\n​\t至于老问题，IDA，大小端的问题，我的认识是：先做，都试一遍。\n\n```c\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n//魔改tea\nvoid detea(uint32_t *v, uint32_t *k, int i);\n//uint32_t data1 = 0x7472795f;\nuint32_t data1 = 0x5F797274;\nuint32_t data2 = 0x64726168;\n//uint32_t data2 = 0x68617264;\nint main()\n{\n    uint32_t enc[8] = {0x9B28ED45, 0x145EC6E9, 0x5B27A6C3, 0xE59E75D5, 0xE82C2500,0xA4211D92,0xCD8A4B62,0xA668F440};\n    //uint32_t enc[8] = {0x45ed289b, 0xe9c65e14, 0xc3a6275b, 0xd5759ee5,0x00252ce8,0x921d21a4,0x624b8acd,0x40f468a6};\n    char key[16] = \"give_you_cup_tea\";\n    for(int i=6; i>=0; i=i-2)\n    {\n        detea(enc, (uint32_t*)key, i);\n    }\n\n    char *flag = (char*)enc;\n    for(int i=0; i<32; i++)\n    {\n        printf(\"%c\", flag[i]);\n    }\n\n    return 0;\n}\n\nvoid detea(uint32_t *v, uint32_t *k, int i)\n{\n    uint32_t v0 = v[i], v1 = v[i+1];\n    uint32_t delta = 0x6E75316C;\n    uint32_t sum = delta * 32;\n    for(int i =31; i >= 0; i--)\n    {\n        v1 -= ((v0 >> 5) + k[3]) ^ (v0 + sum) ^ ((v0 << 4) + k[2]) ^ (sum + i);\n        v0 -= ((v1 >> 5) + k[1]) ^ (v1 + sum) ^ ((v1 << 4) + k[0]) ^ (sum + i);\n        sum = sum - delta;\n    }\n\n    if(i != 0)\n    {\n        v0 ^= v[i-2];\n        v1 ^= v[i-1];\n    }else{\n        v0 ^= data1;\n        v1 ^= data2;\n    }\n    v[i] = v0;\n    v[i+1] = v1;\n}\n```\n\n\n\n\n\n# 你是真的大学生吗？\n\n​\t第一次见这种东西，记录一下。这个代码是一个使用 **8086实模式** 和 **MS-DOS中断** 编写的可执行程序，结构上很典型。\n\n文件极小，只有1kb不到，第一次看这种还没很适应，有点靠注释和猜。IDA反编译源码如下。\n\n```assembly\ndseg:0000 ;\ndseg:0000 ; +-------------------------------------------------------------------------+\ndseg:0000 ; |      This file was generated by The Interactive Disassembler (IDA)      |\ndseg:0000 ; |           Copyright (c) 2024 Hex-Rays, <support@hex-rays.com>           |\ndseg:0000 ; |                      License info: 48-FCB4-5471-8F                      |\ndseg:0000 ; |                                 TOM_RUS                                 |\ndseg:0000 ; +-------------------------------------------------------------------------+\ndseg:0000 ;\ndseg:0000 ; Input SHA256 : DE9713F39D770A61E966FDA9C0A9DDF6C3EF5B4037FF5AD4C7ABB962123AFEA3\ndseg:0000 ; Input MD5    : B64AACBF6ED401B5AE4EB32A63A8E65F\ndseg:0000 ; Input CRC32  : DF414641\ndseg:0000 ; Compiler     : Visual C++ (guessed)\ndseg:0000\ndseg:0000 ; File Name   : F:\\StudyFiles\\CTF\\Review_CTF\\XYCTF2024\\RE\\你是真的大学生吗？.EXE\ndseg:0000 ; Format      : MS-DOS executable (EXE)\ndseg:0000 ; Base Address: 1000h Range: 10000h-100AEh Loaded length: AEh\ndseg:0000 ; Entry Point : 1005:0\ndseg:0000\ndseg:0000                 .686p\ndseg:0000                 .mmx\ndseg:0000                 .model large\ndseg:0000\ndseg:0000 ; ===========================================================================\ndseg:0000\ndseg:0000 ; Segment type: Pure data\ndseg:0000 dseg            segment para stack 'DATA' use16\ndseg:0000                 assume cs:dseg\ndseg:0000 unk_10000       db  0Dh                 ; DATA XREF: start+5↓o\ndseg:0001                 db  0Ah\ndseg:0002                 db  69h ; i\ndseg:0003                 db  6Eh ; n\ndseg:0004                 db  70h ; p\ndseg:0005                 db  75h ; u\ndseg:0006                 db  74h ; t\ndseg:0007                 db  20h\ndseg:0008                 db  73h ; s\ndseg:0009                 db  74h ; t\ndseg:000A                 db  72h ; r\ndseg:000B                 db  69h ; i\ndseg:000C                 db  6Eh ; n\ndseg:000D                 db  67h ; g\ndseg:000E                 db  3Ah ; :\ndseg:000F                 db  24h ; $\ndseg:0010 unk_10010       db  0Dh                 ; DATA XREF: start+15↓o\ndseg:0011                 db  0Ah\ndseg:0012                 db  24h ; $\ndseg:0013 unk_10013       db  0Dh                 ; DATA XREF: start+52↓o\ndseg:0014                 db  0Ah\ndseg:0015                 db  59h ; Y\ndseg:0016                 db  65h ; e\ndseg:0017                 db  73h ; s\ndseg:0018                 db  24h ; $\ndseg:0019 unk_10019       db  76h ; v             ; DATA XREF: start+3D↓o\ndseg:001A                 db  0Eh\ndseg:001B                 db  77h ; w\ndseg:001C                 db  14h\ndseg:001D                 db  60h ; `\ndseg:001E                 db    6\ndseg:001F                 db  7Dh ; }\ndseg:0020                 db    4\ndseg:0021                 db  6Bh ; k\ndseg:0022                 db  1Eh\ndseg:0023                 db  41h ; A\ndseg:0024                 db  2Ah ; *\ndseg:0025                 db  44h ; D\ndseg:0026                 db  2Bh ; +\ndseg:0027                 db  5Ch ; \\\ndseg:0028                 db    3\ndseg:0029                 db  3Bh ; ;\ndseg:002A                 db  0Bh\ndseg:002B                 db  33h ; 3\ndseg:002C                 db    5\ndseg:002D unk_1002D       db  15h                 ; DATA XREF: start+D↓o\ndseg:002E byte_1002E      db 0                    ; DATA XREF: start+21↓r\ndseg:002F unk_1002F       db    0                 ; DATA XREF: start+39↓o\ndseg:0030                 db    0\ndseg:0031                 db    0\ndseg:0032                 db    0\ndseg:0033                 db    0\ndseg:0034                 db    0\ndseg:0035                 db    0\ndseg:0036                 db    0\ndseg:0037                 db    0\ndseg:0038                 db    0\ndseg:0039                 db    0\ndseg:003A                 db    0\ndseg:003B                 db    0\ndseg:003C                 db    0\ndseg:003D                 db    0\ndseg:003E                 db    0\ndseg:003F                 db    0\ndseg:0040                 db    0\ndseg:0041                 db    0\ndseg:0042                 db    0\ndseg:0043                 db    0\ndseg:0044                 db    0\ndseg:0045                 db    0\ndseg:0046                 db    0\ndseg:0047                 db    0\ndseg:0048                 db    0\ndseg:0049                 db    0\ndseg:004A                 db    0\ndseg:004B                 db    0\ndseg:004C                 db    0\ndseg:004D                 db    0\ndseg:004E                 db    0\ndseg:004F                 db    0\ndseg:004F dseg            ends\ndseg:004F\nseg001:0000 ; ===========================================================================\nseg001:0000\nseg001:0000 ; Segment type: Pure code\nseg001:0000 seg001          segment byte public 'CODE' use16\nseg001:0000                 assume cs:seg001\nseg001:0000                 assume es:nothing, ss:dseg, ds:nothing, fs:nothing, gs:nothing\nseg001:0000\nseg001:0000 ; =============== S U B R O U T I N E =======================================\nseg001:0000\nseg001:0000 ; Attributes: noreturn\nseg001:0000\nseg001:0000                 public start\nseg001:0000 start           proc near\nseg001:0000                 mov     ax, seg dseg\nseg001:0003                 mov     ds, ax\nseg001:0005                 assume ds:dseg\nseg001:0005                 lea     dx, unk_10000\nseg001:0009                 mov     ah, 9\nseg001:000B                 int     21h             ; DOS - PRINT STRING\nseg001:000B                                         ; DS:DX -> string terminated by \"$\"\nseg001:000D                 lea     dx, unk_1002D\nseg001:0011                 mov     ah, 0Ah\nseg001:0013                 int     21h             ; DOS - BUFFERED KEYBOARD INPUT\nseg001:0013                                         ; DS:DX -> buffer\nseg001:0015                 lea     dx, unk_10010\nseg001:0019                 mov     ah, 9\nseg001:001B                 int     21h             ; DOS - PRINT STRING\nseg001:001B                                         ; DS:DX -> string terminated by \"$\"\nseg001:001D                 xor     cx, cx\nseg001:001F                 xor     ax, ax\nseg001:0021                 mov     cl, byte_1002E\nseg001:0025                 mov     si, 2Fh ; '/'\nseg001:0028                 mov     al, [si]\nseg001:002A                 add     si, cx\nseg001:002C\nseg001:002C loc_1007C:                              ; CODE XREF: start+37↓j\nseg001:002C                 sub     si, 1\nseg001:002F                 xor     [si], al\nseg001:0031                 mov     al, [si]\nseg001:0033                 dec     cx\nseg001:0034                 cmp     cx, 0\nseg001:0037                 jnz     short loc_1007C\nseg001:0039                 lea     si, unk_1002F\nseg001:003D                 lea     di, unk_10019\nseg001:0041\nseg001:0041 loc_10091:                              ; CODE XREF: start+50↓j\nseg001:0041                 mov     al, [si]\nseg001:0043                 mov     bl, [di]\nseg001:0045                 add     si, 1\nseg001:0048                 inc     di\nseg001:0049                 cmp     al, bl\nseg001:004B                 jnz     short loc_100AA\nseg001:004D                 cmp     cx, 0\nseg001:0050                 jnz     short loc_10091\nseg001:0052                 lea     dx, unk_10013\nseg001:0056                 mov     ah, 9\nseg001:0058                 int     21h             ; DOS - PRINT STRING\nseg001:0058                                         ; DS:DX -> string terminated by \"$\"\nseg001:005A\nseg001:005A loc_100AA:                              ; CODE XREF: start+4B↑j\nseg001:005A                 mov     ah, 4Ch\nseg001:005C                 int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)\nseg001:005C start           endp                    ; AL = exit code\nseg001:005C\nseg001:005C seg001          ends\nseg001:005C\nseg001:005C\nseg001:005C                 end start\n```\n\n```python\ndata = [0x76,0xe,0x77,0x14,0x60,0x6,0x7d,0x4,0x6b,0x1e,0x41,0x2a,0x44,0x2b,0x5c,0x3,0x3b,0xb,0x33,0x5,0x15]\nfor i in range(len(data),0):\n\tprint(chr(data[i] ^ data[i+1]), end='')\n```\n\n\n\n# 砸核桃\n\n​\t新壳，NsPacK3.x，国产壳，北斗，通常是病毒使用的壳。还以为网上能找到现成的脱壳工具，经过只有一个08年的老东西，还用不了了。看WP也是手动脱壳，我也手撕吧。还以为能和获得新工具了，哎，这也是个压缩壳，堆栈平衡同样适用。\n\n​\t32位程序，很明显的`pushfd`、`pushad`、`popfd`、`popad`指令。\n\n​\t然后就是最基础的异或加密，直接看脚本。\n\n```python\nxor = \"this_is_not_flag\"\nenc = [0x12,0x4,0x8,0x14,0x24,0x5c,0x4a,0x3d,0x56,0xa,0x10,0x67,0x0,0x41,0x0,0x1,0x46,0x5a,0x44,0x42,0x6e,0xc,0x44,0x72,0xc,0xd,0x40,0x3e,0x4b,0x5f,0x2,0x1,0x4c,0x5e,0x5b,0x17,0x6e,0xc,0x16,0x68,0x5b,0x12]\nfor i in range(len(enc)):\n    print(chr(enc[i] ^ ord(xor[i % len(xor)])), end='')\n```\n\n\n\n\n\n# DebugMe（APK）\n\n​\tapk逆向，先放一边。\n\n​\tJADX打开，没有可以看的代码，不知道怎么回事，很多乱码。我之前的文件都能显示，工具没有问题，那就是有防护手段了。不会，不想去搜了，直接看WP学习。\n\n​\t先找资源下载JEB，付费软件，得破解版。\n\n​\t下载好了，使用和JADX差不多，生成的项目文件都是和原文件保存在一起，这一点特别好，不需要我们自己去设置路径了，也不容易C盘爆了。\n\n​\t需要修改mainfest中的可调式属性。使用`apktool d DebugMe.apk -o out`解包，修改好后，使用命令`apktool b out -o target_debug.apk`重新打包。但是好像没有这么简单。\n\n\n\n​\t最后成功了，记录一下环境配置的过程。\n\n​\t首先，要使用MT管理器直接在模拟器中修改`Android.mainfest.xml`文件，添加`android:debuggable=\"true\"`，修改之后保存文件，然后使用MT自动打包成新的APK。\n\n​\t将新的APK通过模拟器的共享文件夹传回到电脑上，使用JEB打开反编译。之后就是开始调试APK了，注意：先要将`adb`添加到环境变量里面，JEB就是通过adb来找到模拟器设备的。然后使用 `adb devices`命令查看设备，然后使用命令`adb shell am start -D -n com.xyctf.ezapk/.MainActivity`启动待调试的进程，其中-n后面是待调试的包名等等。\n\n​\t再在JEB中打开调试器，选择好对应的模拟器和进程，就可以成功调试了。正常调试注意加断点再连接程序。\n\n![image-20250603173505598](/pictures/XYCTF2024/image-20250603173505598.png)\n\n​\t`XYCTF{d3bugg3r_15_v3ry_u53ful}`\n\n\n\n\n\n\n\n\n\n# 舔狗四部曲--简爱\n\n​\t一开始吧，DIE分析是ELF程序，就直接IDA打开。（但实际上是.o文件，使用gcc链接，当然IDA反编译出来代码都差不多）。\n\n​\t最后是对src数组和s数组进行比较，但是很奇怪的是，src数据就是没有变化，这里是对s数组加密两次后再使用howtolove函数加密，所以正常的逆向逻辑也应该是三次逆向函数解密。![image-20250602201458975](/pictures/XYCTF2024/image-20250602201458975.png)\n\n​\t但是，看WP可以分析知，程序的源码就是对密文和输入的，都进行了加密，然后调用howtolove，然后才比对，比对对象是`user_input_int`和`plaintext_int`。而howtolove加密的是`loveletter`，也就是说比对就是假比对，那一层encipher加密完全没有必要，就相当于在输入字符串和假flag进行明文比对。这个程序中的比对就不是正常的，我们不能按照正常的逻辑取预期我们输入正确flag就会输出正确的提示信息。不难猜出，作者想要告诉我们，howtolove函数才是加密的逻辑。\n\n​\t算了，不想多说了，我怀疑源码就是错的版本，怎么能这样验证啊。\n\n![image-20250602201907424](/pictures/XYCTF2024/image-20250602201907424.png)\n\n![image-20250602201956024](/pictures/XYCTF2024/image-20250602201956024.png)\n\n\n\n​\t分析半天，一调试就发现，dest是tm指向src的副本，v14是指向和s同样内容的，但是v14是指向s的副本的，后面的s才是真正对s数组进行加密的，所以实际上最后比对就是src数组和howtolove(s)得到的数组。\n\n​\t狗日的反编译一点看不出来，看着就是对指针进行操作，指向的就是同一个数组啊，再也不信反编译的伪代码了。\n\n​\t当然，后面问AI又想到一些：memcpy函数一般是对两个不同地址的数组进行复制操作，如果v14和s指针相同的话，那处理的就是同一块内存了，那复制还有什么意义呢！这里可能能get到一些异常之处，开始没有这个理解。\n\n​\t下面自己写的代码附上。\n\n```c\n#include <stdio.h>\n#include <stdlib.h> \n#include <stdint.h>\n#include <string.h>\n\nvoid re_howtolove(char *a1)\n{\n    int v2[1802] = {0};\n    //memset(v2, 0, sizeof(v2));\n    v2[32] = 2;\n    v2[65] = 2;\n    v2[66] = 4;\n    v2[98] = 2;\n    v2[99] = 5;\n    v2[185] = 2;\n    v2[186] = 2;\n    v2[187] = 1;\n    v2[188] = 1;\n    v2[189] = 1;\n    v2[190] = 1;\n    v2[191] = 1;\n    v2[192] = 1;\n    v2[193] = 1;\n    v2[194] = 1;\n    v2[195] = 1;\n    v2[196] = 1;\n    v2[197] = 1;\n    v2[198] = 1;\n    v2[199] = 1;\n    v2[200] = 1;\n    v2[201] = 1;\n    v2[202] = 1;\n    v2[203] = 1;\n    v2[204] = 1;\n    v2[205] = 1;\n    v2[206] = 1;\n    v2[207] = 1;\n    v2[208] = 1;\n    v2[209] = 1;\n    v2[210] = 1;\n    v2[211] = 1;\n    v2[212] = 1;\n    v2[213] = 1;\n    v2[214] = 1;\n    v2[215] = 1;\n    v2[216] = 1;\n    v2[217] = 1;\n    v2[218] = 1;\n    v2[219] = 1;\n    v2[220] = 1;\n    v2[221] = 1;\n    v2[222] = 1;\n    v2[223] = 1;\n    v2[224] = 1;\n    v2[225] = 1;\n    v2[226] = 1;\n    v2[227] = 1;\n    v2[228] = 1;\n    v2[229] = 2;\n    v2[232] = 2;\n    v2[256] = 2;\n    v2[257] = 5;\n    v2[303] = 1;\n    v2[304] = 1;\n    v2[305] = 1;\n    v2[306] = 1;\n    v2[307] = 2;\n    v2[308] = 5;\n    v2[328] = 1;\n    v2[329] = 1;\n    v2[330] = 1;\n    v2[331] = 1;\n    v2[332] = 1;\n    v2[333] = 1;\n    v2[334] = 1;\n    v2[335] = 1;\n    v2[336] = 1;\n    v2[337] = 1;\n    v2[338] = 1;\n    v2[339] = 1;\n    v2[340] = 1;\n    v2[341] = 1;\n    v2[342] = 2;\n    v2[353] = 2;\n    v2[354] = 5;\n    v2[430] = 2;\n    v2[431] = 2;\n    v2[432] = 5;\n    v2[523] = 2;\n    v2[524] = 5;\n    v2[564] = 2;\n    v2[565] = 5;\n    v2[627] = 2;\n    v2[628] = 1;\n    v2[629] = 1;\n    v2[630] = 1;\n    v2[631] = 1;\n    v2[632] = 1;\n    v2[633] = 1;\n    v2[634] = 1;\n    v2[635] = 1;\n    v2[636] = 1;\n    v2[637] = 1;\n    v2[638] = 1;\n    v2[639] = 1;\n    v2[640] = 1;\n    v2[641] = 1;\n    v2[642] = 1;\n    v2[643] = 1;\n    v2[644] = 1;\n    v2[645] = 1;\n    v2[646] = 1;\n    v2[647] = 2;\n    v2[648] = 4;\n    v2[649] = 1;\n    v2[650] = 1;\n    v2[651] = 1;\n    v2[652] = 1;\n    v2[653] = 2;\n    v2[680] = 2;\n    v2[687] = 2;\n    v2[688] = 4;\n    v2[698] = 2;\n    v2[766] = 2;\n    v2[767] = 5;\n    v2[818] = 2;\n    v2[819] = 1;\n    v2[820] = 2;\n    v2[827] = 2;\n    v2[828] = 5;\n    v2[846] = 2;\n    v2[847] = 5;\n    v2[890] = 2;\n    v2[891] = 1;\n    v2[892] = 1;\n    v2[893] = 1;\n    v2[894] = 1;\n    v2[895] = 1;\n    v2[896] = 1;\n    v2[897] = 1;\n    v2[898] = 1;\n    v2[899] = 1;\n    v2[900] = 1;\n    v2[901] = 1;\n    v2[902] = 1;\n    v2[903] = 1;\n    v2[904] = 1;\n    v2[905] = 1;\n    v2[906] = 1;\n    v2[907] = 1;\n    v2[908] = 1;\n    v2[909] = 1;\n    v2[910] = 1;\n    v2[911] = 1;\n    v2[912] = 1;\n    v2[913] = 1;\n    v2[914] = 1;\n    v2[915] = 1;\n    v2[916] = 1;\n    v2[917] = 1;\n    v2[918] = 1;\n    v2[919] = 1;\n    v2[920] = 1;\n    v2[921] = 1;\n    v2[922] = 1;\n    v2[923] = 1;\n    v2[924] = 1;\n    v2[925] = 1;\n    v2[926] = 1;\n    v2[927] = 1;\n    v2[928] = 1;\n    v2[929] = 1;\n    v2[930] = 1;\n    v2[931] = 1;\n    v2[932] = 1;\n    v2[933] = 2;\n    v2[934] = 5;\n    v2[989] = 2;\n    v2[994] = 2;\n    v2[995] = 1;\n    v2[996] = 1;\n    v2[997] = 1;\n    v2[998] = 1;\n    v2[999] = 1;\n    v2[1000] = 1;\n    v2[1001] = 1;\n    v2[1002] = 1;\n    v2[1003] = 1;\n    v2[1013] = 1;\n    v2[1014] = 1;\n    v2[1015] = 1;\n    v2[1016] = 1;\n    v2[1017] = 1;\n    v2[1018] = 1;\n    v2[1019] = 1;\n    v2[1020] = 1;\n    v2[1021] = 1;\n    v2[1022] = 1;\n    v2[1023] = 1;\n    v2[1024] = 1;\n    v2[1025] = 1;\n    v2[1026] = 1;\n    v2[1027] = 2;\n    v2[1028] = 3;\n\n    int v3 =1027,v4 =31;\n    \n    // for(; v3>=0; --v3)\n    // {\n    //     switch(v2[v3])\n    //     {\n    //         case 0:\n    //             --crypted[v4];\n    //             break;\n    //         case 1:\n    //             ++crypted[v4];\n    //             break;\n    //         case 2:\n    //             v4--;\n    //             break;\n    //         case 4:\n    //             crypted[v4] -= crypted[v4+1] + 70 ;\t\t这里就是错误之处，这个错误语句等价于-(crypted[v4+1]+70)，是错误的啊，我们要的实际上是-crypted[v4+1]-70。\n    //             break;\n    //         case 5:\n    //             crypted[v4] += crypted[v4+1] - 70 ;\t\t\t这里同理。\n    //             break;\n    //         default:\n    //             break;\n    //     }\n    // }\n    \n    for(; v3>=0; --v3)\n    {\n        switch(v2[v3])\n        {\n            case 0:\n                --a1[v4];\n                break;\n            case 1:\n                ++a1[v4];\n                break;\n            case 2:\n                v4--;\n                break;\n            case 4:\n                a1[v4] = a1[v4] - a1[v4+1] + 70 ;\n                break;\n            case 5:\n                a1[v4] = a1[v4] + a1[v4+1] - 70 ;\n                break;\n            default:\n                break;\n        }\n    }\n}\n\n//无用的tea\nvoid detea(uint32_t *v, uint32_t *k)\n{\n    int rounds = 52;\n    uint32_t v0 = v[0];\n    uint32_t v1 = v[1];\n    uint32_t delta = 0x9E3779B9;\n    uint32_t sum = delta * rounds;\n    for(int i=0;i<rounds;i++)\n    {\n        v1 -= (((v0 >> 4)^(v0<<5)) + v0) ^ (k[(sum >> 11) & 3] + sum);\n        sum -= delta;\n        v0 -= (((v1 >> 4)^(v1<<5)) + v1) ^ (k[sum & 3] + sum);\n    }\n    v[0] = v0;\n    v[1] = v1;\n}\n\n\nint main()\n{\n    char crypted[32] = \"flag{Love_is_not_one_sided_Love}\";\n    re_howtolove(crypted);\n    //uint32_t key[4] = {0x12345678,0x9ABCDEF0,0x9AB111F0,0x9A323EF0};\n    //detea((uint32_t *)crypted, key);\n    //detea((uint32_t *)crypted, key);\n    for(int i=0;i<32;i++)\n    {\n        printf(\"%c\",crypted[i]);\n    }\n    return 0;\n}\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n# 何须相思煮余年\n\n​\t给了个纯文本，6，看着应该是机器码和密文。结果跪了，32、64位都不行。\n\n​\t看WP使用了一个python库，来进行反汇编，是x86-32的。\n\n​\t下面是反汇编的代码。\n\n```python\nfrom capstone import *\n\ncode = \"\"\"\n0x55  0x8b  0xec  0x81  0xec  0xa8  0x0  0x0  0x0  0xa1  0x0  0x40  0x41  0x0  0x33  0xc5  0x89  0x45  0xfc  0x68  0x9c  0x0  0x0  0x0  0x6a  0x0  0x8d  0x85  0x60  0xff  0xff  0xff  0x50  0xe8  0x7a  0xc  0x0  0x0  0x83  0xc4  0xc  0xc7  0x85  0x58  0xff  0xff  0xff  0x27  0x0  0x0  0x0  0xc7  0x85  0x5c  0xff  0xff  0xff  0x0  0x0  0x0  0x0  0xeb  0xf  0x8b  0x8d  0x5c  0xff  0xff  0xff  0x83  0xc1  0x1  0x89  0x8d  0x5c  0xff  0xff  0xff  0x83  0xbd  0x5c  0xff  0xff  0xff  0x27  0xf  0x8d  0xed  0x0  0x0  0x0  0x8b  0x95  0x5c  0xff  0xff  0xff  0x81  0xe2  0x3  0x0  0x0  0x80  0x79  0x5  0x4a  0x83  0xca  0xfc  0x42  0x85  0xd2  0x75  0x25  0x8b  0x85  0x5c  0xff  0xff  0xff  0x8b  0x8c  0x85  0x60  0xff  0xff  0xff  0x3  0x8d  0x5c  0xff  0xff  0xff  0x8b  0x95  0x5c  0xff  0xff  0xff  0x89  0x8c  0x95  0x60  0xff  0xff  0xff  0xe9  0xac  0x0  0x0  0x0  0x8b  0x85  0x5c  0xff  0xff  0xff  0x25  0x3  0x0  0x0  0x80  0x79  0x5  0x48  0x83  0xc8  0xfc  0x40  0x83  0xf8  0x1  0x75  0x22  0x8b  0x8d  0x5c  0xff  0xff  0xff  0x8b  0x94  0x8d  0x60  0xff  0xff  0xff  0x2b  0x95  0x5c  0xff  0xff  0xff  0x8b  0x85  0x5c  0xff  0xff  0xff  0x89  0x94  0x85  0x60  0xff  0xff  0xff  0xeb  0x73  0x8b  0x8d  0x5c  0xff  0xff  0xff  0x81  0xe1  0x3  0x0  0x0  0x80  0x79  0x5  0x49  0x83  0xc9  0xfc  0x41  0x83  0xf9  0x2  0x75  0x23  0x8b  0x95  0x5c  0xff  0xff  0xff  0x8b  0x84  0x95  0x60  0xff  0xff  0xff  0xf  0xaf  0x85  0x5c  0xff  0xff  0xff  0x8b  0x8d  0x5c  0xff  0xff  0xff  0x89  0x84  0x8d  0x60  0xff  0xff  0xff  0xeb  0x38  0x8b  0x95  0x5c  0xff  0xff  0xff  0x81  0xe2  0x3  0x0  0x0  0x80  0x79  0x5  0x4a  0x83  0xca  0xfc  0x42  0x83  0xfa  0x3  0x75  0x20  0x8b  0x85  0x5c  0xff  0xff  0xff  0x8b  0x8c  0x85  0x60  0xff  0xff  0xff  0x33  0x8d  0x5c  0xff  0xff  0xff  0x8b  0x95  0x5c  0xff  0xff  0xff  0x89  0x8c  0x95  0x60  0xff  0xff  0xff  0xe9  0xf7  0xfe  0xff  0xff  0x33  0xc0  0x8b  0x4d  0xfc  0x33  0xcd  0xe8  0x4  0x0  0x0  0x0  0x8b  0xe5  0x5d  0xc3\n\"\"\"\n\nopcode = []\ncode = code.split()\nfor i in range(0, len(code), 1):\n    opcode.append(int(code[i][2:], 16))\n    print(hex(opcode[i]), end=' ')\n\n\nopcode = bytes(opcode)\n\nBaseAddr = 0\n\nmd = Cs(CS_ARCH_X86, CS_MODE_32)\nfor x in md.disasm(opcode, 0):\n    addr = x.address + BaseAddr\n    print(hex(addr)[2:],x.mnemonic,x.op_str)\n```\n\n​\t这个题还是一点难度的，需要擅长汇编代码，或者擅长chatgpt（哈哈）。\n\n```assembly\n1 mov ebp, esp\n3 sub esp, 0xa8\n9 mov eax, dword ptr [0x414000]\ne xor eax, ebp\n10 mov dword ptr [ebp - 4], eax\n13 push 0x9c\n18 push 0\n1a lea eax, [ebp - 0xa0]\n20 push eax\n21 call 0xca0\n26 add esp, 0xc\n29 mov dword ptr [ebp - 0xa8], 0x27\n33 mov dword ptr [ebp - 0xa4], 0\n3d jmp 0x4e\n3f mov ecx, dword ptr [ebp - 0xa4]\n45 add ecx, 1\n48 mov dword ptr [ebp - 0xa4], ecx\t\t\t;i++\n4e cmp dword ptr [ebp - 0xa4], 0x27\t\t\t;i<0x27\n55 jge 0x148\n5b mov edx, dword ptr [ebp - 0xa4]\n61 and edx, 0x80000003\t\t\t\t\t\t;取符号位和最低2位\n67 jns 0x6e\t\t\t\t\t\t\t\t\t;结果非负跳转\n69 dec edx\n6a or edx, 0xfffffffc\n6d inc edx\n6e test edx, edx\t\t\t\t\t;按位与，但不保存结果，只设置标志位Z\n70 jne 0x97\t\t\t\t\t\t\t\t;edx!=0跳转\n72 mov eax, dword ptr [ebp - 0xa4]\n78 mov ecx, dword ptr [ebp + eax*4 - 0xa0]\t\t;数组取值，设数组是s\n7f add ecx, dword ptr [ebp - 0xa4]\t\t\t;s[i]+i\n85 mov edx, dword ptr [ebp - 0xa4]\n8b mov dword ptr [ebp + edx*4 - 0xa0], ecx    ;s[i]=s[i]+i\n92 jmp 0x143\n97 mov eax, dword ptr [ebp - 0xa4]\n9d and eax, 0x80000003\na2 jns 0xa9\t\t\t\t\t\t\t;符号位为0跳转\na4 dec eax\na5 or eax, 0xfffffffc\na8 inc eax\na9 cmp eax, 1\t\t\t\t\nac jne 0xd0\nae mov ecx, dword ptr [ebp - 0xa4]\nb4 mov edx, dword ptr [ebp + ecx*4 - 0xa0]\nbb sub edx, dword ptr [ebp - 0xa4]\t\t\t;s[i]-i\nc1 mov eax, dword ptr [ebp - 0xa4]\nc7 mov dword ptr [ebp + eax*4 - 0xa0], edx\t\t;s[i]=s[i]-i\nce jmp 0x143\nd0 mov ecx, dword ptr [ebp - 0xa4]\nd6 and ecx, 0x80000003\ndc jns 0xe3\nde dec ecx\ndf or ecx, 0xfffffffc\ne2 inc ecx\ne3 cmp ecx, 2\ne6 jne 0x10b\ne8 mov edx, dword ptr [ebp - 0xa4]\nee mov eax, dword ptr [ebp + edx*4 - 0xa0]\nf5 imul eax, dword ptr [ebp - 0xa4]\t\t;s[i] * i\nfc mov ecx, dword ptr [ebp - 0xa4]\n102 mov dword ptr [ebp + ecx*4 - 0xa0], eax\n109 jmp 0x143\n10b mov edx, dword ptr [ebp - 0xa4]\n111 and edx, 0x80000003\n117 jns 0x11e\n119 dec edx\n11a or edx, 0xfffffffc\n11d inc edx\n11e cmp edx, 3\n121 jne 0x143\n123 mov eax, dword ptr [ebp - 0xa4]\n129 mov ecx, dword ptr [ebp + eax*4 - 0xa0]\n130 xor ecx, dword ptr [ebp - 0xa4]\t\t\t;s[i] ^ i\n136 mov edx, dword ptr [ebp - 0xa4]\n13c mov dword ptr [ebp + edx*4 - 0xa0], ecx\n143 jmp 0x3f\n148 xor eax, eax\n14a mov ecx, dword ptr [ebp - 4]\n14d xor ecx, ebp\n14f call 0x158\n154 mov esp, ebp\n156 pop ebp\n157 ret \n```\n\n```python\nenc = [88,88,134,87,74,118,318,101,59,92,480,60,65,41,770,110,73,31,918,39,120,27,1188,47,77,24,1352,44,81,23,1680,46,85,15,1870,66,91,16,4750]\n\nfor i in range(len(enc)):\n    if i % 4 == 0:\n        print(chr(enc[i]-i), end='')\n        continue\n    if i % 4 == 1:\n        print(chr(enc[i]+i), end='')\n        continue\n    if i % 4 == 2:\n        print(chr(enc[i]//i), end='')\t\t\t#需要是整除，向下取整\n        continue\n    if i % 4 == 3:\n        print(chr(enc[i]^i), end='')\n        continue\n```\n\n\n\n\n\n# ez_enc\n\n​\t\n\n```python\nenc = [0x27,0x24,0x17,0xb,0x50,0x3,0xc8,0xc,0x1f,0x17,0x36,0x55,0xcb,0x2d,0xe9,0x32,0xe,0x11,0x26,0x2,0xc,0x7,0xfc,0x27,0x3d,0x2d,0xed,0x35,0x59,0xeb,0x3c,0x3e,0xe4,0x7d]\n\nkey = \"IMouto\"\n\nfor i in range(len(enc)-2, 0, -1):\n    enc[i] = enc[i] ^ ord(key[i%6])\n    enc[i] = enc[i] - enc[i+1]\n\t\n    #用上一个字符求出来的tmp必满足在0到20之间的限制\n    tmp = enc[i-1] ^ ord(key[(i-1)%6])\n    tmp = tmp - enc[i]\n    enc[i] += tmp // 20 * 20\n\nprint(\"f\", end=\"\")\t\t#第一个就不用算了\nfor i in range(1,len(enc)):\n    print(chr(enc[i]), end=\"\")\n```\n\n\n\n\n\n# baby unity\n\n​\t游戏是unity做的输入验证文本框？哈，这么搞是吧，小游戏都不给玩，不会逆，直接学WP。\n\n​\tGameAssembly.dll和baby unity.exe都被upx压缩了一下，师傅说单纯为了减少附件的大小，哈，还得先去壳。\n\n​\t先使用Il2CppDumper.exe恢复符号信息，先选.dll文件，再选.bat文件。然后使用IDA打开DLL文件，使用python脚本ida_with_struct_py3.py加载刚刚得到的script.json和il2cpp.h文件。\n\n​\t再使用dnSpy去查看Assembly-CSharp.dll文件，看其中可疑的类名、方法名，但是里面是没办法看源码的，所以要回到IDA中查看反编译的源码，由于恢复了符号信息，所以我们使用IDA直接搜索函数名就行了。\n\n![image-20250605150220575](/pictures/XYCTF2024/image-20250605150220575.png)\n\n![image-20250605150236561](/pictures/XYCTF2024/image-20250605150236561.png)\n\n​\t看到IDA，我们换个主题颜色，之前的有点看腻了。看到明显的base64和异或0xF，比较奇怪的是密文居然是在注释里，难不成这个8字节保存的是一个指针，指向其他文件中的字符串，这里能看到是因为恢复了符号信息，这里自动把字符串取出放在这里了？\n\n​\t之后赛博厨子解密就好。\n\n![image-20250605151110999](/pictures/XYCTF2024/image-20250605151110999.png)\n\n![image-20250605151155177](/pictures/XYCTF2024/image-20250605151155177.png)\n\n\n\n\n\n\n\n\n\n# ez unity（未做，环境不行）\n\n​\t这种il2cpp的unity逆向完全没有接触过，现在都是实行WP学习大法，配环境就花了好长时间，下面记录一下我踩的坑。\n\n​\t首先将能够生成hook.js脚本的方法，先通过pip下载好frida和frida-tools工具，然后通过`npm i frida-il2cpp-bridge`命令下载下来框架，然后配置package.json文件，具体内容根据需要配置（当然去抄），[详细的教程](https://blog.csdn.net/weixin_44292683/article/details/132125663)文章就是这个，就是其中的方法2。\n\n​\t在一切准备就绪后，我执行第一个注入命令就报错了，我反复更换文件，更换frida环境到16.2.1和17.1.0，也重下了题目附件，在虚拟机CTFOS和本机上都试过了，但是都是报出同样一个错误，我完全不理解是为什么。\n\n![image-20250606202411829](/pictures/XYCTF2024/image-20250606202411829.png)\n\n​\t后面使用教程的第一种方法编译frida-il2cpp-bridge项目后，也是没能解决问题。\n\n![image-20250606204030666](/pictures/XYCTF2024/image-20250606204030666.png)\n\n​\t\n\n\n\n\n\n\n\n\n\n\n\n# ezmath\n\n​\tpython逆向，一个二次多项式求解问题，学习z3求解器。解包出来，是以这种形式来表示乘积的：`sum( (lambda .0: [ flag[23] for _ in .0 ])(range(flag[23])) )`。\n\n​\t强行使用z3破解，耗时很长，我等了十几分钟都没结果，不知道还要算多久，直接看WP，有一个很巧妙的思路，因为这个二次多项式=0，而且式子中每个二次项的系数都是1，我们知道(x_i - ord(flag[i]))**2 = 0，那么所有的这些式子展开就会得到该题的的式子，也就是说，附件中给出的二次多项式就是将二次平方项展开的结果。这样就有一个规律了，所有的一次项系数除以2就是对应的常数值（对应flag的ASCII码值）。\n\n​\t应该说这是一个数学推导技巧，在数学题中也会使用的技巧。初中生都会，大学生想不到一点。\n\n```python\nimport re\nstr = \"\"\"\nflag = (lambda .0: [ ord(i) for i in .0 ])(input('flag:'))\nif len(flag) == 32 and (((((((((((((((((((((sum((lambda .0: [ flag[23] for _ in .0 ])(range(flag[23]))) + sum((lambda .0: [ flag[12] for _ in .0 ])(range(flag[12]))) + sum((lambda .0: [ flag[1] for _ in .0 ])(range(flag[1]))) - sum((lambda .0: [ flag[24] for _ in .0 ])(range(222)))) + sum((lambda .0: [ flag[22] for _ in .0 ])(range(flag[22]))) + sum((lambda .0: [ flag[31] for _ in .0 ])(range(flag[31]))) + sum((lambda .0: [ flag[26] for _ in .0 ])(range(flag[26]))) - sum((lambda .0: [ flag[9] for _ in .0 ])(range(178))) - sum((lambda .0: [ flag[29] for _ in .0 ])(range(232)))) + sum((lambda .0: [ flag[17] for _ in .0 ])(range(flag[17]))) - sum((lambda .0: [ flag[23] for _ in .0 ])(range(150))) - sum((lambda .0: [ flag[6] for _ in .0 ])(range(226))) - sum((lambda .0: [ flag[7] for _ in .0 ])(range(110)))) + sum((lambda .0: [ flag[19] for _ in .0 ])(range(flag[19]))) + sum((lambda .0: [ flag[2] for _ in .0 ])(range(flag[2]))) - sum((lambda .0: [ flag[0] for _ in .0 ])(range(176)))) + sum((lambda .0: [ flag[10] for _ in .0 ])(range(flag[10]))) - sum((lambda .0: [ flag[12] for _ in .0 ])(range(198)))) + sum((lambda .0: [ flag[24] for _ in .0 ])(range(flag[24]))) + sum((lambda .0: [ flag[9] for _ in .0 ])(range(flag[9]))) - sum((lambda .0: [ flag[3] for _ in .0 ])(range(168)))) + sum((lambda .0: [ flag[8] for _ in .0 ])(range(flag[8]))) - sum((lambda .0: [ flag[2] for _ in .0 ])(range(134)))) + sum((lambda .0: [ flag[14] for _ in .0 ])(range(flag[14]))) - sum((lambda .0: [ flag[13] for _ in .0 ])(range(170)))) + sum((lambda .0: [ flag[4] for _ in .0 ])(range(flag[4]))) - sum((lambda .0: [ flag[10] for _ in .0 ])(range(142)))) + sum((lambda .0: [ flag[27] for _ in .0 ])(range(flag[27]))) + sum((lambda .0: [ flag[15] for _ in .0 ])(range(flag[15]))) - sum((lambda .0: [ flag[15] for _ in .0 ])(range(224)))) + sum((lambda .0: [ flag[16] for _ in .0 ])(range(flag[16]))) - sum((lambda .0: [ flag[11] for _ in .0 ])(range(230))) - sum((lambda .0: [ flag[1] for _ in .0 ])(range(178)))) + sum((lambda .0: [ flag[28] for _ in .0 ])(range(flag[28]))) - sum((lambda .0: [ flag[5] for _ in .0 ])(range(246))) - sum((lambda .0: [ flag[17] for _ in .0 ])(range(168)))) + sum((lambda .0: [ flag[30] for _ in .0 ])(range(flag[30]))) - sum((lambda .0: [ flag[21] for _ in .0 ])(range(220))) - sum((lambda .0: [ flag[22] for _ in .0 ])(range(212))) - sum((lambda .0: [ flag[16] for _ in .0 ])(range(232)))) + sum((lambda .0: [ flag[25] for _ in .0 ])(range(flag[25]))) - sum((lambda .0: [ flag[4] for _ in .0 ])(range(140))) - sum((lambda .0: [ flag[31] for _ in .0 ])(range(250))) - sum((lambda .0: [ flag[28] for _ in .0 ])(range(150)))) + sum((lambda .0: [ flag[11] for _ in .0 ])(range(flag[11]))) + sum((lambda .0: [ flag[13] for _ in .0 ])(range(flag[13]))) - sum((lambda .0: [ flag[14] for _ in .0 ])(range(234)))) + sum((lambda .0: [ flag[7] for _ in .0 ])(range(flag[7]))) - sum((lambda .0: [ flag[8] for _ in .0 ])(range(174)))) + sum((lambda .0: [ flag[3] for _ in .0 ])(range(flag[3]))) - sum((lambda .0: [ flag[25] for _ in .0 ])(range(242)))) + sum((lambda .0: [ flag[29] for _ in .0 ])(range(flag[29]))) + sum((lambda .0: [ flag[5] for _ in .0 ])(range(flag[5]))) - sum((lambda .0: [ flag[30] for _ in .0 ])(range(142))) - sum((lambda .0: [ flag[26] for _ in .0 ])(range(170))) - sum((lambda .0: [ flag[19] for _ in .0 ])(range(176)))) + sum((lambda .0: [ flag[0] for _ in .0 ])(range(flag[0]))) - sum((lambda .0: [ flag[27] for _ in .0 ])(range(168)))) + sum((lambda .0: [ flag[20] for _ in .0 ])(range(flag[20]))) - sum((lambda .0: [ flag[20] for _ in .0 ])(range(212)))) + sum((lambda .0: [ flag[21] for _ in .0 ])(range(flag[21]))) + sum((lambda .0: [ flag[6] for _ in .0 ])(range(flag[6]))) + sum((lambda .0: [ flag[18] for _ in .0 ])(range(flag[18]))) - sum((lambda .0: [ flag[18] for _ in .0 ])(range(178)))) + 297412 == 0:\n    print('yes')\n    return None\n\"\"\"\n\n#正则表达式中，]不需要转义啊。\npattern = r\"sum\\(\\(lambda .0: \\[ flag\\[(\\d+)] for _ in .0 ]\\)\\(range\\((\\d+)\\)\\)\\)\"\n\nmatches = re.findall(pattern, str)\n\nflag = [0] * 32\n\nfor match in matches:\n    flag[int(match[0])] = int(match[1])//2\n\nfor i in range(32):\n    print(chr(flag[i]), end='')\n```\n\n\n\n\n\n\n\n# 舔狗四部曲--相逢已是上上签\n\n​\t又是8086+DOS系列，IDA直接打开还不行。算了，乱七八糟的，直接看WP。\n\n​\t有标志位被修改了，如下图，正常情况下，上面的红框应该是下面的PE头的地址，这里被改了，要改回0x100，也就是0001。之后就能IDA正常识别了。\n\n![image-20250601115228908](/pictures/XYCTF2024/image-20250601115228908.png)\n\n```python\n#z3破解key\nfrom z3 import *\n\n# 定义变量，假设是整数\nbyte = [Int(f'byte_{i}') for i in range(6)]\n\ns = Solver()\n\n# 变量范围假设：比如字节可打印字符范围(32~126)，或者0~255\nfor b in byte:\n    s.add(b >= 32, b <= 126)\n\n# 添加方程\ns.add(\n    532 * byte[5] + 829 * byte[4] + 258 * byte[3] + 811 * byte[2] + 997 * byte[1] + 593 * byte[0] == 292512,\n    576 * byte[5] + 695 * byte[4] + 602 * byte[3] + 328 * byte[2] + 686 * byte[1] + 605 * byte[0] == 254496,\n    580 * byte[5] + 448 * byte[4] + 756 * byte[3] + 449 * byte[2] + 512 * byte[1] + 373 * byte[0] == 222479,\n    597 * byte[5] + 855 * byte[4] + 971 * byte[3] + 422 * byte[2] + 635 * byte[1] + 560 * byte[0] == 295184,\n    524 * byte[5] + 324 * byte[4] + 925 * byte[3] + 388 * byte[2] + 507 * byte[1] + 717 * byte[0] == 251887,\n    414 * byte[5] + 495 * byte[4] + 518 * byte[3] + 884 * byte[2] + 368 * byte[1] + 312 * byte[0] == 211260\n)\n\nif s.check() == sat:\n    model = s.model()\n    solution = [model[b].as_long() for b in byte]\n    for i in range(6):\n        print(chr(solution[i]), end='')\nelse:\n    print(\"No solution found.\")\n#XYCTF!\n```\n\n​\t这个币题有怪东西，脚本绝对有怪东西。今天就让我碰上了，真tm晦气。。\n\n​\t下面是我照着WP改了一点能跑的脚本。\n\n```c\n//xxtea解密\n#include<stdio.h>\n#include<stdlib.h>\n#include<stdint.h>\n#define DELTA 0x9E3779B9\n#define MX (((z ^ key[e ^ (p & 5)]) + (y ^ sum)) ^ (((z << 4) ^(y >> 3)) + ((y << 2) ^ (z >> 5))))\n\nvoid dexxtea(uint32_t *v, int n, char *key)\n{\n    uint32_t e = 0;\n    uint32_t rounds = 6 + 52 / n;\n    uint32_t sum = DELTA * rounds;\n    uint32_t y = 0, z = 0;\n    uint32_t p;\n    do{\n        e = (sum >> 2) & 5;\n        for(p=n-1; p>0; p--)\n        {\n            y = v[(p+1)%n];     //保存加密位的后一位\n            z = v[(p-1)%n];         //保存加密位的前一位\n            v[p] -= MX;\n        }\n        y = v[(p+1)%n];     //保存加密位的后一位\n        z = v[(p-1)%n];         //保存加密位的前一位\n        v[p] -= MX;\n        sum -= DELTA;\n    }while(--rounds);\n}\n\nint main()\n{\n    uint32_t enc[8] = {0x66697271,0x896E2285,0xC5188C1B,0x72BCFD03,0x538011CA,0x4DA146AC,0x86630D6B,0xF89797F0};\n    char *key = \"XYCTF!\";\n    dexxtea(enc, 8, key);\n    char *flag = (char*)enc;\n    for(int i=0;i < 32;i++)\n    {\n        printf(\"%c\",flag[i]);\n    }\n    return 0;\n}\n```\n\n​\t第一个问题，看这个循环体的内容，上面能跑，下面就是错的。差别就在于p=0的情况，是放在循环体内部，还是放在循环体外部了。结果详细信息分析，我得到一种可能解释：因为p是无符号32位整数，永远大于等于0，所以下面的情况应该是无限循环，在编译器优化的情况后，这个地方应该被识别出是无限循环，直接中断程序了，在for循环里面插入printf根本不输出啊。\n\n```c\ndo{\n        e = (sum >> 2) & 5;\n        for(p=n-1; p>0; p--)\n        {\n            y = v[(p+1)%n];     //保存加密位的后一位\n            z = v[(p-1)%n];         //保存加密位的前一位\n            v[p] -= MX;\n        }\n        y = v[(p+1)%n];     //保存加密位的后一位\n        z = v[(p-1)%n];         //保存加密位的前一位\n        v[p] -= MX;\n        sum -= DELTA;\n}while(--rounds);\n    \n    \ndo{\n        e = (sum >> 2) & 5;\n        for(p=n-1; p>=0; p--)\n        {\n            y = v[(p+1)%n];     //保存加密位的后一位\n            z = v[(p-1)%n];         //保存加密位的前一位\n            v[p] -= MX;\n        }\n        sum -= DELTA;\n}while(--rounds);\n```\n\n​\t第二个问题来了，按照第一个能跑的版本，我将p的类型改为int型，为什么就又不行了？\n\n​\t第二个问题也有了答案：看到这个参数z的代码`z = v[(p-1)%n];` 。无论p是有符号32位整数，还是无符号，`p-1（p=0）`在机器内的表示都是`FFFFFFFF`，通过格式化字符`%x`输出都是这样的。而分别通过`%d %u`输出，却是`-1`和`4294967295`。再看，`(p-1)%8`在通过`%08x`输出的时候却分别是`ffffffff` `00000007`，也就是说在有符号数中`-1%8=-1`。无符号数`FFFFFFFF`（`4294967295`）模8是等于7的。所以会导致z的取值时的索引值不一样。\n\n​\t\n\n​\t综上，总结出无符号数当索引值，要特殊处理等于0的情况；有符号数的模运算中，负数模正数还是负数。\n\n\n\n\n\n\n\n# Trustme（APK）\n\n​\t又是apk，放一边。还是学习WP。\n\n​\t这个倒是挺正常，可以使用JADX打开分析。MainActivity中有假的判断，对其进行解密出来得到用户名。\n\n```python\ndef rc4(data: bytes, key: bytes) -> bytes:\n    S = list(range(256))\n    j = 0\n    out = []\n\n    # KSA: Key Scheduling Algorithm\n    for i in range(256):\n        j = (j + S[i] + key[i % len(key)]) % 256\n        S[i], S[j] = S[j], S[i]\n\n    # PRGA: Pseudo-Random Generation Algorithm\n    i = j = 0\n    for char in data:\n        i = (i + 1) % 256\n        j = (j + S[i]) % 256\n        S[i], S[j] = S[j], S[i]\n        out.append(char ^ S[(S[i] + S[j]) % 256])\n    return bytes(out)\n\n# 输入密文（十六进制）和密钥\ncipher_hex = \"5a3c46e0228b444decc7651c8a7ca93ba4cb35a46f7eb589bef4\"\ncipher_bytes = bytes.fromhex(cipher_hex)\nkey = b\"XYCTF\"\n\n# 解密\nplaintext_bytes = rc4(cipher_bytes, key)\nprint(\"原文密码是:\", plaintext_bytes.decode())\n#原文密码是: The Real username is admin\n```\n\n​\t但是没有其他信息了，我们翻看到Proxy类，看到其中创建了一个新的shell.apk，是对class.dex中的数据进行提取操作的。\n\n```python\nimport struct\n\ndef decrypt(data: bytes) -> bytes:\n    # 对每个字节异或 0xFF\n    return bytes(b ^ 0xFF for b in data)\n\ndef split_payload_from_dex(bArr: bytes, apkFileName: str):\n    # 取 dex 末尾4个字节，读取payload长度（int，4字节）\n    readInt = struct.unpack(\">I\", bArr[-4:])[0]  # 大端，跟Java默认DataInputStream.readInt一样\n    print(f\"Payload length: {readInt}\")\n\n    # 取出payload数据\n    payload_encrypted = bArr[-4 - readInt : -4]\n\n    # 解密\n    payload_decrypted = decrypt(payload_encrypted)\n\n    # 写入解密后的 APK 文件\n    with open(apkFileName, \"wb\") as f:\n        f.write(payload_decrypted)\n    print(f\"Decrypted payload saved to {apkFileName}\")\n\n# 示例调用\nif __name__ == \"__main__\":\n    # 假设 dex.bin 是你整个 dex 文件\n    with open(r\"F:\\StudyFiles\\CTF\\Review_CTF\\XYCTF2024\\RE\\Trustme\\classes.dex\", \"rb\") as f:\n        dex_bytes = f.read()\n\n    split_payload_from_dex(dex_bytes, \"shell.apk\")\n```\n\n​\t得到shell.apk后，看到了密文比对的逻辑，就是使用sql语句验证用户名和密码是否正确。但是，apk解压后得到的/assets/mydb.db文件是无法正常读取的，仔细读源码，看到MoveSQLiteUtil类中有创建db文件的方法，是对mydb.db文件异或0xff解密得到的。\n\n```python\nwith open(r\"F:\\StudyFiles\\CTF\\Review_CTF\\XYCTF2024\\RE\\Trustme\\assets\\mydb.db\", \"rb\") as f:\n    data = f.read()\n    new_data = bytearray(data)\n    for i in range(len(data)):\n        new_data[i] = data[i] ^ 0xff\n\n    with open(r\"F:\\StudyFiles\\CTF\\Review_CTF\\XYCTF2024\\RE\\Trustme\\assets\\mydb_decrypted.db\", \"wb\") as f2:\n        f2.write(new_data)\n```\n\n​\t打开解密文件，就看到了flag。\n\n​\t这题还有SQL注入漏洞，密码为`' or 1=1 --`就能得到flag。\n\n\n\n\n\n\n\n# \t馒头\n\n​\t无壳，IDA打开，代码很清晰，考察的是`哈夫曼树`数据结构，好久之前学的数据结构了，现在都忘了，重新温习一下。看不懂啊，真的难。这题就认真分析一遍，完整写思路，当作是学习新知识了。\n\n​\t通过学习，知道了IDA中通过`add type`自定义结构体，然后通过`Y`键修改反编译的函数参数类型为自定义的结构体指针，这样IDA就能自动识别了。\n\n​\t先看结构初始化函数，这里哈夫曼树是通过`数组`保存的啊，而a1就是这个指向这个数组的指针，这个数组中的每个元素都是一个结构体，这里并不是指针数组，而是结构体数组。`(*a1)[i]`就是第i个节点，而其index就是其在原字符串中的下标。\n\n![image-20250603135741772](/pictures/XYCTF2024/image-20250603135741772.png)\n\n​\t看到create函数是构建哈夫曼树的。\n\n![image-20250603140500857](/pictures/XYCTF2024/image-20250603140500857.png)\n\n​\t看到check函数，这里很巧妙的对左叶子节点进行了值和下标的比对，而对右叶子节点只进行了下标的比对，这样就不必把所有flag的字符值全保存在变量中，显的太简单。同时也可以标注字符在flag中的位置。\n\n![image-20250603140650890](/pictures/XYCTF2024/image-20250603140650890.png)\n\n\n\n​\t理清逻辑后，我开始是手动解密，就像是下面这样，在手动操作的过程中我找到了规律。\n\n​\t就是可打印字符的数字在32到126之间，那么从1到24的数字一定是表示下标的，并且由于哈夫曼树是满二叉树，即除叶子节点外的其他节点都有两个孩子节点。\n\n​\t我举个例子，假设A有两个子节点，且都是叶子节点，左右孩子分别为B、C。那么扫描到A的时候，根据程序就会判断一下B的权值（字符值），然后递归进入到B节点，这时候又会比较一次下标值，然后从叶子节点B返回，接着到右叶子节点C，继续比较下标，然后返回到A的兄弟节点去比对。\n\n​\t所以我们就可以根据循环数组的值，检测到下标，就可以利用前几位的权值计算出原字符串中该下标对于的ASCII码值是多少。\n\n```python\ndata = [2270, 917, 446, 217, 106, 51, 20, 15, 17, 229, 114, 16, 11, 471, 233, 116, 14, 13, 238, 118, 12, 7, 1353, 557, 248, 123, 6, 24, 309, 137, 67, 3, 5, 172, 84, 4, 1, 796, 383, 186, 89, 2, 8, 197, 97, 48, 23, 10, 21, 413, 203, 101, 22, 9, 210, 104, 19, 18]\n\nflag = [0] * 25\nflag[20] = 51\nflag[15] = 106 -51\nflag[17] = 217 - 106\nflag[16] = 114\nflag[11] = 229 - 114\nflag[14] = 116\nflag[13] = 233 - 116\nflag[12] = 118\nflag[7] = 238 - 118\nflag[6] = 123\nflag[24] = 248 - 123\nflag[3] = 67\nflag[5] = 137 - 67\nflag[4] = 84\nflag[1] = 172 - 84\nflag[2] = 89\nflag[8] = 186 - 89\nflag[23] = 48\nflag[10] = 97 - 48\nflag[21] = 197 - 97\nflag[22] = 101\nflag[9] = 203 - 101\nflag[19] = 104\nflag[18] = 210 - 104\n\nfor i in range(1,25):\n    print(chr(flag[i]), end='')\n```\n\n​\t下面是自动处理的脚本。\n\n```python\ndata = [2270, 917, 446, 217, 106, 51, 20, 15, 17, 229, 114, 16, 11, 471, 233, 116, 14, 13, 238, 118, 12, 7, 1353, 557, 248, 123, 6, 24, 309, 137, 67, 3, 5, 172, 84, 4, 1, 796, 383, 186, 89, 2, 8, 197, 97, 48, 23, 10, 21, 413, 203, 101, 22, 9, 210, 104, 19, 18]\nflag = [0] * 25\ni = 0\nwhile i < len(data):\n    if data[i] > 0 and data[i] < 25:\n        n = 1\n        tmp = i\n        while i < len(data) and data[i] > 0 and data[i] < 25:\n            if n == 1:\n                flag[data[i]] = data[tmp-n]\n            else:\n                flag[data[i]] = data[tmp-n] - data[tmp-n+1]\n            i += 1\n            n += 1\n    else:\n        i += 1\n\nfor i in range(1,25):\n    print(chr(flag[i]), end='')\n```\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n# What's this\n\n​\t新东西，第一次碰见，文件头是`1B 4C 75 61 51`。节约时间，学习WP。\n\n​\tChatgpt的解释是：`1B 4C 75 61 51` 是一个 **Lua字节码文件（编译后的Lua文件）的文件头**，即不是普通的 `.lua` 源代码文件，而是已经编译成Lua虚拟机可执行的二进制文件。所以我们要反编译，看源代码。\n\n​\tWP中给出了在线工具，我们上网站反编译好了。也是有幸接触到了一下LUA脚本，这是游戏开发非常流行的语言。\n\n```python\nimport base64\nflag = \"==AeuFEcwxGPuJ0PBNzbC16ctFnPB5DPzI0bwx6bu9GQ2F1XOR1U\"\nflag = flag.replace(\"6\", \"W\")\nflag = flag.replace(\"4\", \"H\")\nflag = flag.replace(\"3\", \"g\")\nflag = flag[::-1]\nflag = base64.b64decode(flag).decode()\nfor i in range(len(flag)):\n    tmp = ord(flag[i]) - 3\n    tmp = (tmp ^ 8) % 256\n    print(chr(tmp), end=\"\")\n```\n\n\n\n\n\n# ez_rand\n\n​\t又是垃圾题，思路很简单，爆破就行了，对应好参数类型。\n\n​\tsb的WP中，直接rand()%255，无语了。tm的，我又一直爆破不出来，明明是照着变量类型抄的。连算式都是照着抄的。\n\n​\t麻痹的，改了一下异或值的计算就好了，还忘了之前错的是什么样子的了，现在怎么改都是对的。真的是玄学，错误消失了，完全找不到之前错的是什么样子的了。\n\n​\t无语逆天了，再也不想碰这个煞笔C语言了。\n\n![image-20250601171908123](/pictures/XYCTF2024/image-20250601171908123.png)\n\n```c++\n//别人的脚本\n#include<iostream>\n#include<cstring>\n#include<algorithm>\n#include<cstdio>\n#include<cstdlib>\n#include<ctime>\nusing namespace std;\nunsigned char cipher[50] = {0x5D, 0x0C, 0x6C, 0xEA, 0x46, 0x19, 0xFC, 0x34,0xB2, 0x62, 0x23, 0x07, 0x62, 0x22, 0x6E, 0xFB, 0xB4, 0xE8, 0xF2, 0xA9, 0x91,0x12, 0x21, 0x86, 0xDB, 0x8E, 0xE9, 0x43, 0x4D};\nint v7;\nbool cmp(char s[])\n{\n\tif(strstr(s,\"XYCTF\")||strstr(s,\"flag\"))\n\t{\n\t\treturn true;\n\t}\n\treturn false;\n}\nchar ans[50];\nint _round=-5;\nsigned main()\n{\n\tfor(unsigned int v4=0;v4<65536;v4++)\n\t{\n\t\tsrand(v4);\n\t\tfor(int i=0;i<29;i++)\n\t\t{\n\t\t\tv7=rand();\n\t\t\tunsigned long long temp=((2155905153*1LL*v7)>>32);\n\t\t\tunsigned char num=v7+(int)((temp&0x80000000)!=0)+((int)temp>>7);\n\t\t\tans[i]=num^cipher[i];\n\t\t}\n\t\tif(cmp(ans))\n\t\t{\n\t\t\t_round=v4;\n\t\t\tbreak;\n\t\t}\n\t}\n\tprintf(\"%s %d\",ans,_round);\n\t//XYCTF{R@nd_1s_S0_S0_S0_easy!} 21308\n}\n```\n\n\n\n\n\n# 舔狗四部曲--记忆的时光机\n\n​\tok，高级的反编译，类似花指令一样的反编译方式。方法为先把要跳转的地址保存到寄存器上，然后通过寄存器跳转；或者搞个`endbr64`指令，影响反编译。\n\n​\t直接学习WP。说是可以通过跳转表，修复反编译，但是没演示具体操作，对小白太不友好了。其他人也都是看汇编或者动调的，那就干吧，动调看看。\n\n​\t首先一个cmp，长度检验，0x30，48位。然后每一位加密后和密文比对，48个字符全部相同就是成功。\n\n​\tenc函数，首先有个xor变化值（i+6，i从0开始的），再xor固定值0x66，再减6，然后xor密文的对应位。\n\n```python\nenc = [105, 88, 97, 99, 103, 76, 77, 50, 152, 32, 77, 81, 123, 37, 117, 81, 163, 88, 96, 114, 66, 98, 103, 102, 55, 108, 48, 70, 102, 79, 93, 3, 93, 164, 102, 1, 67, 104, 125, 124, 85, 79, 122, 63, 108, 18, 33, 9]\nkey = \"i_have_get_shell_but_where_is_you_my_dear_baby!!\"\n\nfor i in range(len(enc)):\n    tmp = (enc[i] ^ ord(key[i])) % 256\n    tmp = (tmp + 6) % 256\n    tmp = (tmp ^ 0x66) % 256\n    tmp = (tmp ^ (i+6)) % 256\n    print(chr(tmp), end='')\n```\n\n​\t这题会动调其实很简单，只是反编译做做样子，有点吓人罢了。\n\n\n\n\n\n# ez_cube\n\n​\tIDA打开，真是个做魔方的题，还得有点空间想象力才行。初始状态如下。\n\n​\tWP给出的在线网站，没办法做到限制旋转，就无法按照题目中的方式解出。可以使用python写一个求解脚本，只使用四种目标旋转，限制步数，BFS就是很可行的。\n\n​\t但是我不想在这样一个非专业逆向的题目耗这么多时间，所以直接过了。附上别人的脚本。\n\n![image-20250601205219843](/pictures/XYCTF2024/image-20250601205219843.png)\n\n```python\nfrom itertools import *\nimport tqdm\ndef f(x):\n\tA=[\"R\"]*9\n\tB=[\"B\"]*9\n\tC=[\"G\"]*9\n\tD=[\"O\"]*9\n\tE=[\"Y\"]*9\n\tF=[\"W\"]*9\n\tB[1]='R'\n\tA[1]='G'\n\tC[1]='B'\n\tfor i in x:\n\t\tif i=='R':\n\t\tv0 = A[2]\n\t\tv1 = A[5]\n\t\tv2 = A[8]\n\t\tA[2] = F[2]\n\t\tA[5] = F[5]\n\t\tA[8] = F[8]\n\t\tF[2] = D[6]\n\t\tF[5] = D[3]\n\t\tF[8] = D[0]\n\t\tD[0] = E[8]\n\t\tD[3] = E[5]\n\t\tD[6] = E[2]\n\t\tE[2] = v0\n\t\tE[5] = v1\n\t\tE[8] = v2\n\t\tv3 = C[1]\n\t\tC[1] = C[3]\n\t\tC[3] = C[7]\n\t\tC[7] = C[5]\n\t\tC[5] = v3\n\t\tv4 = C[0]\n\t\tC[0] = C[6]\n\t\tC[6] = C[8]\n\t\tC[8] = C[2]\n\t\tC[2] = v4\n\tif i=='U':\n\t\tv0 = A[0]\n\t\tv1 = A[1]\n\t\tv2 = A[2]\n\t\tA[0] = C[0]\n\t\tA[1] = C[1]\n\t\tA[2] = C[2]\n\t\tC[0] = D[0]\n\t\tC[1] = D[1]\n\t\tC[2] = D[2]\n\t\tD[0] = B[0]\n\t\tD[1] = B[1]\n\t\tD[2] = B[2]\n\t\tB[0] = v0\n\t\tB[1] = v1\n\t\tB[2] = v2\n\t\tv3 = E[1]\n\t\tE[1] = E[3]\n\t\tE[3] = E[7]\n\t\tE[7] = E[5]\n\t\tE[5] = v3\n\t\tv4 = E[0]\n\t\tE[0] = E[6]\n\t\tE[6] = E[8]\n\t\tE[8] = E[2]\n\t\tE[2] = v4\n\tif i=='r':\n\t\tv0 = A[2]\n\t\tv1 = A[5]\n\t\tv2 = A[8]\n\t\tA[2] = E[2]\n\t\tA[5] = E[5]\n\t\tA[8] = E[8]\n\t\tE[2] = D[6]\n\t\tE[5] = D[3]\n\t\tE[8] = D[0]\n\t\tD[0] = F[8]\n\t\tD[3] = F[5]\n\t\tD[6] = F[2]\n\t\tF[2] = v0\n\t\tF[5] = v1\n\t\tF[8] = v2\n\t\tv3 = C[1]\n\t\tC[1] = C[5]\n\t\tC[5] = C[7]\n\t\tC[7] = C[3]\n\t\tC[3] = v3\n\t\tv4 = C[0]\n\t\tC[0] = C[2]\n\t\tC[2] = C[8]\n\t\tC[8] = C[6]\n\t\tC[6] = v4\n\tif i=='u':\n\t\tv0 = A[0]\n\t\tv1 = A[1]\n\t\tv2 = A[2]\n\t\tA[0] = B[0]\n\t\tA[1] = B[1]\n\t\tA[2] = B[2]\n\t\tB[0] = D[0]\n\t\tB[1] = D[1]\n\t\tB[2] = D[2]\n\t\tD[0] = C[0]\n\t\tD[1] = C[1]\n\t\tD[2] = C[2]\n\t\tC[0] = v0\n\t\tC[1] = v1\n\t\tC[2] = v2\n\t\tv3 = E[1]\n\t\tE[1] = E[5]\n\t\tE[5] = E[7]\n\t\tE[7] = E[3]\n\t\tE[3] = v3\n\t\tv4 = E[0]\n\t\tE[0] = E[2]\n\t\tE[2] = E[8]\n\t\tE[8] = E[6]\n\t\tE[6] = v4\n\tif A==[\"R\"]*9 and B==[\"B\"]*9 and C==[\"G\"]*9 and D==[\"O\"]*9 and E==[\"Y\"]*9 and F==[\"W\"]*9:\n\t\treturn 1\n\telse:\n\t\treturn 0\n\n    \nflag=[]\nfor j in range(13):\n\tfor i in tqdm.tqdm(list(product('RUru',repeat=j))):\n\t\tx=''.join(i)\n\t\tif f(x):\n\t\t\tflag.append(x)\n[print(\"flag{%s}\"%x) for x in flag]\n```\n\n\n\n\n\n# 今夕是何年\n\n​\tIDA打开，哇，都反编译不了，第一次碰见这种，查壳还没有壳，又是RUST语言写的。\n\n​\t学习WP，原来这是LoongArch架构的ELF二进制文件，我们需要一个LoongArch架构的环境来运行这个程序。\n\n​\t按照WP的命令在kali上面下载好了qemu-user，命令为`sudo apt install qemu-user`。然后就可以直接运行main程序了。为什么这么便捷啊？\n\n> 背后的机制：`binfmt_misc`\n>\n> - Linux 有个内核功能叫做 **`binfmt_misc`**，它能让系统识别不同格式的可执行文件。\n> - 当你运行一个非本机架构的可执行文件时，内核通过 `binfmt_misc` 找到对应的解释器（比如 `qemu-arm`），自动调用它来运行程序。\n> - 这样你就感觉“直接运行，不用额外命令”，其实是系统帮你自动转发了。\n\n​\t幸好有教程，不然我去网上找又得花大把时间，错误率还高，各种环境问题。\n\n\n\n\n\n\n\n\n\n# Findme\n\n​\t给了三个二进制文件，不知道是什么东西，DIE也查不出来。新东西，还是直接看WP。6，原来是有隐藏的，我还以为这几个文件是一样的东西，结果一看，文件`Doraemon1` `Doraemon2`确实比较迷，但是`Doraemon4`就是exe文件文件啊， 文件头就能看出来，还去掉了后缀名。\n\n​\t先看exe程序，先是一个RC4类的KSA，初始化S盒并用密钥打乱，密钥为：`Find_Doraemon`。\n\n![image-20250602111610021](/pictures/XYCTF2024/image-20250602111610021.png)\n\n​\t然后是PRGA，伪随机数流加密。对Doraemon3文件读取字符，异或加密后写入Doraemon1文件，并且跟着若干个随机数。\n\n![image-20250602111920780](/pictures/XYCTF2024/image-20250602111920780.png)\n\n​\t所以我们对Doraemon1文件进行读取逆向处理就行，先造出S盒，然后再次异或即可，并且使用S盒中的数进行伪随机生成，去掉中间的若干字符后，到达下一个加密字符，直至文件读取完。\n\n​\t我现在写代码的能力有点差，经常有遗忘的点，改起来花很多时间。还得练。\n\n```c\n#include <stdio.h>  \n#include <stdlib.h>\n#include <stdint.h>\n\nFILE *fp = NULL;\n\nvoid KSA(uint8_t *S, uint8_t *K)\n{\n    uint32_t i;\n    int j = 0;\n    for( i=0; i<512;i++)\n    {\n        S[i] = -(char)i;\n    }\n    i = 0;\n    while(i<512)\n    {\n        j = (K[i%13] + S[i] + j) % 512;\n        uint8_t temp = S[i];\n        S[i] = S[j];\n        S[j] = temp;\n        i++;\n    }\n}\n\nvoid PRGA(uint8_t *S)\n{\n    int i = 0, j = 0, v8=0 , v9 = 0 ;\n    uint8_t temp, k;\n    uint8_t b;\n    fp = fopen(\"F:\\\\StudyFiles\\\\CTF\\\\Review_CTF\\\\XYCTF2024\\\\RE\\\\Findme\\\\Doraemon1\", \"rb\");\n    FILE *stream = fopen(\"./Doraemon3\",\"wb\");\n    if (fp == NULL) {\n        perror(\"Error opening file\");\n        exit(1);\n    }\n    if(stream == NULL) {\n        perror(\"Error opening file\");\n        exit(1);\n    }\n    while(!feof(fp))\n    {\n        i = (i + 1) % 512;\n        j = (S[i] + j) % 512;\n        temp = S[i];\n        S[i] = S[j];\n        S[j] = temp;\n        k = S[(uint8_t)((S[i] + S[j]) % 512)];\n        b = fgetc(fp);\n        fputc(b^k, stream);\n        srand(S[v8 %512]);\n        v9 = rand() % 4;\n        for(int t=0; t<v9; t++)\n        {\n            rand();\n            fgetc(fp);\n        }\n        v8++;\n    }\n}\n\nint main()\n{\n    char *key = \"Find_Doraemon\";\n    uint8_t S[512] = {0};\n\n    KSA(S, (uint8_t *)key);\n    PRGA(S);\n    return 0;\n}\n```\n\n​\t得到3文件后，查看源码，是对2文件进行解密，但是要输入密钥。哈哈，完啦，没有直接的提示，又是脑洞，我没想到。看了WP才知道是`Doraemon`，看来我做题太多了，都有点迟钝了。\n\n​\t得到的解密文件是一个gif图片，打开就得到了flag。\n\n\n\n\n\n\n\n# 舔狗四部曲--我的白月光\n\n​\t这个我真找不到了，动调和时光机一样的逻辑，一样的flag。但肯定不是这样的，但也没有debug检测，直接运行程序也是那样子的啊。有点迷了。\n\n​\t看WP吧，草，原来是平台附件错了......。新的附件是chall.exe。\n\n​\t运行程序得到第一段flag：`flag{L0v3_`。\n\n​\t这题C++写的，反编译有点不好看，主要是难以找到入手点，还是学习WP吧，增长经验。\n\n​\t通过在提示信息前下断点，捕获到断点前面一直在操作的内存数据，提取出来得到这样的字符串，就有了第二段flag。\n\n```python\ndata = [112, 108, 101, 97, 115, 101, 32, 100, 111, 32, 110, 111, 116, 32, 116, 114, 121, 32, 116, 111, 32, 102, 105, 110, 100, 32, 104, 101, 114, 32, 115, 104, 101, 32, 100, 111, 32, 110, 111, 116, 32, 98, 101, 108, 111, 110, 103, 32, 116, 111, 32, 97, 103, 111, 32, 109, 101, 109, 111, 114, 105, 101, 115, 32, 105, 32, 119, 105, 108, 108, 32, 103, 105, 118, 101, 32, 121, 111, 117, 32, 115, 111, 109, 101, 32, 102, 108, 97, 103, 115, 58, 105, 56, 95, 97, 95, 107, 51, 121, 95, 97, 110, 100, 32, 110, 111, 119, 32, 103, 111, 32, 98, 97, 99, 107, 32, 112, 108, 101, 97, 115, 101, 33]\n\nfor i in range(len(data)):\n    print(chr(data[i]), end='')\n```\n\n`please do not try to find her she do not belong to ago memories i will give you some flags:i8_a_k3y_and now go back please!`\n\n​\t程序这个地方原本是Hook掉了Message函数，导致我们一直在循环看弹窗。要把这里nop掉。\n\n![image-20250602165959876](/pictures/XYCTF2024/image-20250602165959876.png)\n\n![image-20250602170024249](/pictures/XYCTF2024/image-20250602170024249.png)\n\n​\t然后调试的时候，这里v24很大，导致我们循环半天，要手动改标志位跳出。\n\n![image-20250602170144586](/pictures/XYCTF2024/image-20250602170144586.png)\n\n​\t再看下面1290函数是加密部分，加密数据是程序写好的（当然是错的），所以没有用户输入的地方。下面就是字符串比对，然后弹出提示信息。所以可以猜出这个就是密文，我们要对加密算法逆向。![image-20250602170236930](/pictures/XYCTF2024/image-20250602170236930.png)\n\n​\t加密函数里面有一个自定义的base64（反编译根本看不出来啊，只能靠看汇编和动态调试看），其算法是对于三位一组的ABC，其密文分别是base[A&0x3f]、base[((B&0xf)<<2)|(A>>6)&3]、base[(B>>4)&0xf | (C&3)<<4]、base[(C>>2)0x3f]。\n\n> ​\t相当于对原字符ABC，其都有八位。加密时是：\n>\n> 第一位对应：A[6] A[5] A[4] A[3] A[2] A[1]\n>\n> 第二位对应：B[4] B[3] B[2] B[1] A[8] A[7]\n>\n> 第三位对应：C[2] C[1] B[8] B[7] B[6] B[5]\n>\n> 第四位对应：C[8] C[7] C[6] C[5] C[4] C[3]\n\n```python\ndef decode_custom_base64(data: str, base: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\") -> bytes:\n    \"\"\"\n    自定义 Base64 解码函数，返回解码后的字节串。\n\n    规则对应：\n    - 输入4个字符一组，映射到3个字节ABC\n    - 解码算法根据你给出的对应关系逆向实现\n    \"\"\"\n    decoded_bytes = bytearray()\n    base_index = {ch: i for i, ch in enumerate(base)}\n\n    length = len(data)\n    i = 0\n    while i < length:\n        # 取4个字符，填充为'='后面补0\n        chunk = data[i:i+4]\n        if len(chunk) < 4:\n            chunk += '=' * (4 - len(chunk))\n\n        vals = []\n        for ch in chunk:\n            if ch == '=':\n                vals.append(0)\n            else:\n                vals.append(base_index[ch])\n\n        # 根据编码规则，逆推 ABC 三字节：\n        # 设编码字符对应的6位数分别是v0,v1,v2,v3\n        v0, v1, v2, v3 = vals\n\n        # 解码公式（反推你给出的编码方式）：\n        A = (v0 & 0x3F) | ((v1 & 0x03) << 6)\n        B = ((v1 >> 2) & 0x0F) | ((v2 & 0x0F) << 4)\n        C = ((v2 >> 4) & 0x03) | ((v3 & 0x3F) << 2)\n\n        decoded_bytes.append(A)\n        if chunk[2] != '=':\n            decoded_bytes.append(B)\n        if chunk[3] != '=':\n            decoded_bytes.append(C)\n\n        i += 4\n\n    return bytes(decoded_bytes)\n\n\ndef decode_custom_base64_to_str(data: str, base: str = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\", encoding='utf-8') -> str:\n    \"\"\"\n    调用自定义解码函数，将结果转换为字符串。\n    \"\"\"\n    decoded_bytes = decode_custom_base64(data, base)\n    return decoded_bytes.decode(encoding, errors='ignore')\n\n\n# 示例\nif __name__ == \"__main__\":\n    custom_base = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\"\n    encoded = \"1YmNkZTN2QmNmdjM3kTNmZTZ2UzN2YTN3ITNmZzN2YWNmZDN2YmNlZTN1YmN2YTO2UmNxYzY2M2N5UjZ3QjN4YTM2UmNidTO2Y2N1UjZ3gjN5YTM2Y2N3YTM2UmN3cDN2YmNlZzN3gzN1YTN3QG=\"  \n    decoded = decode_custom_base64_to_str(encoded, custom_base)\n    for i in range(0,len(decoded), 2):\n        print(chr(int(decoded[i:i+2], 16)), end='')\n        \n   #_memory_never_go_done_finally_thankyou_xiaowangtongxue}\n```\n\n合在一起就是flag{L0v3_i8_a_k3y_and_memory_never_go_done_finally_thankyou_xiaowangtongxue}\n\n\n\n​\t最后动调看一看故事最后的结局，看一看作者最后的感悟。\n\n![image-20250602170833655](/pictures/XYCTF2024/image-20250602170833655.png)\n","tags":["复现WP","Reverse"],"categories":["CTF"]},{"title":"初识Unicorn","url":"/2025/06/29/XYCTF2025/初识Unicorn/","content":"\n\n\n# Unicorn框架\n\n## 前言\n\n​\t环境搭建教程可以看XYCTF2025中的ezVM，只有ubuntu虚拟机版本的，有python语言、C++语言和C语言版本。\n\n\n\n## 介绍\n\n​\t**unicorn**是一个跨平台、轻量级的CPU指令集仿真框架，用于模仿CPU指令执行过程，不需要真实硬件或完整操作系统支持。Unicorn 是由著名的逆向工具 QEMU 的代码衍生而来，但封装成了一个简单的库，支持多语言调用，重点在于模拟 CPU 执行而不是完整系统虚拟化。\n\n​\t支持框架。\n\n| 架构名称 | 说明                     |\n| -------- | ------------------------ |\n| x86      | 32位架构                 |\n| x86_64   | 64位架构（amd64）        |\n| ARM      | 32位 ARM 架构            |\n| ARM64    | 64位 ARM 架构（AArch64） |\n| MIPS     | 包括 MIPS32 和 MIPS64    |\n| PowerPC  | Power 架构的一部分       |\n| SPARC    | 较少使用，但支持         |\n| RISC-V   | 较新的开源架构           |\n\n​\t\n\n> ​\tUnicorn 主要包括以下模块：\n>\n> 1. **内存管理（Memory Map）**：映射程序运行所需的地址空间\n> 2. **寄存器接口**：设置或读取虚拟 CPU 的寄存器值\n> 3. **仿真器接口（Emulator）**：控制执行开始/停止/步进等\n> 4. **钩子机制（Hooks）**：用户可插入回调，拦截指令、内存、异常事件\n> 5. **错误处理与状态码**\n\n\n\n```c\n//使用流程，以C、C++为例\nuc_engine *uc;\nuc_open(UC_ARCH_X86, UC_MODE_32, &uc);\nuc_mem_map(uc, addr, size, UC_PROT_ALL);\nuc_mem_write(uc, addr, code, code_size);\nuc_reg_write(uc, UC_X86_REG_EIP, &addr);\nuc_emu_start(uc, addr, addr + code_size, 0, 0);\nuc_reg_read(uc, UC_X86_REG_EAX, &result);\nuc_close(uc);\n\n\n\nuc_open(...)         // 初始化引擎\nuc_mem_map(...)      // 分配模拟内存\nuc_mem_write(...)    // 写入指令或数据\nuc_reg_write(...)    // 设置寄存器状态\nuc_emu_start(...)    // 启动模拟执行\nuc_reg_read(...)     // 读取寄存器结果\nuc_close(...)        // 关闭引擎释放资源\n```\n\n\n\n\n\n### 主要函数\n\n​\t`uc_err uc_open(uc_arch arch, uc_mode mode, uc_engine **uc);`\n\n​\t**功能**：初始化Unicorn引擎。\n\n​\t**参数**：arch——架构类型，mode——模式，如32位、64位，uc——输出参数，指向新创建的引擎句柄。\n\n​\t**返回值**：错误码（`UC_ERR_OK` 表示成功）\n\n​\t\n\n​\t`uc_err uc_close(uc_engine *uc);`\n\n​\t**功能**：关闭并且释放Unicorn资源。\n\n​\t**参数**：引擎句柄。\n\n​\t**返回值**：错误码。\n\n​\t\n\n​\t`uc_err uc_mem_map(uc_engine *uc, uint64_t address, size_t size, uint32_t perms);`\n\n​\t**功能**：给模拟器分配一块内存。\n\n​\t**参数**：address——虚拟内存起始地址，size——映射大小，perms——内存权限标志，如**UC_PROT_READ | UC_PROT_WRITE | UC_PROT_EXEC**。\n\n​\t**返回值**：错误码。\n\n​\t**注解**：模拟器执行代码和读写数据的内存都需要先映射。\n\n\n\n​\t`uc_err uc_mem_write(uc_engine *uc, uint64_t address, const void *buffer, size_t size);`\n\n​\t**功能**：往模拟内存写数据（代码或变量）。\n\n​\t**参数**：addess——写入内存的起始地址，buffer——数据缓冲区，待写入数据的地址，size——数据长度。\n\n​\t**注解**：常用来写入机器码或模拟数据。\n\n\n\n​\t`uc_err uc_mem_read(uc_engine *uc, uint64_t address, void *buffer, size_t size);`\n\n​\t**功能**：从模拟内存读取数据。\n\n​\t**参数**：同 uc_mem_write，但 buffer 用来存放读出的数据\n\n​\t**注解**：执行后读取内存中状态，或者获得计算结果。\n\n\n\n​\t`uc_err uc_reg_write(uc_engine *uc, int regid, const void *value);`\n\n​\t**功能**：设置模拟 CPU 寄存器的值。\n\n​\t**参数**：regid——寄存器 ID，如 `UC_X86_REG_EAX`，value——指向包含寄存器值的变量的指针（传待传数据的地址）。\n\n​\t**注解**：启动执行前设置寄存器状态，如程序计数器（PC）、堆栈指针（SP）等。\n\n\n\n​\t`uc_err uc_reg_read(uc_engine *uc, int regid, void *value);`\n\n​\t**功能**：读取模拟 CPU 寄存器的值。\n\n​\t**参数**：类似 `uc_reg_write`，将寄存器值写入 `value` 指向的变量。\n\n​\t**注解**：执行完毕后读取寄存器状态，查看结果或下一步执行地址。\n\n\n\n​\t`uc_err uc_emu_start(uc_engine *uc, uint64_t begin, uint64_t until, uint64_t timeout, uint64_t count);`\n\n​\t**功能**：启动仿真执行，从 `begin` 地址开始执行，直到 `until` 停止\n\n​\t**参数**：begin——代码入口地址。until——结束地址（可设置为0表示无限执行直到出错）。timeout——超时时间（微秒），0 表示不限制。count——最大执行指令数，0 表示不限制。\n\n​\t**注解**：这是执行指令的核心函数。\n\n\n\n\n\n​\tHook 注册函数**uc_hook_add**：添加钩子，拦截指令执行、内存读写、异常等事件。\n\n​\t`hook_code_callback` 是用户自定义函数，会在指定范围内每条指令执行时调用。\n\n```c\nuc_hook trace;\nuc_hook_add(uc, &trace, UC_HOOK_CODE, hook_code_callback, NULL, ADDRESS, ADDRESS + size);\n```\n\n\n\n\n\n​\t错误码说明：`UC_ERR_OK` = 0，成功，其它如 `UC_ERR_WRITE_UNMAPPED`、`UC_ERR_READ_UNMAPPED` 表示内存访问错误\n\n使用 `uc_strerror(err)` 可获取错误信息字符串。\n\n\n\n## 简单使用示例\n\n```bash\n先导入环境变量，不想每次都操作可以写入家目录的.bashrc中。\nexport LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/ubuntu/desk/unicorn/build\n\n编译命令示例如下，自行修改源文件路径、include路径和build路径。（注意，最好不要用中文路径，若有报错可以检查这个点）\n\ngcc -o test /home/ubuntu/desk/test.cpp -I /home/ubuntu/unicorn/include/ -L /home/ubuntu/unicorn/build -l unicorn\n```\n\n\n\n```c\n#include <unicorn/unicorn.h>\n#include <stdio.h>\n#include <string.h>\n\n#define ADDRESS 0x1000\n#define DATA_ADDR 0x2000\t\t\t//最好定义为变量类型，uint32_t\n#define CODE_SIZE 0x1000\n#define MAX_LEN 64\n\n// x86 32位代码，实现异或加密：\n// esi 指向输入，ecx 长度\n// 遍历输入字节，对每字节异或0x55\n// 返回时修改内存中内容为加密结果\nconst uint8_t CODE[] = {\n    0x31, 0xC0,             // xor eax, eax\n    0x31, 0xD2,             // xor edx, edx\n    // loop_start:\n    0x8A, 0x06,             // mov al, byte ptr [esi]\n    0x80, 0xF0, 0x55,       // xor al, 0x55\n    0x88, 0x06,             // mov byte ptr [esi], al\n    0x46,                   // inc esi\n    0x42,                   // inc edx\n    0x49,                   // dec ecx\n    0x75, 0xF5,             // jne loop_start\n    0xC3                    // ret\n};\n\nint main() {\n    uc_engine *uc;\n    uc_err err;\n\n    char input[MAX_LEN];\n    const char encrypted_flag[] = {\n        'C' ^ 0x55, 'T' ^ 0x55, 'F' ^ 0x55, '{' ^ 0x55, 's' ^ 0x55, 'e' ^ 0x55,\n        'c' ^ 0x55, 'r' ^ 0x55, 'e' ^ 0x55, 't' ^ 0x55, '_' ^ 0x55, 'f' ^ 0x55,\n        'l' ^ 0x55, 'a' ^ 0x55, 'g' ^ 0x55, '}' ^ 0x55, '\\0'\n    };\n\n    printf(\"Enter flag: \");\n    if (!fgets(input, sizeof(input), stdin)) {\n        printf(\"Input error\\n\");\n        return -1;\n    }\n    size_t len = strlen(input);\n    if (len > 0 && input[len - 1] == '\\n') {\n        input[len - 1] = '\\0';\n        len--;\n    }\n\n    if (len != strlen(encrypted_flag)) {\n        printf(\"Flag verification failed.\\n\");\n        return 0;\n    }\n\n    // 初始化 Unicorn\n    err = uc_open(UC_ARCH_X86, UC_MODE_32, &uc);\n    if (err) {\n        printf(\"Failed to initialize Unicorn engine: %u\\n\", err);\n        return -1;\n    }\n\n    // 分配内存，写入代码和数据\n    uc_mem_map(uc, ADDRESS, CODE_SIZE, UC_PROT_ALL);\n    uc_mem_write(uc, ADDRESS, CODE, sizeof(CODE));\n\n    uc_mem_map(uc, DATA_ADDR, CODE_SIZE, UC_PROT_ALL);\n    uc_mem_write(uc, DATA_ADDR, input, len);\n\n    // 设置寄存器\n    uc_reg_write(uc, UC_X86_REG_ESI, DATA_ADDR);\t//最好传入指针&DATA_ADDR，前提是改为变量类型了\n    uc_reg_write(uc, UC_X86_REG_ECX, len);\t\t\t//最好传入&len\n\n    // 执行代码（加密）\n    err = uc_emu_start(uc, ADDRESS, ADDRESS + sizeof(CODE), 0, 0);\n    if (err) {\n        printf(\"Failed to emulate code: %u\\n\", err);\n        uc_close(uc);\n        return -1;\n    }\n\n    // 读取加密后的数据\n    char encrypted_input[MAX_LEN] = {0};\n    uc_mem_read(uc, DATA_ADDR, encrypted_input, len);\n\n    // 比对\n    if (memcmp(encrypted_input, encrypted_flag, len) == 0) {\n        printf(\"Flag verified successfully!\\n\");\n    } else {\n        printf(\"Flag verification failed.\\n\");\n    }\n\n    uc_close(uc);\n    return 0;\n}\n\n```\n\n\n\n\n\n\n\n## \t相关文章链接\n\n​\t[博客园](https://www.cnblogs.com/Here-is-SG/p/17080180.html)、[Unicorn项目](https://github.com/unicorn-engine/unicorn)\n","tags":["Reverse","技术学习"],"categories":["Reverse"]},{"title":"OpenGL初学习","url":"/2025/06/25/OpenGL学习/OpenGL学习/","content":"\n### \t环境搭建\n\n​\t学习OpenGL的核心模式，[VS2022+GLFW+GLAD环境搭建教程](https://blog.csdn.net/ssunshining/article/details/123767340)，需要注意的是文章中下载的GLFW是编译好的，我们可以跳过CMake编译的那一步，直接去找include文件和lib文件。\n\n​\t还有学习资源，[知识点学习](https://learnopengl-cn.github.io/)。\n\n\n\n------\n\n\n\n### \t基础知识（知识点学习）\n\n\n\n> ### 🔷 OpenGL 是什么？\n>\n> > OpenGL（Open Graphics Library）是一个画图的标准工具库，用来绘制图形，比如 3D 模型、场景、特效等等。\n>\n> - 它不负责创建窗口，也不能处理鼠标/键盘，只专注“画图”。\n> - 想象你是画家，OpenGL 就是你的画笔和颜料。\n>\n> ------\n>\n> ### 🔶 GLFW 是什么？\n>\n> > GLFW 是一个专门用来创建窗口、处理用户输入（键盘鼠标）和设置 OpenGL 的库。\n>\n> - 它帮你打开一个窗口、设置 OpenGL 的版本，并响应鼠标/键盘事件。\n> - 没有 GLFW（或类似的库），你连“打开画布”都做不到。\n>\n> ------\n>\n> ### 🔸 GLAD 是什么？\n>\n> > GLAD 是一个 OpenGL 的“加载器”，帮你把 OpenGL 的函数都准备好。\n>\n> - 因为 OpenGL 的函数不是自动提供的，需要手动“加载”才能使用。\n> - GLAD 就像一个工具箱打开器，确保你能正确使用所有画图工具。\n>\n> ------\n>\n> ## 🧠 记忆小口诀：\n>\n> **GLFW 开窗口，GLAD 开工具，OpenGL 开画图。**\n\n​\t\n\n\n\n\n\n\n\n> ## OpenGL 的坐标系（标准化设备坐标 NDC）\n>\n> 1. **坐标范围：**\n>     OpenGL 在渲染管线最后一步，会把顶点坐标变换到一个叫做 **标准化设备坐标**（NDC，Normalized Device Coordinates）的空间里。\n>    - X轴范围：从 **-1 到 1**（左到右）\n>    - Y轴范围：从 **-1 到 1**（下到上）\n>    - Z轴范围：从 **-1 到 1**（近到远，深度）\n> 2. **坐标轴方向：**\n>    - X轴：负方向指向左，正方向指向右\n>    - Y轴：负方向指向下，正方向指向上\n>    - Z轴：负方向指向屏幕外（观察者方向），正方向指向屏幕内\n> 3. **二维绘图时，Z轴通常为0**\n> 4. **原点在显示窗口的中心点**\n\n\n\n\n\n​\tVBO是什么？顶点缓冲对象，用来管理内存。看下面的代码，就是使用**glGenBuffers**函数生成一个带有缓冲ID的VBO对象。\n\n```java\nunsigned int VBO;\nglGenBuffers(1, &VBO);\n```\n\n> 🧠 为什么 VBO 是一个 `unsigned int` 变量？\n>\n> ——因为在 OpenGL 的内部设计中，每一个“对象”（比如缓冲区对象、纹理对象、着色器对象）都会被分配一个唯一的数字 ID，这个 ID 就是一个整数。OpenGL 并不直接返回一个“指针”或者“结构体”，它只返回一个整数值，然后你以后只要用这个数字来引用这个对象就行了。\n>\n> ❓那 VBO 本身是缓冲区吗？\n>\n> ——不是。VBO只是一个整数变量，用来存这个缓冲区的ID，真正的“缓冲区对象”是在OpenGL内部创建和管理的，你只能通过这个ID来间接使用它。\n\n\n\n\n\n​\tVAO是什么？顶点数组对象，帮你把一堆“顶点属性设置”的状态保存起来，下次想用的时候一绑上，OpenGL 就知道你的顶点数据长什么样，不用你每次都重新设置。\n\n> ## 为什么要有 VAO？\n>\n> 你画一个图形，顶点数据除了顶点坐标外，还可能有颜色、法线、纹理坐标等，每种数据都要告诉 OpenGL 怎么读取。\n>\n> 举个例子：\n>\n> - 你的顶点坐标数据在缓冲区里的起始地址是0，大小是3个float\n> - 颜色数据在缓冲区里的起始地址是12字节，大小是3个float\n>\n> 每次绘制之前，你得告诉 OpenGL 这些数据在哪，格式是什么。\n>\n> 如果没有 VAO，你每次绘图都要重复这些繁琐的设置，非常麻烦。\n>\n> ------\n>\n> ## VAO的作用就是帮你记住这些设置\n>\n> 你先创建一个 VAO，绑定它：\n>\n> ```java\n> unsigned int VAO;\n> glGenVertexArrays(1, &VAO);\n> glBindVertexArray(VAO);\n> ```\n>\n> 然后你做各种顶点属性设置：\n>\n> ```java\n> glBindBuffer(GL_ARRAY_BUFFER, VBO);\n> glVertexAttribPointer(...);\n> glEnableVertexAttribArray(...);\n> ```\n>\n> 这些设置都会被 VAO 记录。\n>\n> 以后你只要：\n>\n> ```java\n> glBindVertexArray(VAO);\n> ```\n>\n> OpenGL就自动知道所有顶点属性设置，你可以直接画图了。\n>\n> ------\n>\n> ## 简单比喻\n>\n> - **没有 VAO**：每次画画都要重新告诉画笔颜色、粗细、位置，麻烦又容易出错。\n> - **有了 VAO**：把画笔的设置存好，下次直接拿出来用，画画快又方便。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------\n\n\n\n### 示例代码讲解（注释版）\n\n```c++\n#include<glad/glad.h>\n#include<GLFW/glfw3.h>\n\n#include<iostream>\n\n//回调函数声明，当窗口大小改变就会调用\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height);\n\n\nint main()\n{\n    glfwInit();\n    //告诉GLFW我们使用OpenGL3.3 Core Profile\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n\n    GLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL);\t//创建窗口\n    \n    if (window == NULL)\t//检查窗口创建状态\n    {\n        std::cout << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\t//把OpenGL上下文设置为这个窗口\n\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\t//初始化GLAD\n    {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n\n    glViewport(0, 0, 800, 600);\t\t//设置视口\n\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\t//注册窗口大小变化的回调函数\n\n    while (!glfwWindowShouldClose(window))\t // 只要窗口没被关闭，就一直循环\n    {\n        glfwSwapBuffers(window);\t\t// 交换颜色缓冲（把渲染的图像显示到屏幕上）\n        glfwPollEvents();\t\t// 处理键盘鼠标等事件\n    }\n    glfwTerminate();\t// 清理并退出 GLFW\n    return 0;\n}\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n    glViewport(0, 0, width, height);\t\t// 根据新的窗口大小重新设置视口\n}\n```\n\n\n\n\n\n### 作业一\n\n\n\n- **绘制渐变色的三角形**\n\n```c++\n#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n#include <iostream>\n\n// 窗口大小变化时调整视口\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n    glViewport(0, 0, width, height);\n}\n\n// 检查着色器编译错误\nvoid checkCompileErrors(unsigned int shader, std::string type)\n{\n    int success;\n    char infoLog[1024];\n    if (type != \"PROGRAM\")\n    {\n        glGetShaderiv(shader, GL_COMPILE_STATUS, &success);\n        if (!success)\n        {\n            glGetShaderInfoLog(shader, 1024, NULL, infoLog);\n            std::cout << \"ERROR::SHADER_COMPILATION_ERROR of type: \" << type << \"\\n\"\n                << infoLog << \"\\n -- --------------------------------------------------- -- \" << std::endl;\n        }\n    }\n    else\n    {\n        glGetProgramiv(shader, GL_LINK_STATUS, &success);\n        if (!success)\n        {\n            glGetProgramInfoLog(shader, 1024, NULL, infoLog);\n            std::cout << \"ERROR::PROGRAM_LINKING_ERROR of type: \" << type << \"\\n\"\n                << infoLog << \"\\n -- --------------------------------------------------- -- \" << std::endl;\n        }\n    }\n}\n\nint main()\n{\n    // 1. 初始化 GLFW\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // OpenGL 3.x\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // OpenGL x.3\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 核心模式\n\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // MacOS 需要这句\n#endif\n\n    // 2. 创建窗口\n    GLFWwindow* window = glfwCreateWindow(800, 600, \"Colored Triangle\", NULL, NULL);\n    if (window == NULL)\n    {\n        std::cout << \"Failed to create GLFW window\\n\";\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n\n    // 3. 初始化 GLAD\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    {\n        std::cout << \"Failed to initialize GLAD\\n\";\n        return -1;\n    }\n\n    // 4. 设置视口和窗口大小回调\n    glViewport(0, 0, 800, 600);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\n    // 5. 定义顶点数据（位置 + 颜色）\n    float vertices[] = {\n        // 位置           // 颜色(R, G, B)\n         0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f,  // 顶点1 蓝色\n        -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,  // 顶点2 绿色\n         0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f   // 顶点3 红色\n    };\n\n    // 6. 编写顶点着色器源码\n    const char* vertexShaderSource = R\"glsl(\n        #version 330 core\n        layout (location = 0) in vec3 aPos;   // 位置属性\n        layout (location = 1) in vec3 aColor; // 颜色属性\n\n        out vec3 ourColor; // 输出给片元着色器的颜色变量\n\n        void main()\n        {\n            gl_Position = vec4(aPos, 1.0); // 设置顶点位置\n            ourColor = aColor;              // 传递颜色到片元着色器\n        }\n    )glsl\";\n\n    // 7. 编写片元着色器源码\n    const char* fragmentShaderSource = R\"glsl(\n        #version 330 core\n        in vec3 ourColor;       // 从顶点着色器传来的颜色\n\n        out vec4 FragColor;     // 输出颜色\n\n        void main()\n        {\n            FragColor = vec4(ourColor, 1.0); // 设置片元颜色，alpha为1（不透明）\n        }\n    )glsl\";\n\n    // 8. 编译顶点着色器\n    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);\n    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);\n    glCompileShader(vertexShader);\n    checkCompileErrors(vertexShader, \"VERTEX\");\n\n    // 9. 编译片元着色器\n    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);\n    glCompileShader(fragmentShader);\n    checkCompileErrors(fragmentShader, \"FRAGMENT\");\n\n    // 10. 链接着色器程序\n    unsigned int shaderProgram = glCreateProgram();\n    glAttachShader(shaderProgram, vertexShader);\n    glAttachShader(shaderProgram, fragmentShader);\n    glLinkProgram(shaderProgram);\n    checkCompileErrors(shaderProgram, \"PROGRAM\");\n\n    // 11. 删除着色器对象，已经链接到程序里了\n    glDeleteShader(vertexShader);\n    glDeleteShader(fragmentShader);\n\n    // 12. 创建顶点缓冲和顶点数组对象\n    unsigned int VBO, VAO;\n    glGenVertexArrays(1, &VAO);\n    glGenBuffers(1, &VBO);\n\n    // 绑定 VAO\n    glBindVertexArray(VAO);\n\n    // 绑定并填充 VBO\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\n    // 位置属性\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);\n    glEnableVertexAttribArray(0);\n\n    // 颜色属性\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));\n    glEnableVertexAttribArray(1);\n\n    // 解绑\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindVertexArray(0);\n\n    // 13. 渲染循环\n    while (!glfwWindowShouldClose(window))\n    {\n        // 处理输入（这里没写输入，后续可以加）\n\n        // 清屏，设置背景颜色\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        // 使用着色器程序\n        glUseProgram(shaderProgram);\n\n        // 绑定 VAO\n        glBindVertexArray(VAO);\n\n        // 绘制三角形\n        glDrawArrays(GL_TRIANGLES, 0, 3);\n\n        // 交换缓冲区和轮询事件\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    // 14. 释放资源\n    glDeleteVertexArrays(1, &VAO);\n    glDeleteBuffers(1, &VBO);\n    glDeleteProgram(shaderProgram);\n\n    // 15. 退出 GLFW\n    glfwTerminate();\n    return 0;\n}\n```\n\n\n\n![image-20250625101600766](/pictures/OpenGL/image-20250625101600766.png)\n\n\n\n\n\n### 练习\n\n- 添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形。\n\n​\t相较于上面的代码，只需修改两处即可：添加顶点（坐标和颜色属性）、绘制6个顶点。\n\n```java\nfloat vertices[] = {\n\t-0.9f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f,\n\t-0.0f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f,\n\t-0.45f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f,\n\t 0.0f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, \n\t 0.9f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f,\n\t 0.45f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f\n};\n\nglDrawArrays(GL_TRIANGLES, 0, 6);\t//用顶点数组从第 0 个顶点开始，按三角形方式，绘制 6个顶点组成的两个三角形。\n```\n\n![image-20250626135154793](/pictures/OpenGL/image-20250626135154793.png)\n\n\n\n\n\n\n\n- 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO。\n\n​\t其他部分不变，改动如下：创建时使用数组存储多个VAO和VBO、两个三角形顶点数据分为不同数组存储、分开绑定并且传输数据解析数据、分开绘制。\n\n```java\nunsigned int VBOs[2], VAOs[2];\nglGenVertexArrays(2, VAOs); // we can also generate multiple VAOs or buffers at the same time\nglGenBuffers(2, VBOs);\n\nfloat firstTriangle[] = {\n    -0.9f, -0.5f, 0.0f,  // left \n    -0.0f, -0.5f, 0.0f,  // right\n    -0.45f, 0.5f, 0.0f,  // top \n};\nfloat secondTriangle[] = {\n     0.0f, -0.5f, 0.0f,  // left\n     0.9f, -0.5f, 0.0f,  // right\n     0.45f, 0.5f, 0.0f   // top \n};\n\nglBindVertexArray(VAOs[0]);\nglBindBuffer(GL_ARRAY_BUFFER, VBOs[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(firstTriangle), firstTriangle, GL_STATIC_DRAW);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\t// Vertex attributes stay the same\nglEnableVertexAttribArray(0);\n\nglBindVertexArray(VAOs[1]);\t// 绑定新的VAO\nglBindBuffer(GL_ARRAY_BUFFER, VBOs[1]);\t//绑定新的VBO\nglBufferData(GL_ARRAY_BUFFER, sizeof(secondTriangle), secondTriangle, GL_STATIC_DRAW); //传输数据到VBO代表的缓冲区\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0); \t\t//指定读取方式\nglEnableVertexAttribArray(0);\t\t\t//启用顶点属性\n\nglBindVertexArray(VAOs[0]);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n        // then we draw the second triangle using the data from the second VAO\nglBindVertexArray(VAOs[1]);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n​\t**glVertexAttribPointer**函数的参数蛮多，建议边看LearnOpenGL项目。\n\n\n\n\n\n\n\n- 创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色。\n\n​\t\n\n​\t在上面的基础上，创建两个**shaderProgram**、**fragmentshader**，然后编译好三个着色器（包括一个共用的顶点着色器），之后分组链接到**shaderProgram**中，最后**while**循环中，分别使用**glUseProgram**函数指定渲染程序进行绘画。","tags":["OpenGL"],"categories":["开发"]},{"title":"阅读APP项目学习——4","url":"/2025/06/24/阅读项目学习/安卓项目学习4/","content":"\n\n\n\n\n### 正文\n\n​\t\n\n​\t**BaseFragment**抽象类，是一个基础的Fragment类实现，继承自 `RxFragment`（这是一个支持 RxJava 生命周期管理的 Fragment），由于该父类实现了IView的方法，所以可以不再实现。\n\n​\t**BaseFragment<T extends IPresenter>**：这是一个泛型类，泛型参数 `T` 必须是 **IPresenter** 接口的子类。说明这个 Fragment 会和某个 Presenter 关联，符合 MVP 架构设计模式。\n\n```java\nprotected View view;\t\t\t\t//保存当前Fragment的根布局视图\nprotected Bundle savedInstanceState;\t\t//保存 Fragment 状态数据\n@Nullable\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\tthis.savedInstanceState = savedInstanceState;\n\tinitSDK();\n\tview = createView(inflater, container);\n\tinitData();\n\tbindView();\n\tbindEvent();\n\tfirstRequest();\n\treturn view;\n}\n    /**\n     * 事件触发绑定\n     */\n    protected void bindEvent() {\n\n    }\n    /**\n     * 控件绑定\n     */\n    protected void bindView() {\n\n    }\n    /**\n     * 数据初始化\n     */\n    protected void initData() {\n\n    }\n    /**\n     * 首次逻辑操作\n     */\n    protected void firstRequest() {\n\n    }\n    /**\n     * 加载布局\n     */\n    protected abstract View createView(LayoutInflater inflater, ViewGroup container);\n    /**\n     * 第三方SDK初始化\n     */\n    protected void initSDK() {\n\n    }\n```\n\n​\t`onCreateView` 是 Fragment 创建视图时调用的回调方法（生命周期方法），它负责加载并返回 Fragment 的布局视图。\n\n\n\n\n\n\n\n\n\n​\t**BaseModelImpl**类用来创建网络请求客户端的基础模型类，它主要负责配置并生成 Retrofit 实例，方便其他模块调用网络接口。使用OkHttp的**OkHttpClient.Builder**来创建客户端，设置了连接超时、写超时、读超时，和一个自定义的网络拦截器，用于请求失败后的重试逻辑。\n\n​\t**getRetrofitObject**方法用来创建一个Retrofit实例，传入基础的URL。\n\n​\t**getRetrofitString**和上面的方法类似，用来处理不同编码（`encode`）的字符串转换。\n\n```java\npublic class BaseModelImpl {\n\n    protected OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .writeTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(10, TimeUnit.SECONDS)\n            .addNetworkInterceptor(new RetryIntercepter(1));\n\n    protected Retrofit getRetrofitObject(String url) {\n        return new Retrofit.Builder().baseUrl(url)\n                //增加返回值为字符串的支持(以实体类返回)\n                .addConverterFactory(ScalarsConverterFactory.create())\n                //增加返回值为Oservable<T>的支持\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .client(clientBuilder.build())\n                .build();\n    }\n\n    protected Retrofit getRetrofitString(String url, String encode) {\n        return new Retrofit.Builder().baseUrl(url)\n                //增加返回值为字符串的支持(以实体类返回)\n                .addConverterFactory(EncodoConverter.create(encode))\n                //增加返回值为Oservable<T>的支持\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .client(clientBuilder.build())\n                .build();\n    }\n}\n```\n\n> 1. Retrofit 是什么？\n>\n> - Retrofit 是由 Square 公司开发的一个 **Android 和 Java** 平台上的网络请求库。\n> - 它帮助你很方便地调用网络上的 **HTTP 接口**（API），从服务器拿数据。\n> - 它帮你把网络请求和响应变得“像调用本地方法”一样简单。\n\n\n\n\n\n\n\n\n\n\n\n\n\n​\t**BasePresenterImpl**抽象类实现了attachView功能，并且通过模板T来进行类型转换，是一个Presenter基类。\n\n```java\npublic abstract class BasePresenterImpl<T extends IView> implements IPresenter{\n    protected T mView;\n\n    @Override\n    public void attachView(@NonNull IView iView) {\n        mView = (T) iView;\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n​\t**RetryIntercepter**类是一个自定义的 **OkHttp 拦截器**，其中`Request` 代表这次网络请求的详细信息，比如请求的地址、请求方法（GET、POST）、请求头、请求体等等。\n\n> ## 为什么要这样写？\n>\n> 拦截器就是“请求和响应之间的中间人”，它能：\n>\n> - **拿到请求**（`chain.request()`）\n> - **对请求做点事**（比如加个头，改改参数，或者打印日志）\n> - **发出请求**（`chain.proceed(request)`）\n> - **拿到响应**，还可以对响应做点事（比如判断失败重试）\n\n```java\npublic class RetryIntercepter implements Interceptor {\n    public int maxRetry;//最大重试次数\n    private int retryNum = 0;//假如设置为3次重试的话，则最大可能请求4次（默认1次+3次重试）\n\n    public RetryIntercepter(int maxRetry) {\n        this.maxRetry = maxRetry;\n    }\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Response response = chain.proceed(request);\n        while (!response.isSuccessful() && retryNum < maxRetry) {\n            retryNum++;\n            response = chain.proceed(request);\n        }\n        return response;\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n​\tbasemvplib分析完了，下一步要分析monky包。先大体通过AI预测一波各个文件夹的含义和其中类的作用。\n\n> ​\t**base**文件夹项目是基础代码，比如基类（BaseActivity、BaseFragment、BasePresenter等），公共抽象层，用来复用和统一规范。\n>\n> ​\t**bean**文件夹存放数据模型类（实体类），用来表示业务数据，比如书籍信息、用户信息等。通常和数据库表结构或者接口返回数据对应。\n>\n> ​\t**cache**缓存相关的代码，负责数据缓存逻辑。\n>\n> ​\t**common**配置的是访问小说网站的API接口。\n>\n> ​\t**dao**是 Data Access Object（数据访问对象） 的缩写，数据访问层，封装数据库操作（增删改查），通常对应实体bean，有专门的接口或类处理数据存取。\n>\n> ​\t**listener**定义获取章节列表的回调通知。\n>\n> ​\t**model**业务逻辑层，处理具体的数据操作和业务规则。\n>\n> ​\t**presenter**这里是 Presenter 层，负责连接 View 和 Model，实现业务逻辑，处理界面和数据的交互。\n>\n> ​\t**service**一般放后台服务相关代码，比如 Android 的 Service 类，做持续后台任务，或者封装网络请求、系统服务操作等。\n>\n> ​\t**utils**工具类包，存放各种辅助类和静态方法。\n>\n> ​\t**view**自定义的视图类，或者跟界面相关的类（不包括特殊控件），一般用来封装界面逻辑或复用界面组件。\n>\n> ​\t**widget**自定义控件或者 UI 组件，比如自定义按钮、列表、动画控件等，扩展系统控件功能。\n\n​\t**BitIntentDataManager**管理 Intent 传递的数据，封装 Intent 数据处理逻辑，方便 Activity/Fragment 之间传参。\n\n​\t**ErrorAnalyContentManager**错误内容分析管理器，可能是日志收集、错误信息处理或者错误报告生成相关的类。\n\n​\t**MApplication**自定义的 Application 类，应用入口，初始化全局变量、SDK、单例等。\n\n​\t**ProxyManager**代理管理器，可能用来实现某种代理模式，动态代理对象，或者负责网络代理、请求代理等功能。\n\n​\t**ReadBookControl**读书控制器，负责书籍阅读相关的业务逻辑，比如翻页、字体大小、阅读进度管理等。\n\n\n\n\n\n​\t改天再系统分析吧，下面在AI问到了一套比较系统的分析流程。\n\n> ## 🧭 一套系统的 MVP 项目分析流程（从 UI 到数据）\n>\n> ------\n>\n> ### ✅ **第一阶段：搞清楚结构和页面入口**\n>\n> #### 步骤 1：打开项目，看 `包结构`\n>\n> - 看包名下有哪些模块（你前面提到的 `view/`, `presenter/`, `model/`, `dao/` 等等）。\n> - 了解项目是不是使用了 MVP/MVVM 架构（从 `presenter/` 和 `model/` 目录可以看出）。\n>\n> #### 步骤 2：找“首页 Activity”或主入口页面\n>\n> - 找 `MainActivity`, `LauncherActivity`, `SplashActivity` 等。\n> - 它一般会是你启动 App 后看到的第一个页面。\n>\n> ------\n>\n> ### ✅ **第二阶段：从 View 层入手分析一个页面**\n>\n> #### 步骤 3：从 `Activity` 或 `Fragment` 开始看\n>\n> - 关注 `onCreate()` 或 `onCreateView()` 方法。\n>\n> - 看它绑定了哪个 Presenter，例如：\n>\n>   ```java\n>   presenter = new ReadBookPresenter();\n>   presenter.attachView(this);\n>   ```\n>\n> - 查看哪些用户操作（按钮点击、滑动等）触发了哪些逻辑：\n>\n>   ```java\n>   button.setOnClickListener(v -> presenter.doSomething());\n>   ```\n>\n> #### 步骤 4：查找绑定的 View 和自定义控件\n>\n> - 查看 XML 布局文件和 `findViewById()` 绑定了哪些控件。\n> - 如果发现有 `PageWidget`、`ReadSettingView` 这类自定义控件：\n>   - 先了解它的大致作用（比如翻页、显示文字）\n>   - 再决定是否深入看它的绘图或手势逻辑（很多时候可以略过）\n>\n> ------\n>\n> ### ✅ **第三阶段：深入 Presenter 层，分析业务逻辑**\n>\n> #### 步骤 5：打开对应的 `Presenter` 类\n>\n> - 看这个 Presenter 的方法有哪些？\n> - 你在 View 层点击按钮时，是调用的哪个方法？\n>\n> 示例：\n>\n> ```java\n> public void loadBook() {\n>     model.getBookData(new Callback() {\n>         @Override\n>         public void success(BookShelfBean bean) {\n>             view.showContent(bean);\n>         }\n>     });\n> }\n> \n> ```\n>\n> - Presenter 是 **核心逻辑中枢**，连接 View 和 Model。\n>\n> ------\n>\n> ### ✅ **第四阶段：查看 Model 层，数据从哪来？**\n>\n> #### 步骤 6：打开 `Model` 或 `ModelImpl` 类\n>\n> - 看它是从 **哪里拿数据** 的：\n>\n>   - 网络请求？（比如用 Retrofit）\n>   - 数据库？（比如用 Dao、GreenDAO）\n>   - 缓存？（比如用 CacheManager）\n>\n> - 查看具体的数据来源，比如：\n>\n>   ```\n>   RetrofitHelper.getApi().getChapters(bookId);\n>   ```\n>\n> ------\n>\n> ### ✅ **第五阶段：往下看数据支撑层（可选）**\n>\n> #### 步骤 7：查看 Bean、Dao、Utils 工具类\n>\n> - `bean/`：定义了哪些数据结构，比如 `BookShelfBean`, `ChapterBean`？\n> - `dao/`：你可以看看 `BookShelfBeanDao` 是如何存/取书的数据的。\n> - `utils/`：只在你看到用到的时候再深入看，比如处理日期、文件、网络状态等。\n>\n> ------\n>\n> ### ✅ **第六阶段：查找回调机制与事件流**\n>\n> - 项目中可能会有一些回调接口（像你之前提到的 `OnGetChapterListListener`）\n> - 分析它们是怎么传值、触发逻辑的。\n\n","tags":["安卓开发学习"],"categories":["开发"]},{"title":"阅读APP项目学习——3","url":"/2025/06/23/阅读项目学习/安卓项目学习3/","content":"\n\n\n### 前言\n\n​\t分析复杂一点的功能，需要熟悉面向对象的编程思想，熟悉更加基础的代码，我感觉有点力不从心，十分难以下手，考虑要不要从基础类一点点学习，分析其作用、为什么要这样写之类的问题，能学到很多知识点，这样是不是会更加有利于我的开发经验学习，毕竟“轮子”的代码都还没搞明白为什么这么写，直接去解析在此基础上的其他功能会让我有点不脚踏实地的感觉。\n\n​\t另外，因为错误的操作，把资源文件给搞乱了，又得新建项目重新copy了，有点烦。\n\n\n\n​\t\n\n### 正文\n\n​\t先从basemvplib的文件开始吧，IView和IPresenter的基础思想已经学习过了，再从**AppActivityManager**、**BaseApplication**、**EncodoConverter**这三个类开始吧。\n\n​\t\n\n​\t**AppActivityManager**类是管理项目中所有Activity的工具类，方便在应用中统一控制 Activity 生命周期，比如批量关闭某类 Activity 或检测 Activity 是否在栈中。\n\n​\t`private static List<WeakReference<Activity>> activities;`使用弱引用存储Activity，当 Activity 被系统回收时，弱引用不会阻止它的回收，避免强引用导致内存泄漏。\n\n\n\n​\t通过双重检查实现线程安全的单例模式，保证AppActivityManager在整个应用中只有一个实例。\n\n```java\npublic static AppActivityManager getInstance(){\n        if(null == instance){\n            synchronized (AppActivityManager.class){\n                if(null == instance){\n                    instance = new AppActivityManager();\n                }\n            }\n        }\n        return instance;\n    }\n\n```\n\n\n\n​\t提供了add、remove方法，其中有两种移除方式：提供Activity实例和Activity类名。\n\n​\t提供了finish方法，可以关闭指定的Activity实例或关闭指定类型的Activity。\n\n​\t提供isExist方法，能够判断某个Activity类是否存在。\n\n\n\n> ### 简单理解：\n>\n> - **Application.onCreate()**\n>    是整个应用程序的“启动入口”，在应用一启动时调用，只调用一次。\n>    你可以在这里做一些**全局初始化**，比如初始化数据库、网络库、第三方SDK等，所有页面都能用。\n> - **Activity.onCreate()**\n>    是某个具体页面（Activity）创建时调用。每打开一个新页面，就会调用它。\n>    你可以在这里做这个页面专属的初始化，比如加载布局、设置按钮事件等。\n\n\n\n​\t**BaseApplication**是一个自定义的Application类，是安卓应用的入口类，是应用启动时创建的全局入口，用来做全局初始化和管理。这是一个基础框架类，只实现了onCreate方法，调用父类的方法。\n\n\n\n​\t**EncodoConverter**继承了 `retrofit2.Converter.Factory`，用于创建数据转换器；有一个私有字段 `encode`，默认编码是 `\"utf-8\"`，也可以自定义传入编码；提供了两个静态方法 `create()` 用于创建该转换器实例，可以用默认编码，也可以用自定义编码；重写了 `responseBodyConverter()` 方法，返回一个 `Converter<ResponseBody, String>`，这个转换器就是把响应体数据读取为指定编码的字符串。\n\n​\t这段代码就是给 Retrofit 定制一个响应体的编码转换器，让它可以用指定编码把服务器返回的字节流转成字符串。\n\n\n\n​\t**Retrofit** 是一个用于 Android 和 Java 的网络请求库，它帮你很方便地向服务器发送 HTTP 请求，获取数据，然后自动把服务器返回的 JSON 或 XML 转换成你定义的 Java 对象，省去了你自己写很多解析代码。\n\n\n\n\n\n\n\n​\t再看**BaseActivity**类，它是所有Activity的基类，统一封装生命周期方法和Presenter管理，使用了泛型<T extends IPresenter> 表示传入的 Presenter 类型，实现了IView。\n\n​\t页面初始化流程，不需要的方法可以不实现。\n\n```java\n    /**\n     * 生命周期 onCreate，Activity 启动时调用。\n     * 这里统一调用了一系列初始化方法，下面会解释每个方法作用。\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        this.savedInstanceState = savedInstanceState;\n\n        // 获取是否使用转场动画\n        if(getIntent()!=null){\n            startShareAnim = getIntent().getBooleanExtra(start_share_ele,false);\n        }\n\n        // 添加到全局Activity管理器中（方便统一关闭、管理Activity）\n        AppActivityManager.getInstance().add(this);\n\n        // 第一步：初始化第三方SDK（可选）\n        initSDK();\n\n        // 第二步：设置布局，比如 setContentView(R.layout.xxx)\n        onCreateActivity();\n\n        //第三步：创建 Presenter 对象\n        mPresenter = initInjector();\n\n        // 第四步：将当前View绑定到Presenter上（用于通知刷新）\n        attachView();\n\n        // 第五步：初始化数据（如适配器、变量等）\n        initData();\n\n        // 第六步：绑定控件（findViewById）\n        bindView();\n\n        // 第七步：绑定事件（点击、刷新等逻辑）\n        bindEvent();\n\n        // 第八步：发起首次请求，比如网络加载书架\n        firstRequest();\n    }\n```\n\n​\t还写好了页面的跳转功能，也就是启动新Activity并带动画效果的方法，有多种，适配多种情况下的使用需求。\n\n```java\n////////////////////////////////启动Activity转场动画/////////////////////////////////////////////\n\n    protected void startActivityForResultByAnim(Intent intent, int requestCode, int animIn, int animExit) {\n        startActivityForResult(intent, requestCode);\n        overridePendingTransition(animIn, animExit);\n    }\n\n\n\n    //protected代表它的子类可以调用\n    protected void startActivityByAnim(Intent intent, int animIn, int animExit) {\n        startActivity(intent);\n        overridePendingTransition(animIn, animExit);\n    }\n\n    protected void startActivityForResultByAnim(Intent intent, int requestCode, @NonNull View view, @NonNull String transitionName, int animIn, int animExit) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            startActivityForResult(intent, requestCode, ActivityOptions.makeSceneTransitionAnimation(this, view, transitionName).toBundle());\n        } else {\n            startActivityForResultByAnim(intent, requestCode, animIn, animExit);\n        }\n    }\n\n    protected void startActivityByAnim(Intent intent, @NonNull View view, @NonNull String transitionName, int animIn, int animExit) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            intent.putExtra(start_share_ele,true);\n            startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, view, transitionName).toBundle());\n        } else {\n            startActivityByAnim(intent, animIn, animExit);\n        }\n    }\n\n    public Context getContext(){\t\t//实现的IView方法\n        return this;\n    }\n\n    public Boolean getStart_share_ele() {\n        return startShareAnim;\n    }\n```\n\n​\t什么是“共享元素动画”？简单说，就是两个页面**“共用一个东西”**，这个东西在切换页面时会**动起来，看起来很自然、酷炫**。更加详细的讲解可以百度。\n\n\n\n\n\n\n\n​\t后面还有**BaseFragment**、**BaseModelImpl**、**BasePresenterImpl**、**RetryIntercepter**类，改天再解析，今天学习任务结束！\n","tags":["安卓开发学习"],"categories":["开发"]},{"title":"阅读APP项目学习——2","url":"/2025/06/22/阅读项目学习/安卓项目学习2/","content":"\n​\t欢迎页开始后，就进入主体**MainActivity**中，查看源码可以发现，其使用了众多自定义的其他类。\n\n​\t\n\n### 概述\n\n​\t先大体通过AI分析一波，看看这个主页面在干什么。\n\n- 页面初始化和布局设置：继承自 **MBaseActivity<IMainPresenter>**，采用 MVP 架构设计（视图层 **MainActivity** 负责UI，**IMainPresenter** 负责业务逻辑）。初始化页面上的控件，如应用logo、几个功能按钮（打赏、设置、书库、添加书籍、下载）、刷新列表控件（**RefreshRecyclerView**）等。\n\n- 显示书架列表：使用**RefreshRecyclerView**来展示书架内容，使用自定义的**BookShelfAdapter**作为列表的适配器，再通过布局管理器**LinearLayoutManager**来控制**RecyclerView**布局。\n- 刷新和加载数据：绑定刷新监听器（**OnRefreshWithProcessListener**）来实现下拉刷新书架数据，刷新时调用**mPresenter.queryBookShelf(true)**请求最新数据。同时处理刷新完成和刷新错误的回调，并更新UI和进度条。\n- 事件处理：给首页的各个按钮绑定点击事件：设置按钮弹出代理设置窗口；下载按钮弹出下载列表窗口；书库按钮跳转到书库界面（**LibraryActivity**）；添加书籍按钮跳转到导入书籍界面；打赏按钮预留了点击事件，具体逻辑没写。给书架列表的每个书籍绑定了点击事件：点击跳转到阅读界面；长按跳转到书籍详情界面，并带动画效果。书架中点击“去选书”会跳转到书库。\n- 管理警告信息弹窗：页面上有一个警告信息区域（**flWarn**），可以通过关闭按钮隐藏。\n- 处理系统按键事件：捕获返回键，实现“连续两次按返回键退出应用”的交互逻辑。\n- 生命周期管理：在 **onDestroy** 里做资源销毁，比如关闭弹窗。\n\n\n\n> ​\t上面比较陌生的概念有“适配器”，这是什么东西啊？\n>\n> ​\t举个简单的例子：你想在家里的书架上摆书，RecyclerView就是书架，适配器就是按顺序拿书，一本一本摆放书籍的人，书本的数据就是你手里的书。没有适配器，你的书架就不知道摆哪些书，也不知道怎么摆。\n\n\n\n\n\n### 逻辑解读\n\n​\t\n\n```java\n//成员变量声明\n    private ImageView ivLogo;           //应用logo图标\n    private ImageButton ibMoney;        //打赏按钮\n    private ImageButton ibSettings;     //设置按钮\n    private ImageButton ibLibrary;      //书库按钮\n    private ImageButton ibAdd;          //添加书籍按钮\n    private ImageButton ibDownload;     //下载按钮\n\n    private RefreshRecyclerView rfRvShelf;\n    private BookShelfAdapter bookShelfAdapter;\n\n    private FrameLayout flWarn;         //警告信息布局（弹出框）\n    private ImageView ivWarnClose;      //关闭警告按钮\n\n    private DownloadListPop downloadListPop;        //下载列表弹窗对象\n    private ProxyPop proxyPop;          //代理设置弹窗对象\n```\n\n​\tImageView是安卓里面用来显示图片的控件，就是一个”图片框“，专门用来在界面上展示图片，比如应用图标、照片、按钮图标等等，只负责显示图片，不响应点击事件（当然，你可以给它加点击事件，让它像按钮一样用）。\n\n​\tImageButton就是有图片的按钮。\n\n​\t其他就是自定义的组件了。\n\n\n\n​\t\n\n​\t看到具体的方法，**initInjector**是在初始化一个Presenter对象，然后返回一个**MainPresenterImpl**实例，负责与界面业务逻辑交互。\n\n​\t**onCreateActivity**设置界面的布局文件。\n\n​\t**initData**初始化数据，创建书架适配器实例。\n\n​\t**dispatchTouchEvent**处理触摸事件，调用父类的方法，套壳函数。\n\n​\t**bindView**绑定界面控件（找控件、实例化），找到布局里的各种控件（按钮、列表、弹窗等），并关联到变量，给书架列表 `RecyclerView` 设置适配器和布局管理器。\n\n​\t**bindEvent**绑定各种事件监听器。\n\n​\t**bindRvShelfEvent**给书架的刷新控件绑定刷新监听。\n\n​\t**firstRequest**首次加载数据，应用打开时调用。\n\n​\t**refreshBookShelf**将新的书籍列表数据传给适配器，更新显示。\n\n​\t**activityRefreshView**触发书架刷新动作，让刷新控件开始刷新动画并调用刷新逻辑。\n\n​\t**refreshFinish**刷新结束，隐藏刷新动画。\n\n​\t**refreshError**刷新错误时调用。\n\n​\t**refreshRecyclerViewItemAdd**刷新时进度条+1。\n\n​\t**setRecyclerMaxProgress**设置刷新进度条的最大值。\n\n​\t**onKeyDown**按键事件处理，用户按返回键时，调用 `exit()` 方法，实现“再按一次退出程序”的逻辑。\n\n​\t**onDestroy**资源销毁时调用，清理一些弹窗的资源，防止内存泄漏。\n\n​\t**exit**退出程序的逻辑，如果2秒内第二次按返回键，则退出程序，否则提示“再按一次退出程序”。\n\n\n\n\n\n### 前端页面复现\n\n​\t看到XML文件，里面使用到一个自定义的组件**com.monke.monkeybook.widget.refreshview.RefreshRecyclerView**，\n\n下图中的空白区域就是这个组件的位置。当然也包括一个作者自己开源的沉浸框，需要引用依赖。\n\n​\t里面的布局很清晰明了，沉浸框包裹最外层，然后一个垂直方向的线性布局来隔分上下页面，里面再由水平的线性布局来展示顶部，下面就是书架区。\n\n![image-20250622115453885](/pictures/novelReader_app/image-20250622115453885.png)\n\n​\t需要导入对应的drawable里面的XML文件、layout里面的其他XML文件、values里面的XML文件。然后写入**RefreshRecyclerView**类、**RefreshProgressBar**类、**RefreshRecyclerViewAdapter**抽象类、**OnRefreshWithProgressListener**接口、**OnLoadMoreListener**接口、**BaseRefreshListener**接口，还有**BookContentView**类，因为这个类又引出一堆其他的类和接口。太麻烦了。\n\n​\t先放着BookContentView不管吧，还有其他几个**BitIntentDataManager**、**MApplication**、**ReadBookControl**都有点问题啊！这样分析也太麻烦了。不能按照这个逻辑搞下去。\n\n\n\n\n\n### 具体功能流程分析\n\n​\t先从最简单的退出功能来说吧，不然都没法读下去了。\n\n```java\n\t@Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (keyCode == KeyEvent.KEYCODE_BACK) {\n            exit();\n            return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n\tprivate long exitTime = 0;\n\tpublic void exit() {\n        if ((System.currentTimeMillis() - exitTime) > 2000) {\n            Toast.makeText(getApplicationContext(), \"再按一次退出程序\",\n                    Toast.LENGTH_SHORT).show();\n            exitTime = System.currentTimeMillis();\n        } else {\n            finish();\n            System.exit(0);\n        }\n    }\n```\n\n​\t当用户摁下”返回键“，触发onKeyDown方法，会调用exit方法，导致退出程序。keyCode表示当前被按下的按键的代码（编号），KeyEvent.KEYCODE_BACK是安卓系统定义的常量，代表”返回键“的按键代码。System.currentTimeMillis方法返回一个”long“类型的数字，表示从“1970年1月1日午夜”（称为“Unix纪元”）开始，到当前时刻所经过的毫秒数。\n\n​\t第一次摁下”返回键“会设置exitTime为当前时间，然后需要在两秒内再摁一次，才进入else里面。\n\n​\tfinish方法，**只是告诉系统“关闭这个Activity”，但它是异步的，不会立即停止当前方法的执行**。`finish()` 会请求系统去销毁Activity（触发生命周期`onPause() -> onStop() -> onDestroy()`），但是这个过程是在系统消息队列中排队执行的，并不会马上跳出当前方法或终止线程，但是这个过程是在系统消息队列中排队执行的，并不会马上跳出当前方法或终止线程。\n\n\n\n\n\n\n\n### AI总结主页面功能\n\n​\t后面就根据这些功能，开始进行分块讲解，包括代码跟踪讲解，这样会更加让我专注于功能的实现。\n\n> ### 1. 界面初始化和视图绑定\n>\n> - **加载界面布局**（`setContentView`），让页面显示出来\n> - **查找并绑定控件**，比如logo图标、按钮、书架列表等\n> - **初始化书架适配器**，管理书籍列表的显示\n>\n> ### 2. 数据展示和刷新\n>\n> - **展示书架列表数据**，把数据加载到书架适配器里，显示在列表中\n> - **支持下拉刷新**，用户下拉列表时，重新请求数据，刷新书架内容\n> - **刷新进度反馈**，通过进度条显示刷新进度，提高用户体验\n>\n> ### 3. 用户交互处理\n>\n> - **按钮点击事件**\n>   - 点击“设置”按钮弹出代理设置窗口\n>   - 点击“下载”按钮弹出下载列表\n>   - 点击“打赏”按钮触发打赏操作（这里没实现具体逻辑）\n>   - 点击“书库”按钮进入书库页面\n>   - 点击“添加书籍”按钮进入导入书籍页面\n> - **书架书籍点击**\n>   - 点击书籍跳转到阅读页面，打开书籍\n>   - 长按书籍跳转到书籍详情页面，带动画效果\n>\n> ### 4. 弹窗与提示\n>\n> - 弹出代理设置和下载列表弹窗，方便用户操作\n> - 警告信息框的显示和关闭，提醒用户重要信息\n>\n> ### 5. 生命周期与退出\n>\n> - 监听手机返回键，防止误操作退出\n> - 实现“双击返回键退出程序”的逻辑，提高用户体验\n> - 退出时释放资源，防止内存泄漏\n>\n> ​\t\t","tags":["安卓开发学习"],"categories":["开发"]},{"title":"阅读APP项目学习——1","url":"/2025/06/21/阅读项目学习/安卓项目学习1/","content":"\n# \t前言\n\n​\t该阅读项目是[MONKOVEL](https://github.com/ZhangQinhao/MONKOVEL)，我将分析学习其项目设计和JAVA代码，我没什么语言基础，也没有开发经验，此系列将记录我在这个项目中自学到的知识。\n\n​\t\n\n# \t正文\n\n​\t先看到`AndroidManifest.xml`文件，查看APP存在多少个Activity（界面）：`WelcomeActivity`类负责欢迎界面，实现一个动画的效果。\n\n```xml\n<activity\n            android:name=\".view.impl.WelcomeActivity\"\n            android:screenOrientation=\"portrait\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n```\n\n​\t之后会跳转到主界面。\n\n```java\npublic void onAnimationEnd(Animator animation) {\n                startActivityByAnim(new Intent(WelcomeActivity.this, MainActivity.class), android.R.anim.fade_in, android.R.anim.fade_out);\n                finish();\n            }\n```\n\n\n\n​\t`MainActivity`负责主页面的呈现，展示从各个网站解析来的书籍；`SearchActivity`类负责关键词搜索，可能会调用网络接口或本地数据库查询；`DownloadService`负责后台下载任务，通常是service类型，不阻塞UI，管理下载队列，处理断点续传等等；还有`LibraryActivity`书架页面、`ChoiceBookActivity`书籍选择页面、`BookDetailActivity`书的详细详细、`ReadBookActivity`负责阅读界面、`ImportBookActivity`负责本地导入书籍。\n\n\n\n\n\n## 复现\n\n​\t首先可以单独复现出welcome界面，先处理好xml文件，会需要导入包：注意新的写法是`implementation(\"...\")`。写入`activity_welcome.xml`文件，复制图片资源到res目录下，改写系统默认的`AndroidManifest.xml`文件，删除系统给的`MainActivity`部分。后面从`view.impl.WelcomeActivity`开始慢慢抄入其他文件，暂时不需要的功能可以注释掉。\n\n​\t\n\n### MVP架构\n\n​\t实现`IView`和`IPresenter`接口，这是MVP设计架构中常见的基础接口。\n\n> MVP的思想是：View（视图）：负责“显示”和“用户交互”。\n>\n> ​\t\tPresenter（中间人）：负责“处理逻辑”和“沟通”。\n>\n> ​\t\tModel（模型）：负责“数据和业务逻辑”。\n>\n> MVP 就是把“显示界面”和“业务逻辑”拆开，让代码更整洁、更容易维护\n\n> #### 真实开发中：\n>\n> - 你的手机界面就是 View，负责显示按钮、列表等\n> - 代码里写的 Presenter 负责监听按钮，处理业务逻辑\n> - Model 负责数据存取，比如从数据库拿数据，或者调用网络接口\n\n​\t\n\n​\t\n\n```java\npublic interface IView {\n    public Context getContext();\n}\n```\n\n​\t看到`IView`的接口方法，`getContext`方法，什么是Context？看一下ChatGpt的看法。\n\n> - **Context 就像手机里的“万能钥匙”或者“工具箱”**，它告诉你“现在在哪个环境下”，可以帮你访问很多系统服务、资源，甚至打开新页面、显示提示消息。\n> - 假设你在一个大商场里，Context 就像你的商场会员卡，你拿着会员卡，商场才知道你是谁、你在哪个店铺、你可以用哪些优惠，通过会员卡，你可以去不同的柜台（服务）办事情，比如买东西、退货、查余额。\n> - 在代码里 Context 能做什么？打开新界面、显示弹窗、访问资源、获取系统服务（比如网络、传感器）、访问文件、数据库等等。\n> - 举个简单例子，`Toast.makeText(context, \"Hello!\", Toast.LENGTH_SHORT).show();`，这句话的 `context` 就告诉系统，“你现在在哪个环境下显示这个弹窗”，系统才能正确地把弹窗显示在屏幕上。\n> - 常见的 Context 类型：**Activity**，它本身就是一个 Context，代表一个界面；**Application**，整个应用程序的全局 Context；**Service**，后台服务的 Context。\n\n​\t`getContext`是给谁用的？————给 **Presenter（业务逻辑层）用的**，Presenter 通过 `IView.getContext()` 拿到这个环境（Context），就能做很多事情。\n\n​\t看看例子，很清楚。\n\n```java\npublic class MainPresenter implements IPresenter {\n    private IView view;\n    @Override\n    public void attachView(@NonNull IView iView) {\n        this.view = iView;\n    }\n    @Override\n    public void detachView() {\n        this.view = null;\n    }\n    public void showMessage() {\n        // 通过view拿Context来显示Toast\n        Toast.makeText(view.getContext(), \"Hello MVP!\", Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n\n\n\n\n\n\n```java\npublic interface IPresenter {\n    /**\n     * 注入View，使之能够与View相互响应\n     */\n    void attachView(@NonNull IView iView);\n    /**\n     * 释放资源，如果使用了网络请求 可以在此执行IModel.cancelRequest()\n     */\n    void detachView();\n}\n```\n\n​\t看到`IPresenter`接口，`attachview`就是提供的用来绑定view和presenter的方法。\n\n​\t什么时候会调用？  一般是在界面刚创建或刚准备好跟 Presenter 交互的时候调用，比如 `Activity` 的 `onCreate()` 或 `onStart()` 里。\n\n​\t谁来调用？  通常是 **View（界面层，比如 Activity）自己调用**，或者有时是在创建 Presenter 的时候由框架或代码调用。\n\n​\t为什么？  因为 Presenter 需要知道它服务的是哪个 View，才能让 View 显示数据或者响应用户操作。\n\n\n\n​\t下面是AI举得小例子，很了然了。\n\n```java\npublic class MainActivity extends AppCompatActivity implements IView {\n    private IPresenter presenter;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        presenter = new MainPresenter();\n        presenter.attachView(this);  // 把自己（View）传给Presenter，绑定关系建立\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        presenter.detachView();  // 解绑，防止内存泄漏\n    }\n    // 实现IView的方法\n    @Override\n    public Context getContext() {\n        return this;\n    }\n}\n```\n\n\n\n​\t我们查看presenter和view文件夹也发现了这个一一对应的关系，除了欢迎界面（因为没有交互，所以不需要）。\n\n![image-20250621210554075](/pictures/novelReader_app/image-20250621210554075.png)\n\n\n\n### 其他子类设计\n\n​\t`BaseApplication`基础类。\n\n​\t`AppActivityManager`是一个“Activity管理工具类”：记录、管理当前所有的Activity，能关闭指定的Activity、能判断Activity是否存在、通过弱引用避免内存泄露。\n\n​\t`BaseActivity`是“通用Activity模板”，它封装了 Activity 常用的功能、生命周期管理、和 Presenter 的绑定逻辑，它的作用就是：把每个页面都要重复写的代码（如固定的方法调用，Activity转场动画调用等等），统一写在这个“父类”里，子类只需要关注页面自己的功能实现，省时省力！\n\n​\t`MBaseActivity`是继续添加友盟统计的一个抽象类，能够统计用户的使用情况。\n\n​\t\n\n\n\n​\t再抄下`activity_welcome.xml`布局文件，应该就可以展示第一个界面的效果了。\n","tags":["安卓开发学习"],"categories":["开发"]},{"title":"ISCTF2024","url":"/2025/06/05/ISCTF2024/RE/","content":"\n# Ezre\n\n> ​\t一个简单的维吉尼亚加密，看了半天没看出来，在强行写解密算法后，才突然发现。\n\n------\n\n\n\n# 《回忆安魂曲》三——mainn.exe\n\n\n\n> ​\t迷宫类题目，无壳64位。槽点就是将移动键换成了“love”四个字符，然后迷宫对应的字符串在结尾多给了几个，起到迷惑性效果，差点让我搞不清行列数，还有行坐标从0开始，列坐标从0开始，起始点坐标（1，1）。开始直接把我绕晕。\n>\n> ​\t确定迷宫后，又复习了DFS算法。收获不少。\n\n```python\nmaze_str = \"\"\"###############################P#...............#...#.......#.#####.###.#####.#.###.#####.#.....#...#.#.....#...#.#...#.#####.#.###.#.#######.#.#.###.#C..#.#.#...#.#...#...#.#.#...#.#.#.#.#.###.#.#.#.###.#.#.#.#.#.#.#.#...#...#.#.......#.#.#.###.#.###.#####.#########.###.#...#...#.....#.#.......#...#.#.#####.#####.#.#.#####.###.#...#...#...#...#...#...#.#...#.###.#.###.#.#######.#.#.#.#.#...#.#.#...#.#...#...#...#.#.###.#.#.#####.#.#.#.#######.###.#...#.....#...#.#.#...#.....#.#########.#####.#.###.#.###.#.#.....#.#...#...#...#...#.#.#.#.#.#.#.###.#.#####.###.#.#.#...#.#...#.#...#...#...#...#.#.###.###.#.#####.#.###.###.#.#...#.#.#.......#.#...#.#...#.#####.#.#######.#.#####.#.###.#...#.#.......#.#...#...#.#..E#.#.#.#.#######.###.#.#####.#.#.#...#.............#.....#.#.#.###############.#######.#.#.#.........#...#...#.....#...#.#.#######.#.#.#####.#.#######.#.......#...#.......#.........\"\"\"\n\nfor i in range(30):\n    for j in range(30):\n        print(maze_str[i*30+j], end=' ')\n    print()\n\n\nmaze = []\nfor i in range(30):\n    maze_row = []\n    for j in range(30):\n        maze_row.append(maze_str[i*30+j])\n    maze.append(maze_row)\n\nstart = (1,1)\n\ndef dfs(maze, x, y,path):\n    if maze[x][y] == 'E':\n        return True\n    if x < 0 or x >= len(maze) or y < 0 or y >= len(maze[0]) or maze[x][y] == '#' or maze[x][y] == 'C':\n        return False\n\n    maze[x][y] = '#'\n\n    directions = [(-1,0), (0,-1), (1,0), (0,1)]\n    directions_str = ['l', 'v', 'o', 'e']\n    for i in range(4):\n        dx = directions[i][0]\n        dy = directions[i][1]\n        path.append(directions_str[i])\n        if dfs(maze, x+dx, y+dy,path):\n            return True\n        path.pop()\n\n    maze[x][y] = '.'\n    return False\n\ndef find_path():\n    path = []\n    if dfs(maze, start[0], start[1], path):\n        return path\n    else:\n        return \"No path found\"\n\nans = find_path()\nans = ''.join(ans)\nprint(ans)\n```\n\n------\n\n\n\n# **找啊找**——zhao.exe\n\n> ​\t直接拖入IDA发现只有很少几个函数，于是去查壳发现UPX壳，然后直接-d脱壳失败，拖入HxD发现标志位被改成APK了，改回来就成功脱壳了。\n>\n> ​\t再拖入IDA中就正常了，逻辑很简单，查看加密逻辑，先大小写字母替换，再异或一下。静态分析时直接去数据节查看时，得到一组数据，然后写python代码，跑出来提示为错误的flag，是出题人挖的一个坑。\n>\n> ​\t反复查看加密逻辑发现没有问题，最后动态调试，在比较之前查看数据，发现程序里存储的加密数据被改了，看来是程序在运行初始化时才给出真正的加密flag。取出数据，跑解密脚本就ok了。\n>\n> ​\t还是动调发现问题。\n\n------\n\n\n\n# py不好，会被ban\n\n\n\n> ​\tpython的exe程序。先使用Pyinstxtractor解出pyc，然后直接托在线平台解出py。我开始找的平台解不出来，我还在猜是不是题目加难度了，导致文件进行了一定的修改，不能直接解出来。原来是工具不行！最后看wp才发现这个网站。\n>\n> ​\t解出py后直接反向写解密逻辑即可解密。\n\n\n\n------\n\n\n\n# 你知道.elf文件吗\n\n> ​\t跑不起来，签到题，没有技术含量，算了。\n\n\n\n------\n\n\n\n# 《回忆安魂曲》二——test11\n\n> ​\t一个ELF文件，使用IDA远程调试，收获到了IDA调试ELF程序的方法，进一步增加了动态调试的经验，认识到一种干扰编译的方法，就是在调用程序时，不直接使用call，而是将函数首地址加载进寄存器，然后使用call寄存器调用，这样IDA分析不出来，只有动调能看到其中的跳转逻辑。\n>\n> ​\t查阅知道，这是一种“控制流平坦化”的反编译技术，通过主分发器来控制程序基本块的执行流程。\n>\n> ​\t得知flag长度为36位，然后enc加密，动态调试分析加密逻辑。确定是逐字节加密，假设当前字符下标为i，字符串数组为str。有个密钥key为字符串“i_can_reverse_but_i_can_not_have_you“。\n>\n> ​\t最终得到的加密数据为：[234, 12, 26, 17, 246, 44, 29, 62, 23, 53, 49, 41, 244, 57, 57, 211, 195, 45, 0, 16, 48, 61, 204, 0, 211, 192, 75, 198, 17, 199, 41, 62, 186, 96, 144, 52]\n>\n> - str[i] = str[i] ^ (0x66 + i) ^ 0x52\n>- str[i] = str[i] + 6\n> - str[i] = str[i] ^ (key[i] + i)\n\n```python\nenc = [234, 12, 26, 17, 246, 44, 29, 62, 23, 53, 49, 41, 244, 57, 57, 211, 195, 45, 0, 16, 48, 61, 204, 0, 211, 192, 75, 198, 17, 199, 41, 62, 186, 96, 144, 52]\nkey = 'i_can_reverse_but_i_can_not_have_you'\n\nfor i in range(len(enc)):\n    enc[i] = (enc[i] ^ (ord(key[i]) + i)) & 0xff\n    enc[i] = (enc[i] - 6) & 0xff\n    enc[i] = (enc[i] ^ 0x52 ^(0x66 + i)) & 0xff\n    print(chr(enc[i]), end='')\n    #ISCTF{as_her_never_will_come_back!!}\n```\n\n------\n\n\n\n# 《回忆安魂曲》四——文件夹：初识风仙儿\n\n> ​\t解压得到一个main.py和so文件。这是一个`Cpython`逆向题，我是第一次遇见，先跟着WP学习，但是第一步通过python中的`help函数`查看模块就出问题了。为什么呢，因为几个虚拟机的python版本不对，需要3.10的，而且本机是windows系统，一直是要么导入错系统test模块，要么导入不进，唉，环境愁死人！下载python3.10还把我的ubuntu20.04给干崩了，被我直接删了。**之后再干这种活要拍快照了**！最后在ubuntu24.04中下载好了，然后就导入进去了。真的被环境折磨惨了啊。\n>\n> ​\t看了教程，都是神仙，有的直接猜出加密算法，有的一点点死看IDA中的几千行`Cython代码`，有的凭空生成了so对应的python源代码。一个都行不通，最后在网上找了个AI代码调整，把原本的几千行`Cython`给优化了，出了一个简化的C语言版，并且整理出了核心逻辑，于是我直接看核心加密逻辑，很清晰，然后写解密就出了。\n\n```python\nhack_data = [27, 16, 43, 29, 127, 46, 51, 102, 50, 1, 112, 50, 53, 101, 57, 1] \nkey = 'H1m' sbox = [1, 14, 4, 13, 10, 2, 5, 8, 7, 6, 9, 12, 15, 3, 11, 0]  \nflag_list = [0] * 16  \nfor i in range(len(sbox)):\n    tmp = hack_data[i] ^ ord(key[i % len(key)])\n    flag_list[sbox[i]] = tmp\nfor i in range(len(flag_list)):\n    print(chr(flag_list[i]), end='')\n```\n\n------\n\n\n\n# MIPS\n\n> ​\t一种新的指令集，对应的汇编语言也不一样，需要重新学习。\n\n​\t单独出一个wp来记录学习过程中得到的知识。\n\n------\n\n\n\n\n\n# 桀桀桀\n\n> ​\t`rep stosd是一条高效的字符串操作指令，适用于快速初始化或填充内存区域，edi保存填充地址，ecx保存填充次数，eax保存单次填充值。`\n>\n> ​\t这一题很有意思啊，有花指令、TLS、伪随机数和魔改tea，有很多可学的点，在做题的时候，由于对花指令的不够全面的了解，和对TLS的不全面了解，导致我一直困在对非核心部分的探索学习中，始终未能抓住主要逻辑，最后导致身心疲惫。\n>\n> ​\t于是决定参照WP和网上的资料，好好恶补一下这些方面的知识，并且记录下来。\n\n```python\nfor i in range(0x4119E2, 0x4119E7):\t\t#IDA的patch脚本，记住使用到的函数名就好。\n    idc.patch_byte(i, 0x90)\n```\n\n专门出一个WP，记录一下这些难题。\n\n------\n\n\n\n# 嘿嘿嘿\n\n​\t无壳，验证长度32位，然后进入140001850，有SMC保护技术，我们修改标志位绕过反调试，\n\n![image-20250521110206759](/pictures/ISCTF2024/image-20250521110206759.png)\n\n![image-20250521110250703](/pictures/ISCTF2024/image-20250521110250703.png)\n\n​\t这里也没有调用，我们先不用管140001A0函数，继续去main函数中看程序逻辑。看到1400017B0函数，马上就调用了解密出的函数，参数分别是字符串\"Welcome_to_ISCTF\"，还有两个空数组。\n\n![image-20250521110613803](/pictures/ISCTF2024/image-20250521110613803.png)\n\n​\t先看140001440，对字符串进行异或，存储到a2中，140003270数据可以直接看到。这里需要注意的是，在IDA中数据以小端保存，尽管字符串显示的顺序是“Welcome_to_ISCTF”，但在栈帧中保存的顺序其实是cleW......，需要每4个字节逆序，这样才是a1[i]的值。\n\n![image-20250521110827346](/pictures/ISCTF2024/image-20250521110827346.png)\n\n![image-20250521110918291](/pictures/ISCTF2024/image-20250521110918291.png)\n\n​\t接着进入1400014A0函数，a1是空数组，a2是才加密的中间密钥的指针。如果只是出flag的话，这里没有必要深入分析了，直接取最终密钥就行了。\n\n![image-20250521104520689](/pictures/ISCTF2024/image-20250521104520689.png)\n\n​\t回到主函数，1400017B0函数才是加密的地方，继续看140001630，由于是对明文进行了分块的，分成2个16字节加密的。\n\n![image-20250521113825145](/pictures/ISCTF2024/image-20250521113825145.png)\n\n​\t里面两个函数，一个加密，一个逆序复制。\n\n![image-20250521112328705](/pictures/ISCTF2024/image-20250521112328705.png)\n\n​\t加密以4字节为一个单位，将16字节分为4个元素，加密32轮，整体加密32/4=8轮。加密方式就是异或1400013F0的返回值。\n\n![image-20250521112403260](/pictures/ISCTF2024/image-20250521112403260.png)\n\n​\t\ta2确定是1。a1是那群异或得到的值。\n\n![image-20250521113204681](/pictures/ISCTF2024/image-20250521113204681.png)\n\n​\t这里有一个映射表，256字节。\n\n![image-20250521113218351](/pictures/ISCTF2024/image-20250521113218351.png)\n\n​\t映射后的值为a1.\n\n![image-20250521113233640](/pictures/ISCTF2024/image-20250521113233640.png)\n\n​\t这里其实是一种扩展的左移并记录溢出位的操作。\n\n![image-20250521113401853](/pictures/ISCTF2024/image-20250521113401853.png)\n\n再看这个函数，以4字节为整体进行逆序，因为每次加密只有16字节参与，所以只需要移动4次。\n\n![image-20250521113539461](/pictures/ISCTF2024/image-20250521113539461.png)\n\n看回主函数，通过调试确定，比对的时候密文端序不变，解密脚本中就直接使用数据。\n\n![image-20250521113646251](/pictures/ISCTF2024/image-20250521113646251.png)\n\n最后完全不看WP，自己写出来了，Exp如下。花了4个小时吧。\n\n```c\n#include <stdio.h>\n#include <stdlib.h> \n#include <stdint.h>\n\n//密钥在动调的时候取出就行了。\nuint8_t key[128] = {64, 219, 65, 24, 40, 193, 230, 145, 203, 169, 18, 125, 170, 192, 199, 159, 157, 38, 46, 6, 157, 90, 123, 166, 146, 16, 175, 171, 169, 249, 251, 160, 135, 168, 171, 240, 25, 222, 93, 91, 231, 26, 172, 17, 30, 69, 73, 82, 201, 42, 246, 134, 66, 49, 108, 95, 150, 236, 129, 102, 94, 24, 255, 27, 69, 188, 182, 179, 250, 225, 54, 233, 113, 90, 12, 164, 92, 131, 61, 232, 59, 85, 99, 174, 230, 155, 235, 1, 32, 36, 55, 178, 65, 89, 177, 99, 76, 98, 54, 100, 188, 139, 221, 165, 68, 157, 191, 115, 242, 75, 56, 38, 65, 13, 123, 99, 220, 204, 61, 124, 51, 252, 15, 10, 176, 107, 255, 109};\n\n\n//取出就行了。\nuint8_t map[256] = {214, 144, 233, 254, 204, 225, 61, 183, 22, 182, 20, 194, 40, 251, 44, 5, 43, 103, 154, 118, 42, 190, 4, 195, 170, 68, 19, 38, 73, 134, 6, 153, 156, 66, 80, 244, 145, 239, 152, 122, 51, 84, 11, 67, 237, 207, 172, 98, 228, 179, 28, 169, 201, 8, 232, 149, 128, 223, 148, 250, 117, 143, 63, 166, 71, 7, 167, 252, 243, 115, 23, 186, 131, 89, 60, 25, 230, 133, 79, 168, 104, 107, 129, 178, 113, 100, 218, 139, 248, 235, 15, 75, 112, 86, 157, 53, 30, 36, 14, 94, 99, 88, 209, 162, 37, 34, 124, 59, 1, 33, 120, 135, 212, 0, 70, 87, 159, 211, 39, 82, 76, 54, 2, 231, 160, 196, 200, 158, 234, 191, 138, 210, 64, 199, 56, 181, 163, 247, 242, 206, 249, 97, 21, 161, 224, 174, 93, 164, 155, 52, 26, 85, 173, 147, 50, 48, 245, 140, 177, 227, 29, 246, 226, 46, 130, 102, 202, 96, 192, 41, 35, 171, 13, 83, 78, 111, 213, 219, 55, 69, 222, 253, 142, 47, 3, 255, 106, 114, 109, 108, 91, 81, 141, 27, 175, 146, 187, 221, 188, 127, 17, 217, 92, 65, 31, 16, 90, 216, 10, 193, 49, 136, 165, 205, 123, 189, 45, 116, 208, 18, 184, 229, 180, 176, 137, 105, 151, 74, 12, 150, 119, 126, 101, 185, 241, 9, 197, 110, 198, 132, 24, 240, 125, 236, 58, 220, 77, 32, 121, 238, 95, 62, 215, 203, 57, 72};\n\n\nuint32_t sub_1400012F0(uint32_t a1, int16_t a2){\n    for(int16_t i=0;i<a2;i++){\n        a1 = a1 / 0x80000000 + 2 * a1;\n    }\n    return a1;\n}\n\nuint32_t sub_140001340(uint32_t a1){\n    return sub_1400012F0(a1,24) ^ sub_1400012F0(a1, 18) ^ sub_1400012F0(a1, 10) ^ sub_1400012F0(a1, 2) ^ a1;\n}\n\n//完全照抄加密时的逻辑就行，这里是求异或值的地方，我们的目标是要找出一样的异或值，所以要和加密时的逻辑一样。\nuint32_t get_xor(uint32_t seed){\n    uint32_t t = map[(uint8_t)seed] + (map[(uint8_t)(seed>>8)] << 8) + (map[(uint8_t)(seed>>16)] << 16) + (map[(uint8_t)(seed>>24)] << 24);\n    return sub_140001340(t);\n\n}\n\n\n//仿照加密过程，其实就是一个异或操作，只是这个异或的密钥经过复杂的运算得出的\nvoid  decrypt(uint32_t *enc, uint8_t *key){\n    uint32_t *k = (uint32_t*)key;\n    for(int i=31;i>=0;i--){\n        enc[i%4] ^= get_xor(k[i] ^ enc[(i+3)%4] ^ enc[(i+2)%4] ^ enc[(i+1)%4]);\n    }\n}\n\n\nint main(){\n    \n    //密文最好是调试的时候看，断点下在比较的地方。\n    uint32_t enc[] = \t\t\t\t{0xA8F44759,0xCDB824F2,0x32FB3C01,0x42BEFFE1,0x3EC30B40,0xE094AA46,0x2AEA2B,0x362C0888};\n    uint32_t enc1[8];\n    \n    \n    for(int i=0;i<8;i++){\n        int j = i % 4;\n        enc1[i] = enc[(i/4)*4 + (3-j)];\n    }\n\n    for(int i=0;i<2;i++){\n        decrypt(enc1+i*4,key);\n    }\n\n    for(int i=0;i<8;i++){\t\t\t\t\t//这里开始是反的，还搞错了。字符串的大小端总是让我摸不着头脑。\n        printf(\"%c\",enc1[i]&0xFF);\n        printf(\"%c\",enc1[i]>>8&0xFF);\n        printf(\"%c\",enc1[i]>>16&0xFF);\n        printf(\"%c\",enc1[i]>>24&0xFF);\n    }\n\n    return 0;\n}\n```\n\n------\n\n# 萝卜子的螃蟹\n\n​\t\tRUST语言程序，可以使用IDA反编译打开，难点就是反编译代码很难看，需要配合动调确定程序的运行逻辑。有点累了，改天再写。\n\n​\t动调还是经验太少了，趁此机会，好好照着WP学习一下动调的经验。下面只总结了收获的经验，完整WP都有。\n\n\n\n- #### 通过提示字符串的交叉引用找到程序的主要逻辑函数。\n\n- #### 看到如下图所示的这种乱七八糟的函数名，看到如此难以读懂的伪代码，先单步调试找到input函数。并且，根据input函数中的参数值，找到存储输入flag的地址。参数是指针，要通过G键跳转到对应的内存地址处查看。\n\n![image-20250522122253781](/pictures/ISCTF2024/image-20250522122253781.png)\n\n- #### 找到INPUT之后，再酌情分析程序还有哪些重要部分。然后忽略其他操作，除开与输入flag相关的部分，其他都可以不管，需要什么可以靠动调直接读取值。\n\n- #### 看到长度比较和赋值部分，这一大堆数据很可能就是密文，但是不能着急，密文也是可以做处理的，不到最后比对的时候都不要完全确定密文。\n\n![image-20250522122710905](/pictures/ISCTF2024/image-20250522122710905.png)\n\n- #### 看到下面前两个函数都是对密文进行操作，v35->v40->v36，不用管。我们只需要锁定住我们的输入即可，v29就是输入字符串的指针，我们看到v29只在405F80参数处出现了，而且下面就是比对了。所以该题应该只在这个函数里面进行了处理。\n\n![image-20250522122830052](/pictures/ISCTF2024/image-20250522122830052.png)\n\n- #### 下面的比对操作，需要简单跟踪变量值确定变量代表的含义，在进入406AA0时下断点取出密文值即可。\n\n![image-20250522123228352](/pictures/ISCTF2024/image-20250522123228352.png)\n\n- #### 重点是怎么知道对输入的操作是什么样子的，在上面的v29处找到输入的flag，打下内存断点，这样每当程序去访问这个地址时就会触发断点，分别我们分析程序对flag做了什么处理。具体操作就是在数据头摁下F2下断点，然后填下数据长度就行。\n\n![image-20250522123655696](/pictures/ISCTF2024/image-20250522123655696.png)\n\n- #### 之后就可以看情况F9策马奔腾了，注意ntdll有时候回访问这个内存地址的，我们可以通过查看断点表，随时开启或关闭断点，记得配合程序断点，关闭内存断点，直接F9来跳过ntdll的访问，我们只关心主要逻辑对该地址的访问。跳出ntdll后，再开启内存断点。\n\n![image-20250522123845878](/pictures/ISCTF2024/image-20250522123845878.png)\n\n![image-20250522123934610](/pictures/ISCTF2024/image-20250522123934610.png)\n\n\n\n​\t最后复现WP，自己手动找到数据，解密成功。\n\n​\t通过本题，我学习到了内存断点找加密操作的方法，发现了通过G键进行内存跳转的功能。\n\n```python\ndata = \"A\" * 52\nenc_data = [105, 170, 63, 98, 219, 177, 5, 252, 176, 134, 189, 146, 177, 222, 70, 219, 183, 31, 150, 151, 6, 229, 101, 231, 47, 223, 159, 159, 159, 228, 116, 102, 218, 205, 139, 51, 99, 178, 172, 136, 66, 138, 47, 12, 150, 246, 201, 34, 207, 27, 86, 152]\n\nxor_key = []\nfor i in range(52):\n    xor_key.append(enc_data[i] ^ ord(data[i]))\n\n\nenc_flag =[97, 184, 61, 119, 220, 139, 54, 200, 130, 179, 163, 226, 196, 192, 106, 255, 155, 110, 165, 175, 20, 197, 66, 195, 49, 242, 191, 144, 185, 250, 19, 1, 196, 245, 165, 7, 125, 179, 159, 172, 92, 140, 94, 34, 179, 232, 200, 60, 220, 57, 35, 164]\nflag = \"\"\n\nfor i in range(52):\n    flag += chr(enc_flag[i] ^ xor_key[i])\n\nprint(flag)\n```\n","tags":["复现WP","Reverse"],"categories":["CTF"]},{"title":"BaseCTF2024","url":"/2025/06/04/BaseCTF/BaseCTF2024_RE/","content":"\n\n\n------\n\n> **UPX mimi：**\n>\n> ​\t初步接触到了UPX加壳保护的知识和对应的脱壳工具，这是一种“压缩”保护壳，即将源程序代码进行压缩，然后配上解压缩代码，组成新的程序，即“UPX解压代码”+“压缩的源文件”。在程序启动时，会先执行UPX的解压代码，得到解压后的源文件，然后将控制流转移到源文件。\n\n> **ez_maze:**\n>\n> ​\t最基础的迷宫题目，从IDA中可以直接看到迷宫，人工就能得到路径。\n\n> **BasePlus:**\n>\n> ​\t无保护，直接拖入IDA，考察基础的阅读代码的能力，加密函数为Base64的一点点变化，对Base64加密后继续异或一下。很基础。第一次认真搓Base64的c语言代码，收获不少。\n\n> **Ez_Xor:**\n>\n> ​\t复习了大小端序的知识。\n>\n> ​\t“小端序”：低位有效字节保存在小地址。如0xDEADBEEF在内存中的顺序是（小地址）EF BE AD DE（大地址）。“大端序”相反。\n>\n> ​\t本题就是简单的流加密，生成密钥流然后加密。对应解密即可。\n\n> **UPX:**\n>\n> ​\t有壳，直接脱壳报错。学习到了，改标志位来保护加壳程序的手段，我们的反制操作就是打开文件，将对应的标志位从小写改回大写。之后就可以正常脱壳了。\n>\n> ​\t拖入IDA后，考察的是换表的Base64。唯一需要注意的点就是因为题目源码是C语言，在IDA字符串显示中给双引号全面加了转义符号的，不要搞错了。\n\n![image-20250425170632940](/pictures/BaseCTF2024/image-20250425170632940.png)\n\n> **lk:**\n>\n> ​\t比较大的线性方程组，考察python的z3solver库使用。\n\n> **喝杯下午茶：**\n>\n> ​\t标准的Tea加密，第一次使用C语言实现了该算法，收获不少。\n\n> **Ezpy:**\n>\n> ​\t考察python打包出的EXE程序。反编译出源码。\n>\n> ​\t再考察RC4加密。\n\n> **最简单的编码：**\n>\n> ​\t无保护技术，纯考验伪代码的阅读水平，耐下心来分析就好了。\n\n> **neuro爱数学：**\n>\n> ​\t\n\n> **RivestCipher:**\n>\n> ​\t考察标准RC4加密算法。\n\n> **ezAndroid:**\n>\n> ​\t收获到了逆向apk安装包的软件jadx，接触到了so文件（共享库）逆向，是一些没有接触过的操作。又要读奇怪的代码。唉！\n\n------\n\n# **UPX PRO MAX**\t\n\n​\t直接运行EXE程序，会出现下图的显示。\n\n![image-20250506132159230](/pictures/BaseCTF2024/image-20250506132159230.png)\n\nDIE也看到UPX壳。\n\n![image-20250506132311405](/pictures/BaseCTF2024/image-20250506132311405.png)\n\n直接上工具是不行的啊，报错了。\n\n跟着WP学习——**利用ESP定律x64dbg手脱UPX壳**。\n\n> “ESP定律”也称“堆栈平衡定律”\n>\n> 由于在程序自解密或者自解压过程中, 多数壳会先将当前寄存器状态压栈, 如使用`pushad`, 而在解压结束后, 会将之前的寄存器值出栈, 如使用`popad`. 因此在寄存器出栈时, 往往程序代码被恢复, 此时硬件断点触发（这就是我们要下硬件断点的原因），然后在程序当前位置, 只需要一些单步操作, 就会到达正确的OEP位置。\n>\n> 1. 程序刚载入开始 `pushad/pushfd`\n> 2. 将全部寄存器压栈后就设对 ESP 寄存器设硬件断点\n> 3. 运行程序, 触发断点\n> 4. 删除硬件断点开始分析\n\n在x64dbg中，F9两次后来到这个压栈的操作处。接着单步运行一次，看到ESP的值为红色，代表其值被修改了，我们右键选择“在内存窗口中转到”，然后在栈中打下硬件断点。\n\n![image-20250506133643545](/pictures/BaseCTF2024/image-20250506133643545.png)\n\n![image-20250506134057787](/pictures/BaseCTF2024/image-20250506134057787.png)\n\n![image-20250506134312068](/pictures/BaseCTF2024/image-20250506134312068.png)\n\n之后F9，触发断点后单步运行几下就找到OEP了，即程序入口点。可以看到这个地方的多次pop指令。\n\n根据wp中的提示，0X41CF65跳转的地方就是程序的入口点了。应该是了。\n\n![image-20250506134519180](/pictures/BaseCTF2024/image-20250506134519180.png)\n\n下面根据WP中的操作介绍一步步就可以脱出无壳的程序了，叫UPX_PRO_MAX_dump_SCY.exe。\n\n> `scylla`插件：在 x64dbg 中内置的 Scylla 插件可用于 dump 进程，**即将内存中的程序数据转储到磁盘上**，形成一个可执行文件的副本，方便后续对程序的分析和研究。\n>\n> `IAT AutoSearch`： 在分析经过加壳或加密的程序时，程序的导入表可能被破坏或隐藏，IAT AutoSearch 可以自动扫描内存或代码段，寻找可能的导入函数地址，帮助逆向工程师快速找到程序所调用的外部函数。\n\n> 程序的导入表是程序的关键数据结构，用于列出程序运行时需要从其他模块（通常是 DLL）中导入的函数和变量。以下是导入表的详细介绍：\n>\n>   * 导入表是程序的一个数据结构，它包含了一系列的引用信息，指向程序运行时需要调用的外部函数和变量所在的模块及其具体地址。\n>\n> \n>\n>   * **便于调用外部模块功能** ：程序通常不会将所有功能都自己实现，而是通过调用系统或第三方提供的 DLL 中的函数和变量来实现复杂的功能。导入表就像一个目录，告诉操作系统程序需要从哪些 DLL 中使用哪些功能。\n>   * **便于程序的动态链接** ：它支持程序的动态链接机制。程序在编译时不会直接将 DLL 中的函数和变量代码包含进来，而是在运行时装载所需的 DLL，并通过导入表找到具体的函数和变量地址，这样可以减少程序自身的体积，同时方便对 DLL 进行更新和共享。\n>\n> \n>\n>   * **导入模块名表** ：存放了程序需要导入的各个模块的名字，比如 “kernel32.dll”“user32.dll” 等。\n>   * **导入函数名表** ：对于每个导入模块，都有一个对应的导入函数名表，列出了从该模块中导入的具体函数名称，如 “MessageBoxA”“CreateFileA” 等。\n>   * **导入函数地址表（IAT）** ：在程序运行时，操作系统会将每个导入函数的实际内存地址填入这个表中，程序通过这个表中的地址来调用相应的函数。\n\n脱壳后的程序导入IDA中，很清晰的加密逻辑。直接逆向写脚本就行。\n\n![image-20250506141212651](/pictures/BaseCTF2024/image-20250506141212651.png)\n\n但是这里出现了一个坑：`sub_401550`函数其实就是一些加密字符串移动操作，分成几部分存储在几个变量中。但是在验证函数中，全程只用到了a1和a2部分，也就是sub_401550中的a2和a3，不是完整的密文，我觉得这里是中间出了问题，而且这个提取出来的exe程序无法正常运行，IDA中也调试不行，只能静态分析。所以还是有点不靠谱的东西存在。\n\n![image-20250506142108769](/pictures/BaseCTF2024/image-20250506142108769.png)\n\n![image-20250506141429954](/pictures/BaseCTF2024/image-20250506141429954.png)\n\n------\n\n# EZ_VM\n\n​\t基本信息：`pyinstaller`打包的`ELF64`位程序，使用`pydumpck`解包得到`py`文件。\n\n​\t加密逻辑在`what.py`文件，打开，里面函数名称和变量名都是用数字代替的，还有一些小错误，比如本来的“while”语句变成“if”，需要改过来。\n\n​\t代码的逻辑就是：分别使用一个数组变量和一个字典来模拟一个栈和内存，使用变量模拟寄存器，通过数组的`pop`和`push`模拟栈的操作，使用函数定义各种汇编指令，如push、pop、add、sub等等，都是统一操作数长度。就这样定义了一个能够通过汇编指令进行运行的“虚拟机”，里面存在出题人预先写好的一段静态汇编代码，作为加密函数。\n\n> 1. 我们首要任务就是给源python代码进行重命名和明显的错误纠正。（需要足够熟悉汇编指令，起码的要知道。转移指令还没那么重要，因为我们不关心程序的执行流程，我们只需要注意密文的来处即可。）\n> 2. 然后在其中插入print调试语句输出操作指令、栈和内存的值，锁定密文的存储地方，观察加密方法。\n> 3. 根据加密方法写逆向脚本。\n\n​\t\n\n```python\nenc_flag = [\n    35,\n    18,\n    22,\n    38,\n    23,\n    18,\n    61,\n    25,\n    83,\n    4,\n    0,\n    5,\n    5,\n    83,\n    95,\n    20,\n    29,\n    83,\n    82,\n    1,\n    29,\n    25,\n    0,\n    0,\n    81,\n    72,\n    76,\n    85,\n    3,\n    85,\n    79,\n    73,\n    83,\n    0,\n    15,\n    9,\n    85,\n    7,\n    80,\n    82,\n    0,\n    5,\n    84,\n    77,\n    130]\n\n\nclass Opcode:\n    vm_push = 240\n    vm_pop = 241\n    vm_and = 242\n    vm_or = 243\n    vm_not = 244\n    vm_xor = 245\n    vm_jmp = 246\n    vm_jz = 247\n    vm_label = 248\n    vm_strlen = 249\n    vm_loadchar = 250\n    vm_store = 251\n    vm_load = 252\n    vm_add = 253\n    vm_sub = 254\n\n\nclass VM:\n\n    def __init__(self):\n        self.stack = []\n        self.bytecode = []\n        self.pc = 0\n        self.labels = {}\n        self.memory = {}\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if not self.stack:\n            raise IndexError('something wrong..')\n        return self.stack.pop()\n\n    def _scan_labels(self):\n        labels = {}\n        pc = 0\n        while pc < len(self.bytecode):\n            if self.bytecode[pc] == Opcode.vm_label:\n                label_name = self.bytecode[pc + 1]\n                labels[label_name] = pc\n                pc += 2\n            else:\n                pc += 1\n\n        return labels\n\n    def vm_and(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b & a)\n\n    def vm_or(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b | a)\n\n    def vm_not(self):\n        b = self.pop()\n        self.push(~b)\n\n    def vm_xor(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b ^ a)\n\n    def vm_jmp(self):\n        label_name = self.bytecode[self.pc]\n        self.pc = self.labels[label_name]\n\n    def vm_jz(self):\n        label_name = self.bytecode[self.pc]\n        self.pc += 1\n        a = self.pop()\n        b = self.pop()\n        if a == b:\n            self.pc = self.labels[label_name]\n\n    def vm_strlen(self):\n        string = self.pop()\n        self.push(len(string))\n\n    def vm_loadchar(self):\n        string = self.pop()\n        index = self.pop()\n        self.push(ord(string[index]))\n\n    def vm_store(self):\n        value = self.pop()\n        key = self.bytecode[self.pc]\n        if key == 'r':\n            if key not in self.memory:\n                self.memory[key] = []\n            self.memory[key].append(value)\n        else:\n            self.memory[key] = value\n        self.pc += 1\n\n    def vm_load(self):\n        key = self.bytecode[self.pc]\n        self.push(self.memory[key])\n        self.pc += 1\n\n    def vm_add(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b + a)\n\n    def vm_sub(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b - a)\n\n    def run(self, bytecode):\n        self.bytecode = bytecode\n        self.pc = 0\n        self.labels = self._scan_labels()\n        while self.pc < len(self.bytecode):\n            opcode = self.bytecode[self.pc]\n            self.pc += 1\n            if opcode == Opcode.vm_push:\n                value = self.bytecode[self.pc]\n                self.pc += 1\n                self.push(value)\n            elif opcode == Opcode.vm_pop:\n                self.pop()\n            elif opcode == Opcode.vm_and:\n                self.vm_and()\n            elif opcode == Opcode.vm_or:\n                self.vm_or()\n            elif opcode == Opcode.vm_not:\n                self.vm_not()\n            elif opcode == Opcode.vm_xor:\n                self.vm_xor()\n            elif opcode == Opcode.vm_jmp:\n                self.vm_jmp()\n            elif opcode == Opcode.vm_jz:\n                self.vm_jz()\n            elif opcode == Opcode.vm_label:\n                self.pc += 1\n            elif opcode == Opcode.vm_strlen:\n                self.vm_strlen()\n            elif opcode == Opcode.vm_loadchar:\n                self.vm_loadchar()\n            elif opcode == Opcode.vm_store:\n                self.vm_store()\n            elif opcode == Opcode.vm_load:\n                self.vm_load()\n            elif opcode == Opcode.vm_add:\n                self.vm_add()\n            elif opcode == Opcode.vm_sub:\n                self.vm_sub()\n            else:\n                raise ValueError('something wrong')\n            print(f\"pc: {self.pc}| opcode: {get_opcode_name(opcode)}, stack: {self.stack}, memory: {self.memory}\")\n\n    def encrypt(self, serial):\n        bytecode = [\n            Opcode.vm_push, serial,\n            Opcode.vm_strlen,\n            Opcode.vm_store, 'l1',\n            Opcode.vm_push, 0,\n            Opcode.vm_store, 'i',\n            Opcode.vm_label, 's',\n            Opcode.vm_load, 'l1',\n            Opcode.vm_push, 1,\n            Opcode.vm_sub,\n            Opcode.vm_load, 'i',\n            Opcode.vm_jz, 'e',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, 1,\n            Opcode.vm_add,\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_xor,\n            Opcode.vm_store, 'r',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, 1,\n            Opcode.vm_add,\n            Opcode.vm_store, 'i',\n            Opcode.vm_jmp, 's',\n            Opcode.vm_label, 'e',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_push, 255,\n            Opcode.vm_xor,\n            Opcode.vm_store, 'r'\n        ]\n        self.run(bytecode)\n        enc = self.memory['r']\n        return enc\n\ndef get_opcode_name(opcode):\n    for name, value in Opcode.__dict__.items():\n        if value == opcode:\n            return name\n    return None\n\nvm = VM()\ntest_flag = \"BaseCTF{VM_is_awesome}\"\nenc = vm.encrypt(test_flag)\nprint(f\"encrypted test_flag: {enc}\")\nprint(f\"original flag: {enc_flag}\")\n```\n\n根据WP提示重命名后，观察传输的调试信息。看一下开头和结尾就行。\n\n![image-20250509160138052](/pictures/BaseCTF2024/image-20250509160138052.png)\n\n![image-20250509160305470](/pictures/BaseCTF2024/image-20250509160305470.png)\n\n​\t所以猜到加密逻辑是：从前往后，相邻两位异或，尾部和255异或。\n\n这里给出我的解密脚本。\n\n```python\nenc_flag = [35, 18, 22, 38, 23,  18,61, 25,  83,4,0, 5, 5,83,95,  20,  29, 83,82,  1, 29, 25, 0,0,81,72,76,85,3,85,79,73,83,0,15,9,85,7,80,82,0,5,84,77,130,255]\n\nflag = \"\"\nfor i in range(len(enc_flag)):\n    char = enc_flag[i]\n    for j in range(i+1, len(enc_flag)):\n        char = char ^ enc_flag[j]\n\n    flag += chr(char)\n\nprint(flag)\n```\n\n------\n\n# Microgame\n\n​\t不理解，不会游戏逆向，后面得学啊。专门做了一个CE的学习。\n\n​\t学习完CE，专门出个WP来做。\n\n------\n\n# neuro爱数学\n\n​\t直接打开IDA看看`main`函数，程序无壳，就是考察数学问题。\n\n![image-20250512120720066](/pictures/BaseCTF2024/image-20250512120720066.png)\n\n![image-20250512130852846](/pictures/BaseCTF2024/image-20250512130852846.png)\n\n![image-20250512130953971](/pictures/BaseCTF2024/image-20250512130953971.png)\n\n```c\n#include<stdio.h>\n#include<stdint.h>\n#include<intrin.h>\n\nint main(){\t\t\t\t\t\t\t\t//注意：各个变量和函数的类型是关键，不能搞错，需要对照IDA伪代码\n    int64_t v5=0x400C0210000001;\t\t\t//这个值是固定的，但是需要动调程序得到这个值。\n\n    for(int i=-60; i<=59; i++){\n        if(i == 44 || i == 58){\n            printf(\"符合条件的i值位：%d/n\", i);\n            continue;\n        }\n\n        unsigned int v12 = (unsigned int)(i + 37);\n        if(v12 <= 54 && _bittest64((int64_t*)&v5,(unsigned int)v12) != 0){\n            printf(\"符合条件的i值为：%d/n\", i);\n        }\n\n    }\n\n    return 0;\n}\n\n```\n\n![image-20250512131328904](/pictures/BaseCTF2024/image-20250512131328904.png)\n\n然后使用python脚本展开多项式得到系数。\n\n````python\nfrom sympy import symbols, expand\n\n# 定义符号变量\nx = symbols('x')\n\n# 构造多项式\npolynomial = (x - 44) * (x - 58) * (x - 5) * (x + 37) * (x - 17) * (x + 9) * (x - 6) * (x + 4)\n\n# 展开多项式\nexpanded_polynomial = expand(polynomial)\n\n# 提取并打印系数\nstandard_form = expanded_polynomial.as_poly()  # 获取标准形式的多项式\ncoefficients = standard_form.all_coeffs()    # 获取所有系数\n\n# 打印系数逆序（从常数项到最高次项）。因为正常是从高次项到低次项。\nprint(coefficients[::-1])\n#[-1733624640, 134045088, 122783468, -12168520, -1364231, 121272, -358, -80, 1]\n````\n\n![测试图片](/pictures/BaseCTF2024/image-20250512131708984.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["复现WP","Reverse"],"categories":["CTF"]},{"title":"分类","url":"/categories/index.html"},{"title":"关于","url":"/about/index.html","content":"\n\n\n"},{"title":"友情链接","url":"/link/index.html"},{"title":"标签","url":"/tags/index.html"},{"url":"/json/music.json","content":"[\n  {\n    \"name\": \"青花瓷\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"\n  },\n  {\n    \"name\": \"稻香\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"\n  },\n  {\n    \"name\": \"晴天\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"\n  },\n  {\n    \"name\": \"七里香\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"\n  },\n  {\n    \"name\": \"花海\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"\n  },\n  {\n    \"name\": \"反方向的钟\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"\n  },\n  {\n    \"name\": \"兰亭序\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"\n  },\n  {\n    \"name\": \"说好的辛福呢\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"\n  },\n  {\n    \"name\": \"等你下课 (with 杨瑞代)\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"\n  },\n  {\n    \"name\": \"我落泪情绪零碎\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"\n  },\n  {\n    \"name\": \"听妈妈的话\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"\n  },\n  {\n    \"name\": \"明明就\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"\n  },\n  {\n    \"name\": \"我是如此相信\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"\n  },\n  {\n    \"name\": \"发如雪\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"\n  },\n  {\n    \"name\": \"以父之名\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"\n  },\n  {\n    \"name\": \"园游会\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"\n  },\n  {\n    \"name\": \"本草纲目\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"\n  },\n  {\n    \"name\": \"龙卷风\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"\n  }\n]"},{"url":"/static/css/index_media.css","content":"/* index ，主页面动画*/\n\n  #home-media-container {\n    position: fixed; /* 改为固定定位 */\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    z-index: 0;\n    \n    /* 添加底部向上渐变遮罩 */\n    -webkit-mask-image: linear-gradient(to top, transparent 0%, black 0%);\n    mask-image: linear-gradient(to top, transparent 0%, black 0%);\n  }\n  \n  .home-media {\n    position: fixed; /* 同步改为固定定位 */\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n    \n    /* 添加透明度过渡 */\n    transition: opacity 0.5s ease;\n    opacity: 1;\n  }\n  \n    /* 自定义加载动画容器 */\n  .custom-loader {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    z-index: 10; /* 确保在视频上方 */\n    pointer-events: none; /* 防止阻挡视频交互 */\n    transition: opacity 0.5s ease; /* 淡出动画 */\n  }\n\n  /* 加载动画元素 */\n  .loader-animation {\n    width: 18%;\n    height: 18%;\n    min-width: 128px;\n    min-height: 128px;\n    background-size: contain; /* 保持比例 */\n    background-position: center;\n    background-repeat: no-repeat;\n    animation: pulse 1.5s infinite ease-in-out;\n  }\n\n  /* 呼吸动画效果 */\n  @keyframes pulse {\n    0% { transform: scale(1); opacity: 0.8; }\n    50% { transform: scale(1.1); opacity: 1; }\n    100% { transform: scale(1); opacity: 0.8; }\n  }\n"},{"title":"音乐馆","url":"/music/index.html"},{"url":"/static/js/index_media.js","content":"// ======================= 横竖屏自适应背景媒体加载器 =======================\nlet lastOrientation = null; // 记录上一次的方向状态\n\n// ================= 新增滚动渐变效果函数 =================\nfunction initScrollFadeEffect() {\n  const mediaContainer = document.getElementById('home-media-container');\n  if (!mediaContainer) return;\n  \n  const mediaElement = mediaContainer.querySelector('.home-media');\n  if (!mediaElement) return;\n  \n  // 节流函数优化性能\n  function throttle(func, limit) {\n    let lastFunc, lastRan;\n    return function() {\n      const context = this;\n      const args = arguments;\n      if (!lastRan) {\n        func.apply(context, args);\n        lastRan = Date.now();\n      } else {\n        clearTimeout(lastFunc);\n        lastFunc = setTimeout(function() {\n          if ((Date.now() - lastRan) >= limit) {\n            func.apply(context, args);\n            lastRan = Date.now();\n          }\n        }, limit - (Date.now() - lastRan));\n      }\n    }\n  }\n\n  // 处理滚动时的透明度变化\n  function handleScrollFade() {\n    const scrollY = window.scrollY;\n    const windowHeight = window.innerHeight;\n    \n    // 计算透明度：从1（完全不透明）到0（完全透明）\n    // 当滚动到一屏高度时，透明度变为0\n    let opacity = 1 - (scrollY / windowHeight);\n    opacity = Math.max(0, Math.min(1, opacity)); // 限制在0-1范围\n    \n    mediaElement.style.opacity = opacity;\n  }\n\n  // 节流处理滚动事件（每50ms检查一次）\n  const throttledScrollHandler = throttle(handleScrollFade, 50);\n  \n  // 添加滚动监听\n  window.addEventListener('scroll', throttledScrollHandler);\n  \n  // 初始化时执行一次\n  handleScrollFade();\n  \n  // 存储当前滚动处理器以便后续移除\n  return throttledScrollHandler;\n}\n\n\n// ================= 滚动渐变效果函数结束 =================\n\n// ================= 新增底部遮罩层控制函数 =================\nfunction initScrollMaskEffect() {\n  const mediaContainer = document.getElementById('home-media-container');\n  if (!mediaContainer) return;\n  \n  // 节流函数优化性能\n  function throttle(func, limit) {\n    let lastFunc, lastRan;\n    return function() {\n      const context = this;\n      const args = arguments;\n      if (!lastRan) {\n        func.apply(context, args);\n        lastRan = Date.now();\n      } else {\n        clearTimeout(lastFunc);\n        lastFunc = setTimeout(function() {\n          if ((Date.now() - lastRan) >= limit) {\n            func.apply(context, args);\n            lastRan = Date.now();\n          }\n        }, limit - (Date.now() - lastRan));\n      }\n    }\n  }\n\n  // 处理滚动时的遮罩变化\n  function handleScrollMask() {\n    const scrollY = window.scrollY;\n    const windowHeight = window.innerHeight;\n    \n    // 计算遮罩高度（0-100%）\n    let maskHeight = (scrollY / windowHeight) * 100;\n    maskHeight = Math.min(100, Math.max(0, maskHeight));\n    \n    // 动态设置遮罩层高度\n    mediaContainer.style.setProperty('--mask-height', `${maskHeight}%`);\n  }\n\n  // 节流处理滚动事件（每50ms检查一次）\n  const throttledScrollHandler = throttle(handleScrollMask, 50);\n  \n  // 添加滚动监听\n  window.addEventListener('scroll', throttledScrollHandler);\n  \n  // 初始化时执行一次\n  handleScrollMask();\n  \n  // 返回处理器以便后续移除\n  return throttledScrollHandler;\n}\n\n\nfunction initResponsiveBackground() {\n  const mediaContainer = document.getElementById('home-media-container');\n  if (!mediaContainer) {\n    console.error('[背景加载器] 未找到媒体容器元素');\n    return;\n  }\n\n  // 检测当前屏幕方向\n  const currentIsPortrait = window.innerHeight > window.innerWidth;\n  const currentOrientation = currentIsPortrait ? 'portrait' : 'landscape';\n  \n  // 如果方向未改变，则直接返回\n  if (lastOrientation === currentOrientation) {\n    console.log('[背景加载器] 方向未改变，无需重新加载');\n    return;\n  }\n  \n  // 更新方向记录\n  lastOrientation = currentOrientation;\n  console.log(`[背景加载器] 方向变化: ${currentOrientation}`);\n\n  // 清除现有媒体元素和加载动画\n  const existingMedia = mediaContainer.querySelector('.home-media');\n  const existingLoader = mediaContainer.querySelector('.custom-loader');\n  if (existingMedia) existingMedia.remove();\n  if (existingLoader) existingLoader.remove();\n\n  // 根据方向选择资源\n  let mediaSrc, posterSrc, mediaType;\n  if (currentIsPortrait) {\n    mediaSrc = mediaContainer.dataset.portraitVideo || mediaContainer.dataset.portraitImg;\n    posterSrc = mediaContainer.dataset.portraitPoster;\n    mediaType = mediaContainer.dataset.portraitVideo ? 'video' : 'img';\n  } else {\n    mediaSrc = mediaContainer.dataset.landscapeVideo || mediaContainer.dataset.landscapeImg;\n    posterSrc = mediaContainer.dataset.landscapePoster;\n    mediaType = mediaContainer.dataset.landscapeVideo ? 'video' : 'img';\n  }\n\n  if (!mediaSrc) {\n    console.error('[背景加载器] 未找到有效媒体资源');\n    return;\n  }\n\n  console.log(`[背景加载器] 使用资源: ${mediaSrc} (类型: ${mediaType})`);\n\n  // 创建媒体元素\n  const mediaElement = document.createElement(mediaType);\n  mediaElement.className = 'home-media';\n  mediaElement.style.cssText = 'width:100%;height:100%;object-fit:cover';\n  \n  // ================= 设置初始透明度 =================\n  mediaElement.style.opacity = '1';\n  mediaElement.style.transition = 'opacity 0.5s ease';\n  // ================================================\n  \n  // 在媒体容器添加媒体元素后调用效果函数\n  mediaContainer.appendChild(mediaElement);\n  addMediaEffects(mediaElement, mediaType); // 添加新功能\n   \n  console.log('[背景加载器] 媒体元素已创建');\n   \n  // 创建自定义加载动画容器\n  const loaderContainer = document.createElement('div');\n  loaderContainer.className = 'custom-loader';\n  mediaContainer.prepend(loaderContainer);\n  \n  // 创建加载动画元素\n  const loaderElement = document.createElement('div');\n  loaderElement.className = 'loader-animation';\n  \n  // 设置加载动画样式（使用GIF）\n  loaderElement.style.backgroundImage = `url(${posterSrc})`;\n  loaderContainer.appendChild(loaderElement);\n  \n  // 视频特殊处理\n  if (mediaType === 'video') {\n    mediaElement.autoplay = true;\n    mediaElement.muted = true;\n    mediaElement.loop = true;\n    mediaElement.playsInline = true;\n    mediaElement.setAttribute('playsinline', '');\n    mediaElement.setAttribute('webkit-playsinline', '');\n    \n    // 多源支持\n    const source = document.createElement('source');\n    source.src = mediaSrc;\n    source.type = 'video/mp4';\n    mediaElement.appendChild(source);\n    \n    // 处理自动播放限制\n    const playPromise = mediaElement.play();\n    if (playPromise !== undefined) {\n      playPromise.catch(error => {\n        console.warn('[背景加载器] 自动播放被阻止:', error);\n        mediaElement.muted = true;\n        mediaElement.play();\n      });\n    }\n    \n    // 视频加载完成后移除加载动画\n    mediaElement.addEventListener('loadeddata', () => {\n      loaderContainer.style.opacity = '0';\n      setTimeout(() => {\n        if (loaderContainer.parentNode) {\n          loaderContainer.parentNode.removeChild(loaderContainer);\n        }\n      }, 500); // 淡出动画持续时间\n    });\n  } else {\n    mediaElement.src = mediaSrc;\n    mediaElement.loading = 'eager';\n    \n    // 图片加载完成后移除加载动画\n    mediaElement.addEventListener('load', () => {\n      loaderContainer.style.opacity = '0';\n      setTimeout(() => {\n        if (loaderContainer.parentNode) {\n          loaderContainer.parentNode.removeChild(loaderContainer);\n        }\n      }, 500);\n    });\n  }\n\n  // 错误处理\n  mediaElement.onerror = function() {\n    console.error(`[背景加载器] 资源加载失败: ${mediaSrc}`);\n    this.style.display = 'none';\n    \n    // 尝试回退到备用类型\n    console.warn('[背景加载器] 尝试回退到备用媒体');\n    const fallbackType = mediaType === 'video' ? 'img' : 'video';\n    const fallbackSrc = currentIsPortrait ? \n      (mediaContainer.dataset.portraitImg || mediaContainer.dataset.portraitVideo) :\n      (mediaContainer.dataset.landscapeImg || mediaContainer.dataset.landscapeVideo);\n    \n    if (fallbackSrc && fallbackSrc !== mediaSrc) {\n      console.log(`[背景加载器] 使用备用资源: ${fallbackSrc}`);\n      mediaElement.src = fallbackSrc;\n      mediaElement.style.display = 'block';\n    }\n\n    // 4. 增强错误处理（在initResponsiveBackground函数内修改）\n    // 在mediaElement.onerror函数内添加：\n    setTimeout(() => {\n      if (!this.parentNode) {\n        console.warn('[修复] 尝试完全重建');\n        lastOrientation = null;\n        initResponsiveBackground();\n    // ================= 错误重建时重置透明度 =================\n        setTimeout(initScrollFadeEffect, 500);\n      }\n    }, 1000);\n  };\n\n  mediaContainer.appendChild(mediaElement);\n  console.log('[背景加载器] 媒体元素已创建');\n  \n  // ================= 初始化滚动渐变效果 =================\n  initScrollFadeEffect();\n}\n\nfunction addMediaEffects(mediaElement, mediaType) {\n  if (mediaType === 'video') {\n    // 获取当前方向\n    const currentIsPortrait = window.innerHeight > window.innerWidth;\n\n    // 竖屏模式下固定放大105%\n    const baseScale = currentIsPortrait ? 1.05 : 1.2;\n    mediaElement.style.transform = `scale(${baseScale})`;\n    \n    // 检测是否为iOS设备\n    function isIOS() {\n      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n    }\n\n    // 如果是iOS设备，直接禁用所有视差效果\n    if (isIOS()) {\n      console.log('[视差效果] 在iOS设备上，禁用所有视差效果');\n      return; // 直接返回，不初始化任何视差效果\n    }\n    // 1. 添加缩放动画效果\n    mediaElement.style.transform = 'scale(1.2)'; // 初始放大110%\n    mediaElement.style.transition = 'transform 0.5s ease-out';\n    \n    // 在视频加载完成后触发缩放动画\n    mediaElement.addEventListener('loadeddata', () => {\n      // 竖屏模式保持105%缩放，不需要动画\n      if (currentIsPortrait) {\n        mediaElement.style.transform = 'scale(1.05)';\n      } \n      // 横屏模式执行缩放动画到正常大小\n      else {\n        setTimeout(() => {\n          mediaElement.style.transform = 'scale(1)';\n        }, 100);\n      }\n    });\n    \n    // 2. 添加视差效果（鼠标/陀螺仪）\n    const mediaContainer = document.getElementById('page-header');\n    mediaContainer.style.overflow = 'hidden';\n    mediaElement.style.transformOrigin = 'center center';\n    \n    // 视差效果参数\n    const parallaxIntensity = 0.05;\n    const scaleIntensity = 0.05;\n    let isGyroActive = false;\n    \n    // ================= 新增陀螺仪支持 =================\n    // 检测陀螺仪支持\n    function initGyroParallax() {\n      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {\n        // iOS 13+ 需要权限\n        DeviceOrientationEvent.requestPermission()\n          .then(permissionState => {\n            if (permissionState === 'granted') {\n              setupGyroListeners();\n              isGyroActive = true;\n            }\n          })\n          .catch(console.error);\n      } else if ('DeviceOrientationEvent' in window) {\n        // Android和其他支持设备\n        setupGyroListeners();\n        isGyroActive = true;\n      }\n      \n      return isGyroActive;\n    }\n    \n    // 设置陀螺仪监听\n    function setupGyroListeners() {\n      window.addEventListener('deviceorientation', handleOrientation);\n    }\n    \n    // 处理陀螺仪数据\n    function handleOrientation(event) {\n      // 竖屏模式使用105%基础缩放\n      const baseScaleValue = currentIsPortrait ? 1.05 : 1;\n      if (!isGyroActive) return;\n      \n      // 获取陀螺仪数据（beta: 前后倾斜, gamma: 左右倾斜）\n      const beta = event.beta || 0;  // 前后倾斜（-180到180）\n      const gamma = event.gamma || 0; // 左右倾斜（-90到90）\n      \n      // 将角度转换为百分比偏移（归一化处理）\n      const moveX = (gamma / 90) * parallaxIntensity * 100; // -100% 到 100%\n      const moveY = (beta / 180) * parallaxIntensity * 100; \n      \n      // 应用视差效果\n      mediaElement.style.transform = `\n        translate(${moveX}%, ${moveY}%)\n        scale(${baseScaleValue + scaleIntensity})\n      `;\n    }\n    \n    // ================= 鼠标视差效果 =================\n    function initMouseParallax() {\n      mediaContainer.addEventListener('mousemove', (e) => {\n        const rect = mediaContainer.getBoundingClientRect();\n        const x = (e.clientX - rect.left) / rect.width;\n        const y = (e.clientY - rect.top) / rect.height;\n        \n        const moveX = (x - 0.5) * parallaxIntensity * 100;\n        const moveY = (y - 0.5) * parallaxIntensity * 100;\n        \n        mediaElement.style.transform = `\n          translate(${moveX}%, ${moveY}%)\n          scale(${1 + scaleIntensity})\n        `;\n      });\n      \n      mediaContainer.addEventListener('mouseleave', () => {\n        mediaElement.style.transform = 'scale(1)';\n      });\n    }\n    \n    // ================= 根据设备类型初始化 =================\n    // 检测移动设备\n    const isMobile = /Mobi|Android/i.test(navigator.userAgent);\n    \n    if (isMobile) {\n      // 移动设备优先使用陀螺仪\n      if (!initGyroParallax()) {\n        // 不支持陀螺仪则回退到触摸事件\n        initTouchParallax();\n      }\n    } else {\n      // PC设备使用鼠标事件\n      initMouseParallax();\n    }\n    \n    // ================= 触摸事件回退方案 =================\n    function initTouchParallax() {\n      mediaContainer.addEventListener('touchmove', (e) => {\n        e.preventDefault();\n        const touch = e.touches[0];\n        const rect = mediaContainer.getBoundingClientRect();\n        const x = (touch.clientX - rect.left) / rect.width;\n        const y = (touch.clientY - rect.top) / rect.height;\n        \n        const moveX = (x - 0.5) * parallaxIntensity * 50; // 移动强度减半\n        const moveY = (y - 0.5) * parallaxIntensity * 50;\n        \n        mediaElement.style.transform = `\n          translate(${moveX}%, ${moveY}%)\n          scale(${1 + scaleIntensity * 0.5}) // 缩放强度减半\n        `;\n      });\n      \n      mediaContainer.addEventListener('touchend', () => {\n        mediaElement.style.transform = 'scale(1)';\n      });\n    }\n    \n    // ================= 性能优化 =================\n    // 页面不可见时暂停陀螺仪\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden') {\n        isGyroActive = false;\n      } else if (isMobile) {\n        isGyroActive = initGyroParallax();\n      }\n    });\n  }\n}\n\n// 在initMedia函数中调用新功能\nfunction initMedia() {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', function() {\n      initResponsiveBackground();\n      initScrollFadeEffect(); // 添加调用\n    });\n  } else {\n    initResponsiveBackground();\n    initScrollFadeEffect(); // 添加调用\n  }\n}\n\n\n// ======================= 执行入口 =======================\ninitMedia();\n\n// 防抖处理窗口变化\nlet resizeTimer;\nwindow.addEventListener('resize', () => {\n  clearTimeout(resizeTimer);\n  resizeTimer = setTimeout(() => {\n    // 计算当前方向状态\n    const currentIsPortrait = window.innerHeight > window.innerWidth;\n    const currentOrientation = currentIsPortrait ? 'portrait' : 'landscape';\n    \n    // 只有方向实际改变时才执行重载\n    if (lastOrientation !== currentOrientation) {\n      console.log('[背景加载器] 窗口大小变化，重新加载媒体');\n      initResponsiveBackground();\n    } else {\n      console.log('[背景加载器] 窗口大小变化但方向未改变');\n      // ================= 方向未变时重置透明度 =================\n      initScrollFadeEffect();\n    }\n  }, 500);\n});\n\n// 页面可见性变化处理\ndocument.addEventListener('visibilitychange', () => {\n  if (document.visibilityState === 'visible') {\n    const video = document.querySelector('#home-media-container video');\n    if (video && video.paused) {\n      console.log('[背景加载器] 页面恢复可见，重新播放视频');\n      video.play().catch(e => console.warn('视频恢复播放失败:', e));\n    }\n    // ================= 页面恢复可见时重置透明度 =================\n    initScrollFadeEffect();\n  }\n});\n\n// ========== 新增修复代码（直接加在现有代码后面） ========== //\n\n// 1. 缓存恢复检测（核心修复）\nwindow.addEventListener('pageshow', event => {\n  if (event.persisted && location.pathname === '/') {\n    console.log('[修复] 检测到缓存恢复主页，强制重置');\n    lastOrientation = null;\n    initResponsiveBackground();\n    // ================= 缓存恢复时重置透明度 =================\n    setTimeout(initScrollFadeEffect, 300);\n  }\n});\n\n// 2. 路由变化监听（SPA兼容）\nwindow.addEventListener('popstate', () => {\n  if (location.pathname === '/') {\n    console.log('[修复] 检测到返回主页');\n    setTimeout(() => {\n      // 检查媒体元素是否存在\n      const container = document.getElementById('home-media-container');\n      if (!container?.querySelector('.home-media')) {\n        lastOrientation = null;\n        initResponsiveBackground();\n      }\n      // ================= 返回主页时重置透明度 =================\n      initScrollFadeEffect();\n    }, 300); // 延迟确保DOM更新\n  }\n});\n\n// 3. 媒体状态自检（兜底方案）\nfunction checkMediaStatus() {\n  if (location.pathname !== '/') return;\n  \n  const container = document.getElementById('home-media-container');\n  if (!container) return;\n  \n  const hasMedia = container.querySelector('.home-media');\n  if (!hasMedia) {\n    console.log('[修复] 自检发现媒体丢失');\n    lastOrientation = null;\n    initResponsiveBackground();\n  }\n  // ================= 媒体自检时重置透明度 =================\n  initScrollFadeEffect();\n}\n\n// 每0.5秒检查一次（轻量级检测）\nsetInterval(checkMediaStatus, 500);\n\n\n\n\n"}]