[{"title":"Hello World","url":"/2025/06/04/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"BaseCTF2024","url":"/2025/06/04/BaseCTF/BaseCTF2024_RE/","content":"\n\n\n------\n\n> **UPX mimi：**\n>\n> ​\t初步接触到了UPX加壳保护的知识和对应的脱壳工具，这是一种“压缩”保护壳，即将源程序代码进行压缩，然后配上解压缩代码，组成新的程序，即“UPX解压代码”+“压缩的源文件”。在程序启动时，会先执行UPX的解压代码，得到解压后的源文件，然后将控制流转移到源文件。\n\n> **ez_maze:**\n>\n> ​\t最基础的迷宫题目，从IDA中可以直接看到迷宫，人工就能得到路径。\n\n> **BasePlus:**\n>\n> ​\t无保护，直接拖入IDA，考察基础的阅读代码的能力，加密函数为Base64的一点点变化，对Base64加密后继续异或一下。很基础。第一次认真搓Base64的c语言代码，收获不少。\n\n> **Ez_Xor:**\n>\n> ​\t复习了大小端序的知识。\n>\n> ​\t“小端序”：低位有效字节保存在小地址。如0xDEADBEEF在内存中的顺序是（小地址）EF BE AD DE（大地址）。“大端序”相反。\n>\n> ​\t本题就是简单的流加密，生成密钥流然后加密。对应解密即可。\n\n> **UPX:**\n>\n> ​\t有壳，直接脱壳报错。学习到了，改标志位来保护加壳程序的手段，我们的反制操作就是打开文件，将对应的标志位从小写改回大写。之后就可以正常脱壳了。\n>\n> ​\t拖入IDA后，考察的是换表的Base64。唯一需要注意的点就是因为题目源码是C语言，在IDA字符串显示中给双引号全面加了转义符号的，不要搞错了。\n\n![image-20250425170632940](/pictures/BaseCTF2024\\image-20250425170632940.png)\n\n> **lk:**\n>\n> ​\t比较大的线性方程组，考察python的z3solver库使用。\n\n> **喝杯下午茶：**\n>\n> ​\t标准的Tea加密，第一次使用C语言实现了该算法，收获不少。\n\n> **Ezpy:**\n>\n> ​\t考察python打包出的EXE程序。反编译出源码。\n>\n> ​\t再考察RC4加密。\n\n> **最简单的编码：**\n>\n> ​\t无保护技术，纯考验伪代码的阅读水平，耐下心来分析就好了。\n\n> **neuro爱数学：**\n>\n> ​\t\n\n> **RivestCipher:**\n>\n> ​\t考察标准RC4加密算法。\n\n> **ezAndroid:**\n>\n> ​\t收获到了逆向apk安装包的软件jadx，接触到了so文件（共享库）逆向，是一些没有接触过的操作。又要读奇怪的代码。唉！\n\n------\n\n# **UPX PRO MAX**\t\n\n​\t直接运行EXE程序，会出现下图的显示。\n\n![image-20250506132159230](/pictures/BaseCTF2024\\image-20250506132159230.png)\n\nDIE也看到UPX壳。\n\n![image-20250506132311405](/pictures/BaseCTF2024\\image-20250506132311405.png)\n\n直接上工具是不行的啊，报错了。\n\n跟着WP学习——**利用ESP定律x64dbg手脱UPX壳**。\n\n> “ESP定律”也称“堆栈平衡定律”\n>\n> 由于在程序自解密或者自解压过程中, 多数壳会先将当前寄存器状态压栈, 如使用`pushad`, 而在解压结束后, 会将之前的寄存器值出栈, 如使用`popad`. 因此在寄存器出栈时, 往往程序代码被恢复, 此时硬件断点触发（这就是我们要下硬件断点的原因），然后在程序当前位置, 只需要一些单步操作, 就会到达正确的OEP位置。\n>\n> 1. 程序刚载入开始 `pushad/pushfd`\n> 2. 将全部寄存器压栈后就设对 ESP 寄存器设硬件断点\n> 3. 运行程序, 触发断点\n> 4. 删除硬件断点开始分析\n\n在x64dbg中，F9两次后来到这个压栈的操作处。接着单步运行一次，看到ESP的值为红色，代表其值被修改了，我们右键选择“在内存窗口中转到”，然后在栈中打下硬件断点。\n\n![image-20250506133643545](/pictures/BaseCTF2024\\image-20250506133643545.png)\n\n![image-20250506134057787](/pictures/BaseCTF2024\\image-20250506134057787.png)\n\n![image-20250506134312068](/pictures/BaseCTF2024\\image-20250506134312068.png)\n\n之后F9，触发断点后单步运行几下就找到OEP了，即程序入口点。可以看到这个地方的多次pop指令。\n\n根据wp中的提示，0X41CF65跳转的地方就是程序的入口点了。应该是了。\n\n![image-20250506134519180](/pictures/BaseCTF2024\\image-20250506134519180.png)\n\n下面根据WP中的操作介绍一步步就可以脱出无壳的程序了，叫UPX_PRO_MAX_dump_SCY.exe。\n\n> `scylla`插件：在 x64dbg 中内置的 Scylla 插件可用于 dump 进程，**即将内存中的程序数据转储到磁盘上**，形成一个可执行文件的副本，方便后续对程序的分析和研究。\n>\n> `IAT AutoSearch`： 在分析经过加壳或加密的程序时，程序的导入表可能被破坏或隐藏，IAT AutoSearch 可以自动扫描内存或代码段，寻找可能的导入函数地址，帮助逆向工程师快速找到程序所调用的外部函数。\n\n> 程序的导入表是程序的关键数据结构，用于列出程序运行时需要从其他模块（通常是 DLL）中导入的函数和变量。以下是导入表的详细介绍：\n>\n>   * 导入表是程序的一个数据结构，它包含了一系列的引用信息，指向程序运行时需要调用的外部函数和变量所在的模块及其具体地址。\n>\n> \n>\n>   * **便于调用外部模块功能** ：程序通常不会将所有功能都自己实现，而是通过调用系统或第三方提供的 DLL 中的函数和变量来实现复杂的功能。导入表就像一个目录，告诉操作系统程序需要从哪些 DLL 中使用哪些功能。\n>   * **便于程序的动态链接** ：它支持程序的动态链接机制。程序在编译时不会直接将 DLL 中的函数和变量代码包含进来，而是在运行时装载所需的 DLL，并通过导入表找到具体的函数和变量地址，这样可以减少程序自身的体积，同时方便对 DLL 进行更新和共享。\n>\n> \n>\n>   * **导入模块名表** ：存放了程序需要导入的各个模块的名字，比如 “kernel32.dll”“user32.dll” 等。\n>   * **导入函数名表** ：对于每个导入模块，都有一个对应的导入函数名表，列出了从该模块中导入的具体函数名称，如 “MessageBoxA”“CreateFileA” 等。\n>   * **导入函数地址表（IAT）** ：在程序运行时，操作系统会将每个导入函数的实际内存地址填入这个表中，程序通过这个表中的地址来调用相应的函数。\n\n脱壳后的程序导入IDA中，很清晰的加密逻辑。直接逆向写脚本就行。\n\n![image-20250506141212651](/pictures/BaseCTF2024\\image-20250506141212651.png)\n\n但是这里出现了一个坑：`sub_401550`函数其实就是一些加密字符串移动操作，分成几部分存储在几个变量中。但是在验证函数中，全程只用到了a1和a2部分，也就是sub_401550中的a2和a3，不是完整的密文，我觉得这里是中间出了问题，而且这个提取出来的exe程序无法正常运行，IDA中也调试不行，只能静态分析。所以还是有点不靠谱的东西存在。\n\n![image-20250506142108769](/pictures/BaseCTF2024\\image-20250506142108769.png)\n\n![image-20250506141429954](/pictures/BaseCTF2024\\image-20250506141429954.png)\n\n------\n\n# EZ_VM\n\n​\t基本信息：`pyinstaller`打包的`ELF64`位程序，使用`pydumpck`解包得到`py`文件。\n\n​\t加密逻辑在`what.py`文件，打开，里面函数名称和变量名都是用数字代替的，还有一些小错误，比如本来的“while”语句变成“if”，需要改过来。\n\n​\t代码的逻辑就是：分别使用一个数组变量和一个字典来模拟一个栈和内存，使用变量模拟寄存器，通过数组的`pop`和`push`模拟栈的操作，使用函数定义各种汇编指令，如push、pop、add、sub等等，都是统一操作数长度。就这样定义了一个能够通过汇编指令进行运行的“虚拟机”，里面存在出题人预先写好的一段静态汇编代码，作为加密函数。\n\n> 1. 我们首要任务就是给源python代码进行重命名和明显的错误纠正。（需要足够熟悉汇编指令，起码的要知道。转移指令还没那么重要，因为我们不关心程序的执行流程，我们只需要注意密文的来处即可。）\n> 2. 然后在其中插入print调试语句输出操作指令、栈和内存的值，锁定密文的存储地方，观察加密方法。\n> 3. 根据加密方法写逆向脚本。\n\n​\t\n\n```python\nenc_flag = [\n    35,\n    18,\n    22,\n    38,\n    23,\n    18,\n    61,\n    25,\n    83,\n    4,\n    0,\n    5,\n    5,\n    83,\n    95,\n    20,\n    29,\n    83,\n    82,\n    1,\n    29,\n    25,\n    0,\n    0,\n    81,\n    72,\n    76,\n    85,\n    3,\n    85,\n    79,\n    73,\n    83,\n    0,\n    15,\n    9,\n    85,\n    7,\n    80,\n    82,\n    0,\n    5,\n    84,\n    77,\n    130]\n\n\nclass Opcode:\n    vm_push = 240\n    vm_pop = 241\n    vm_and = 242\n    vm_or = 243\n    vm_not = 244\n    vm_xor = 245\n    vm_jmp = 246\n    vm_jz = 247\n    vm_label = 248\n    vm_strlen = 249\n    vm_loadchar = 250\n    vm_store = 251\n    vm_load = 252\n    vm_add = 253\n    vm_sub = 254\n\n\nclass VM:\n\n    def __init__(self):\n        self.stack = []\n        self.bytecode = []\n        self.pc = 0\n        self.labels = {}\n        self.memory = {}\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if not self.stack:\n            raise IndexError('something wrong..')\n        return self.stack.pop()\n\n    def _scan_labels(self):\n        labels = {}\n        pc = 0\n        while pc < len(self.bytecode):\n            if self.bytecode[pc] == Opcode.vm_label:\n                label_name = self.bytecode[pc + 1]\n                labels[label_name] = pc\n                pc += 2\n            else:\n                pc += 1\n\n        return labels\n\n    def vm_and(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b & a)\n\n    def vm_or(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b | a)\n\n    def vm_not(self):\n        b = self.pop()\n        self.push(~b)\n\n    def vm_xor(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b ^ a)\n\n    def vm_jmp(self):\n        label_name = self.bytecode[self.pc]\n        self.pc = self.labels[label_name]\n\n    def vm_jz(self):\n        label_name = self.bytecode[self.pc]\n        self.pc += 1\n        a = self.pop()\n        b = self.pop()\n        if a == b:\n            self.pc = self.labels[label_name]\n\n    def vm_strlen(self):\n        string = self.pop()\n        self.push(len(string))\n\n    def vm_loadchar(self):\n        string = self.pop()\n        index = self.pop()\n        self.push(ord(string[index]))\n\n    def vm_store(self):\n        value = self.pop()\n        key = self.bytecode[self.pc]\n        if key == 'r':\n            if key not in self.memory:\n                self.memory[key] = []\n            self.memory[key].append(value)\n        else:\n            self.memory[key] = value\n        self.pc += 1\n\n    def vm_load(self):\n        key = self.bytecode[self.pc]\n        self.push(self.memory[key])\n        self.pc += 1\n\n    def vm_add(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b + a)\n\n    def vm_sub(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b - a)\n\n    def run(self, bytecode):\n        self.bytecode = bytecode\n        self.pc = 0\n        self.labels = self._scan_labels()\n        while self.pc < len(self.bytecode):\n            opcode = self.bytecode[self.pc]\n            self.pc += 1\n            if opcode == Opcode.vm_push:\n                value = self.bytecode[self.pc]\n                self.pc += 1\n                self.push(value)\n            elif opcode == Opcode.vm_pop:\n                self.pop()\n            elif opcode == Opcode.vm_and:\n                self.vm_and()\n            elif opcode == Opcode.vm_or:\n                self.vm_or()\n            elif opcode == Opcode.vm_not:\n                self.vm_not()\n            elif opcode == Opcode.vm_xor:\n                self.vm_xor()\n            elif opcode == Opcode.vm_jmp:\n                self.vm_jmp()\n            elif opcode == Opcode.vm_jz:\n                self.vm_jz()\n            elif opcode == Opcode.vm_label:\n                self.pc += 1\n            elif opcode == Opcode.vm_strlen:\n                self.vm_strlen()\n            elif opcode == Opcode.vm_loadchar:\n                self.vm_loadchar()\n            elif opcode == Opcode.vm_store:\n                self.vm_store()\n            elif opcode == Opcode.vm_load:\n                self.vm_load()\n            elif opcode == Opcode.vm_add:\n                self.vm_add()\n            elif opcode == Opcode.vm_sub:\n                self.vm_sub()\n            else:\n                raise ValueError('something wrong')\n            print(f\"pc: {self.pc}| opcode: {get_opcode_name(opcode)}, stack: {self.stack}, memory: {self.memory}\")\n\n    def encrypt(self, serial):\n        bytecode = [\n            Opcode.vm_push, serial,\n            Opcode.vm_strlen,\n            Opcode.vm_store, 'l1',\n            Opcode.vm_push, 0,\n            Opcode.vm_store, 'i',\n            Opcode.vm_label, 's',\n            Opcode.vm_load, 'l1',\n            Opcode.vm_push, 1,\n            Opcode.vm_sub,\n            Opcode.vm_load, 'i',\n            Opcode.vm_jz, 'e',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, 1,\n            Opcode.vm_add,\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_xor,\n            Opcode.vm_store, 'r',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, 1,\n            Opcode.vm_add,\n            Opcode.vm_store, 'i',\n            Opcode.vm_jmp, 's',\n            Opcode.vm_label, 'e',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_push, 255,\n            Opcode.vm_xor,\n            Opcode.vm_store, 'r'\n        ]\n        self.run(bytecode)\n        enc = self.memory['r']\n        return enc\n\ndef get_opcode_name(opcode):\n    for name, value in Opcode.__dict__.items():\n        if value == opcode:\n            return name\n    return None\n\nvm = VM()\ntest_flag = \"BaseCTF{VM_is_awesome}\"\nenc = vm.encrypt(test_flag)\nprint(f\"encrypted test_flag: {enc}\")\nprint(f\"original flag: {enc_flag}\")\n```\n\n根据WP提示重命名后，观察传输的调试信息。看一下开头和结尾就行。\n\n![image-20250509160138052](/pictures/BaseCTF2024\\image-20250509160138052.png)\n\n![image-20250509160305470](/pictures/BaseCTF2024\\image-20250509160305470.png)\n\n​\t所以猜到加密逻辑是：从前往后，相邻两位异或，尾部和255异或。\n\n这里给出我的解密脚本。\n\n```python\nenc_flag = [35, 18, 22, 38, 23,  18,61, 25,  83,4,0, 5, 5,83,95,  20,  29, 83,82,  1, 29, 25, 0,0,81,72,76,85,3,85,79,73,83,0,15,9,85,7,80,82,0,5,84,77,130,255]\n\nflag = \"\"\nfor i in range(len(enc_flag)):\n    char = enc_flag[i]\n    for j in range(i+1, len(enc_flag)):\n        char = char ^ enc_flag[j]\n\n    flag += chr(char)\n\nprint(flag)\n```\n\n------\n\n# Microgame\n\n​\t不理解，不会游戏逆向，后面得学啊。专门做了一个CE的学习。\n\n​\t学习完CE，专门出个WP来做。\n\n------\n\n# neuro爱数学\n\n​\t直接打开IDA看看`main`函数，程序无壳，就是考察数学问题。\n\n![image-20250512120720066](/pictures/BaseCTF2024\\image-20250512120720066.png)\n\n![image-20250512130852846](/pictures/BaseCTF2024\\image-20250512130852846.png)\n\n![image-20250512130953971](/pictures/BaseCTF2024\\image-20250512130953971.png)\n\n```c\n#include<stdio.h>\n#include<stdint.h>\n#include<intrin.h>\n\nint main(){\t\t\t\t\t\t\t\t//注意：各个变量和函数的类型是关键，不能搞错，需要对照IDA伪代码\n    int64_t v5=0x400C0210000001;\t\t\t//这个值是固定的，但是需要动调程序得到这个值。\n\n    for(int i=-60; i<=59; i++){\n        if(i == 44 || i == 58){\n            printf(\"符合条件的i值位：%d\\n\", i);\n            continue;\n        }\n\n        unsigned int v12 = (unsigned int)(i + 37);\n        if(v12 <= 54 && _bittest64((int64_t*)&v5,(unsigned int)v12) != 0){\n            printf(\"符合条件的i值为：%d\\n\", i);\n        }\n\n    }\n\n    return 0;\n}\n\n```\n\n![image-20250512131328904](/pictures/BaseCTF2024\\image-20250512131328904.png)\n\n然后使用python脚本展开多项式得到系数。\n\n```python\nfrom sympy import symbols, expand\n\n# 定义符号变量\nx = symbols('x')\n\n# 构造多项式\npolynomial = (x - 44) * (x - 58) * (x - 5) * (x + 37) * (x - 17) * (x + 9) * (x - 6) * (x + 4)\n\n# 展开多项式\nexpanded_polynomial = expand(polynomial)\n\n# 提取并打印系数\nstandard_form = expanded_polynomial.as_poly()  # 获取标准形式的多项式\ncoefficients = standard_form.all_coeffs()    # 获取所有系数\n\n# 打印系数逆序（从常数项到最高次项）。因为正常是从高次项到低次项。\nprint(coefficients[::-1])\n#[-1733624640, 134045088, 122783468, -12168520, -1364231, 121272, -358, -80, 1]\n```\n\n![image-20250512131708984](/pictures/BaseCTF2024\\image-20250512131708984.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["CTF","技术"],"categories":["学习笔记"]},{"title":"tags","url":"/tags/index.html"},{"title":"about","url":"/about/index.html"},{"title":"categories","url":"/categories/index.html"}]