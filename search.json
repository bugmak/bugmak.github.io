[{"title":"OpenGL初学习","url":"/2025/06/25/OpenGL学习/OpenGL学习/","content":"\n### \t环境搭建\n\n​\t学习OpenGL的核心模式，[VS2022+GLFW+GLAD环境搭建教程](https://blog.csdn.net/ssunshining/article/details/123767340)，需要注意的是文章中下载的GLFW是编译好的，我们可以跳过CMake编译的那一步，直接去找include文件和lib文件。\n\n​\t还有学习资源，[知识点学习](https://learnopengl-cn.github.io/)。\n\n\n\n------\n\n\n\n### \t基础知识（知识点学习）\n\n\n\n> ### 🔷 OpenGL 是什么？\n>\n> > OpenGL（Open Graphics Library）是一个画图的标准工具库，用来绘制图形，比如 3D 模型、场景、特效等等。\n>\n> - 它不负责创建窗口，也不能处理鼠标/键盘，只专注“画图”。\n> - 想象你是画家，OpenGL 就是你的画笔和颜料。\n>\n> ------\n>\n> ### 🔶 GLFW 是什么？\n>\n> > GLFW 是一个专门用来创建窗口、处理用户输入（键盘鼠标）和设置 OpenGL 的库。\n>\n> - 它帮你打开一个窗口、设置 OpenGL 的版本，并响应鼠标/键盘事件。\n> - 没有 GLFW（或类似的库），你连“打开画布”都做不到。\n>\n> ------\n>\n> ### 🔸 GLAD 是什么？\n>\n> > GLAD 是一个 OpenGL 的“加载器”，帮你把 OpenGL 的函数都准备好。\n>\n> - 因为 OpenGL 的函数不是自动提供的，需要手动“加载”才能使用。\n> - GLAD 就像一个工具箱打开器，确保你能正确使用所有画图工具。\n>\n> ------\n>\n> ## 🧠 记忆小口诀：\n>\n> **GLFW 开窗口，GLAD 开工具，OpenGL 开画图。**\n\n​\t\n\n\n\n\n\n\n\n> ## OpenGL 的坐标系（标准化设备坐标 NDC）\n>\n> 1. **坐标范围：**\n>     OpenGL 在渲染管线最后一步，会把顶点坐标变换到一个叫做 **标准化设备坐标**（NDC，Normalized Device Coordinates）的空间里。\n>    - X轴范围：从 **-1 到 1**（左到右）\n>    - Y轴范围：从 **-1 到 1**（下到上）\n>    - Z轴范围：从 **-1 到 1**（近到远，深度）\n> 2. **坐标轴方向：**\n>    - X轴：负方向指向左，正方向指向右\n>    - Y轴：负方向指向下，正方向指向上\n>    - Z轴：负方向指向屏幕外（观察者方向），正方向指向屏幕内\n> 3. **二维绘图时，Z轴通常为0**\n> 4. **原点在显示窗口的中心点**\n\n\n\n\n\n​\tVBO是什么？顶点缓冲对象，用来管理内存。看下面的代码，就是使用**glGenBuffers**函数生成一个带有缓冲ID的VBO对象。\n\n```java\nunsigned int VBO;\nglGenBuffers(1, &VBO);\n```\n\n> 🧠 为什么 VBO 是一个 `unsigned int` 变量？\n>\n> ——因为在 OpenGL 的内部设计中，每一个“对象”（比如缓冲区对象、纹理对象、着色器对象）都会被分配一个唯一的数字 ID，这个 ID 就是一个整数。OpenGL 并不直接返回一个“指针”或者“结构体”，它只返回一个整数值，然后你以后只要用这个数字来引用这个对象就行了。\n>\n> ❓那 VBO 本身是缓冲区吗？\n>\n> ——不是。VBO只是一个整数变量，用来存这个缓冲区的ID，真正的“缓冲区对象”是在OpenGL内部创建和管理的，你只能通过这个ID来间接使用它。\n\n\n\n\n\n​\tVAO是什么？顶点数组对象，帮你把一堆“顶点属性设置”的状态保存起来，下次想用的时候一绑上，OpenGL 就知道你的顶点数据长什么样，不用你每次都重新设置。\n\n> ## 为什么要有 VAO？\n>\n> 你画一个图形，顶点数据除了顶点坐标外，还可能有颜色、法线、纹理坐标等，每种数据都要告诉 OpenGL 怎么读取。\n>\n> 举个例子：\n>\n> - 你的顶点坐标数据在缓冲区里的起始地址是0，大小是3个float\n> - 颜色数据在缓冲区里的起始地址是12字节，大小是3个float\n>\n> 每次绘制之前，你得告诉 OpenGL 这些数据在哪，格式是什么。\n>\n> 如果没有 VAO，你每次绘图都要重复这些繁琐的设置，非常麻烦。\n>\n> ------\n>\n> ## VAO的作用就是帮你记住这些设置\n>\n> 你先创建一个 VAO，绑定它：\n>\n> ```java\n> unsigned int VAO;\n> glGenVertexArrays(1, &VAO);\n> glBindVertexArray(VAO);\n> ```\n>\n> 然后你做各种顶点属性设置：\n>\n> ```java\n> glBindBuffer(GL_ARRAY_BUFFER, VBO);\n> glVertexAttribPointer(...);\n> glEnableVertexAttribArray(...);\n> ```\n>\n> 这些设置都会被 VAO 记录。\n>\n> 以后你只要：\n>\n> ```java\n> glBindVertexArray(VAO);\n> ```\n>\n> OpenGL就自动知道所有顶点属性设置，你可以直接画图了。\n>\n> ------\n>\n> ## 简单比喻\n>\n> - **没有 VAO**：每次画画都要重新告诉画笔颜色、粗细、位置，麻烦又容易出错。\n> - **有了 VAO**：把画笔的设置存好，下次直接拿出来用，画画快又方便。\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n------\n\n\n\n### 示例代码讲解（注释版）\n\n```c++\n#include<glad/glad.h>\n#include<GLFW/glfw3.h>\n\n#include<iostream>\n\n//回调函数声明，当窗口大小改变就会调用\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height);\n\n\nint main()\n{\n    glfwInit();\n    //告诉GLFW我们使用OpenGL3.3 Core Profile\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);\n    //glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE);\n\n    GLFWwindow* window = glfwCreateWindow(800, 600, \"LearnOpenGL\", NULL, NULL);\t//创建窗口\n    \n    if (window == NULL)\t//检查窗口创建状态\n    {\n        std::cout << \"Failed to create GLFW window\" << std::endl;\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\t//把OpenGL上下文设置为这个窗口\n\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\t//初始化GLAD\n    {\n        std::cout << \"Failed to initialize GLAD\" << std::endl;\n        return -1;\n    }\n\n    glViewport(0, 0, 800, 600);\t\t//设置视口\n\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\t//注册窗口大小变化的回调函数\n\n    while (!glfwWindowShouldClose(window))\t // 只要窗口没被关闭，就一直循环\n    {\n        glfwSwapBuffers(window);\t\t// 交换颜色缓冲（把渲染的图像显示到屏幕上）\n        glfwPollEvents();\t\t// 处理键盘鼠标等事件\n    }\n    glfwTerminate();\t// 清理并退出 GLFW\n    return 0;\n}\n\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n    glViewport(0, 0, width, height);\t\t// 根据新的窗口大小重新设置视口\n}\n```\n\n\n\n\n\n### 作业一\n\n\n\n- **绘制渐变色的三角形**\n\n```c++\n#include <glad/glad.h>\n#include <GLFW/glfw3.h>\n#include <iostream>\n\n// 窗口大小变化时调整视口\nvoid framebuffer_size_callback(GLFWwindow* window, int width, int height)\n{\n    glViewport(0, 0, width, height);\n}\n\n// 检查着色器编译错误\nvoid checkCompileErrors(unsigned int shader, std::string type)\n{\n    int success;\n    char infoLog[1024];\n    if (type != \"PROGRAM\")\n    {\n        glGetShaderiv(shader, GL_COMPILE_STATUS, &success);\n        if (!success)\n        {\n            glGetShaderInfoLog(shader, 1024, NULL, infoLog);\n            std::cout << \"ERROR::SHADER_COMPILATION_ERROR of type: \" << type << \"\\n\"\n                << infoLog << \"\\n -- --------------------------------------------------- -- \" << std::endl;\n        }\n    }\n    else\n    {\n        glGetProgramiv(shader, GL_LINK_STATUS, &success);\n        if (!success)\n        {\n            glGetProgramInfoLog(shader, 1024, NULL, infoLog);\n            std::cout << \"ERROR::PROGRAM_LINKING_ERROR of type: \" << type << \"\\n\"\n                << infoLog << \"\\n -- --------------------------------------------------- -- \" << std::endl;\n        }\n    }\n}\n\nint main()\n{\n    // 1. 初始化 GLFW\n    glfwInit();\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3); // OpenGL 3.x\n    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3); // OpenGL x.3\n    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE); // 核心模式\n\n#ifdef __APPLE__\n    glfwWindowHint(GLFW_OPENGL_FORWARD_COMPAT, GL_TRUE); // MacOS 需要这句\n#endif\n\n    // 2. 创建窗口\n    GLFWwindow* window = glfwCreateWindow(800, 600, \"Colored Triangle\", NULL, NULL);\n    if (window == NULL)\n    {\n        std::cout << \"Failed to create GLFW window\\n\";\n        glfwTerminate();\n        return -1;\n    }\n    glfwMakeContextCurrent(window);\n\n    // 3. 初始化 GLAD\n    if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))\n    {\n        std::cout << \"Failed to initialize GLAD\\n\";\n        return -1;\n    }\n\n    // 4. 设置视口和窗口大小回调\n    glViewport(0, 0, 800, 600);\n    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);\n\n    // 5. 定义顶点数据（位置 + 颜色）\n    float vertices[] = {\n        // 位置           // 颜色(R, G, B)\n         0.0f,  0.5f, 0.0f,  0.0f, 0.0f, 1.0f,  // 顶点1 蓝色\n        -0.5f, -0.5f, 0.0f,  0.0f, 1.0f, 0.0f,  // 顶点2 绿色\n         0.5f, -0.5f, 0.0f,  1.0f, 0.0f, 0.0f   // 顶点3 红色\n    };\n\n    // 6. 编写顶点着色器源码\n    const char* vertexShaderSource = R\"glsl(\n        #version 330 core\n        layout (location = 0) in vec3 aPos;   // 位置属性\n        layout (location = 1) in vec3 aColor; // 颜色属性\n\n        out vec3 ourColor; // 输出给片元着色器的颜色变量\n\n        void main()\n        {\n            gl_Position = vec4(aPos, 1.0); // 设置顶点位置\n            ourColor = aColor;              // 传递颜色到片元着色器\n        }\n    )glsl\";\n\n    // 7. 编写片元着色器源码\n    const char* fragmentShaderSource = R\"glsl(\n        #version 330 core\n        in vec3 ourColor;       // 从顶点着色器传来的颜色\n\n        out vec4 FragColor;     // 输出颜色\n\n        void main()\n        {\n            FragColor = vec4(ourColor, 1.0); // 设置片元颜色，alpha为1（不透明）\n        }\n    )glsl\";\n\n    // 8. 编译顶点着色器\n    unsigned int vertexShader = glCreateShader(GL_VERTEX_SHADER);\n    glShaderSource(vertexShader, 1, &vertexShaderSource, NULL);\n    glCompileShader(vertexShader);\n    checkCompileErrors(vertexShader, \"VERTEX\");\n\n    // 9. 编译片元着色器\n    unsigned int fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);\n    glShaderSource(fragmentShader, 1, &fragmentShaderSource, NULL);\n    glCompileShader(fragmentShader);\n    checkCompileErrors(fragmentShader, \"FRAGMENT\");\n\n    // 10. 链接着色器程序\n    unsigned int shaderProgram = glCreateProgram();\n    glAttachShader(shaderProgram, vertexShader);\n    glAttachShader(shaderProgram, fragmentShader);\n    glLinkProgram(shaderProgram);\n    checkCompileErrors(shaderProgram, \"PROGRAM\");\n\n    // 11. 删除着色器对象，已经链接到程序里了\n    glDeleteShader(vertexShader);\n    glDeleteShader(fragmentShader);\n\n    // 12. 创建顶点缓冲和顶点数组对象\n    unsigned int VBO, VAO;\n    glGenVertexArrays(1, &VAO);\n    glGenBuffers(1, &VBO);\n\n    // 绑定 VAO\n    glBindVertexArray(VAO);\n\n    // 绑定并填充 VBO\n    glBindBuffer(GL_ARRAY_BUFFER, VBO);\n    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);\n\n    // 位置属性\n    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)0);\n    glEnableVertexAttribArray(0);\n\n    // 颜色属性\n    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), (void*)(3 * sizeof(float)));\n    glEnableVertexAttribArray(1);\n\n    // 解绑\n    glBindBuffer(GL_ARRAY_BUFFER, 0);\n    glBindVertexArray(0);\n\n    // 13. 渲染循环\n    while (!glfwWindowShouldClose(window))\n    {\n        // 处理输入（这里没写输入，后续可以加）\n\n        // 清屏，设置背景颜色\n        glClearColor(0.2f, 0.3f, 0.3f, 1.0f);\n        glClear(GL_COLOR_BUFFER_BIT);\n\n        // 使用着色器程序\n        glUseProgram(shaderProgram);\n\n        // 绑定 VAO\n        glBindVertexArray(VAO);\n\n        // 绘制三角形\n        glDrawArrays(GL_TRIANGLES, 0, 3);\n\n        // 交换缓冲区和轮询事件\n        glfwSwapBuffers(window);\n        glfwPollEvents();\n    }\n\n    // 14. 释放资源\n    glDeleteVertexArrays(1, &VAO);\n    glDeleteBuffers(1, &VBO);\n    glDeleteProgram(shaderProgram);\n\n    // 15. 退出 GLFW\n    glfwTerminate();\n    return 0;\n}\n```\n\n\n\n![image-20250625101600766](/pictures/OpenGL/image-20250625101600766.png)\n\n\n\n\n\n### 练习\n\n- 添加更多顶点到数据中，使用glDrawArrays，尝试绘制两个彼此相连的三角形。\n\n​\t相较于上面的代码，只需修改两处即可：添加顶点（坐标和颜色属性）、绘制6个顶点。\n\n```java\nfloat vertices[] = {\n\t-0.9f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f,\n\t-0.0f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f,\n\t-0.45f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f,\n\t 0.0f, -0.5f, 0.0f, 0.0f, 0.0f, 1.0f, \n\t 0.9f, -0.5f, 0.0f, 0.0f, 1.0f, 0.0f,\n\t 0.45f, 0.5f, 0.0f, 1.0f, 0.0f, 0.0f\n};\n\nglDrawArrays(GL_TRIANGLES, 0, 6);\t//用顶点数组从第 0 个顶点开始，按三角形方式，绘制 6个顶点组成的两个三角形。\n```\n\n![image-20250626135154793](/pictures/OpenGL/image-20250626135154793.png)\n\n\n\n\n\n\n\n- 创建相同的两个三角形，但对它们的数据使用不同的VAO和VBO。\n\n​\t其他部分不变，改动如下：创建时使用数组存储多个VAO和VBO、两个三角形顶点数据分为不同数组存储、分开绑定并且传输数据解析数据、分开绘制。\n\n```java\nunsigned int VBOs[2], VAOs[2];\nglGenVertexArrays(2, VAOs); // we can also generate multiple VAOs or buffers at the same time\nglGenBuffers(2, VBOs);\n\nfloat firstTriangle[] = {\n    -0.9f, -0.5f, 0.0f,  // left \n    -0.0f, -0.5f, 0.0f,  // right\n    -0.45f, 0.5f, 0.0f,  // top \n};\nfloat secondTriangle[] = {\n     0.0f, -0.5f, 0.0f,  // left\n     0.9f, -0.5f, 0.0f,  // right\n     0.45f, 0.5f, 0.0f   // top \n};\n\nglBindVertexArray(VAOs[0]);\nglBindBuffer(GL_ARRAY_BUFFER, VBOs[0]);\nglBufferData(GL_ARRAY_BUFFER, sizeof(firstTriangle), firstTriangle, GL_STATIC_DRAW);\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);\t// Vertex attributes stay the same\nglEnableVertexAttribArray(0);\n\nglBindVertexArray(VAOs[1]);\t// 绑定新的VAO\nglBindBuffer(GL_ARRAY_BUFFER, VBOs[1]);\t//绑定新的VBO\nglBufferData(GL_ARRAY_BUFFER, sizeof(secondTriangle), secondTriangle, GL_STATIC_DRAW); //传输数据到VBO代表的缓冲区\nglVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 0, (void*)0); \t\t//指定读取方式\nglEnableVertexAttribArray(0);\t\t\t//启用顶点属性\n\nglBindVertexArray(VAOs[0]);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n        // then we draw the second triangle using the data from the second VAO\nglBindVertexArray(VAOs[1]);\nglDrawArrays(GL_TRIANGLES, 0, 3);\n```\n\n​\t**glVertexAttribPointer**函数的参数蛮多，建议边看LearnOpenGL项目。\n\n\n\n\n\n\n\n- 创建两个着色器程序，第二个程序使用一个不同的片段着色器，输出黄色；再次绘制这两个三角形，让其中一个输出为黄色。\n\n​\t\n\n​\t在上面的基础上，创建两个**shaderProgram**、**fragmentshader**，然后编译好三个着色器（包括一个共用的顶点着色器），之后分组链接到**shaderProgram**中，最后**while**循环中，分别使用**glUseProgram**函数指定渲染程序进行绘画。","tags":["OpenGL"],"categories":["开发"]},{"title":"阅读APP项目学习——4","url":"/2025/06/24/阅读项目学习/安卓项目学习4/","content":"\n\n\n\n\n### 正文\n\n​\t\n\n​\t**BaseFragment**抽象类，是一个基础的Fragment类实现，继承自 `RxFragment`（这是一个支持 RxJava 生命周期管理的 Fragment），由于该父类实现了IView的方法，所以可以不再实现。\n\n​\t**BaseFragment<T extends IPresenter>**：这是一个泛型类，泛型参数 `T` 必须是 **IPresenter** 接口的子类。说明这个 Fragment 会和某个 Presenter 关联，符合 MVP 架构设计模式。\n\n```java\nprotected View view;\t\t\t\t//保存当前Fragment的根布局视图\nprotected Bundle savedInstanceState;\t\t//保存 Fragment 状态数据\n@Nullable\n@Override\npublic View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {\n\tthis.savedInstanceState = savedInstanceState;\n\tinitSDK();\n\tview = createView(inflater, container);\n\tinitData();\n\tbindView();\n\tbindEvent();\n\tfirstRequest();\n\treturn view;\n}\n    /**\n     * 事件触发绑定\n     */\n    protected void bindEvent() {\n\n    }\n    /**\n     * 控件绑定\n     */\n    protected void bindView() {\n\n    }\n    /**\n     * 数据初始化\n     */\n    protected void initData() {\n\n    }\n    /**\n     * 首次逻辑操作\n     */\n    protected void firstRequest() {\n\n    }\n    /**\n     * 加载布局\n     */\n    protected abstract View createView(LayoutInflater inflater, ViewGroup container);\n    /**\n     * 第三方SDK初始化\n     */\n    protected void initSDK() {\n\n    }\n```\n\n​\t`onCreateView` 是 Fragment 创建视图时调用的回调方法（生命周期方法），它负责加载并返回 Fragment 的布局视图。\n\n\n\n\n\n\n\n\n\n​\t**BaseModelImpl**类用来创建网络请求客户端的基础模型类，它主要负责配置并生成 Retrofit 实例，方便其他模块调用网络接口。使用OkHttp的**OkHttpClient.Builder**来创建客户端，设置了连接超时、写超时、读超时，和一个自定义的网络拦截器，用于请求失败后的重试逻辑。\n\n​\t**getRetrofitObject**方法用来创建一个Retrofit实例，传入基础的URL。\n\n​\t**getRetrofitString**和上面的方法类似，用来处理不同编码（`encode`）的字符串转换。\n\n```java\npublic class BaseModelImpl {\n\n    protected OkHttpClient.Builder clientBuilder = new OkHttpClient.Builder()\n            .connectTimeout(10, TimeUnit.SECONDS)\n            .writeTimeout(10, TimeUnit.SECONDS)\n            .readTimeout(10, TimeUnit.SECONDS)\n            .addNetworkInterceptor(new RetryIntercepter(1));\n\n    protected Retrofit getRetrofitObject(String url) {\n        return new Retrofit.Builder().baseUrl(url)\n                //增加返回值为字符串的支持(以实体类返回)\n                .addConverterFactory(ScalarsConverterFactory.create())\n                //增加返回值为Oservable<T>的支持\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .client(clientBuilder.build())\n                .build();\n    }\n\n    protected Retrofit getRetrofitString(String url, String encode) {\n        return new Retrofit.Builder().baseUrl(url)\n                //增加返回值为字符串的支持(以实体类返回)\n                .addConverterFactory(EncodoConverter.create(encode))\n                //增加返回值为Oservable<T>的支持\n                .addCallAdapterFactory(RxJava2CallAdapterFactory.create())\n                .client(clientBuilder.build())\n                .build();\n    }\n}\n```\n\n> 1. Retrofit 是什么？\n>\n> - Retrofit 是由 Square 公司开发的一个 **Android 和 Java** 平台上的网络请求库。\n> - 它帮助你很方便地调用网络上的 **HTTP 接口**（API），从服务器拿数据。\n> - 它帮你把网络请求和响应变得“像调用本地方法”一样简单。\n\n\n\n\n\n\n\n\n\n\n\n\n\n​\t**BasePresenterImpl**抽象类实现了attachView功能，并且通过模板T来进行类型转换，是一个Presenter基类。\n\n```java\npublic abstract class BasePresenterImpl<T extends IView> implements IPresenter{\n    protected T mView;\n\n    @Override\n    public void attachView(@NonNull IView iView) {\n        mView = (T) iView;\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n​\t**RetryIntercepter**类是一个自定义的 **OkHttp 拦截器**，其中`Request` 代表这次网络请求的详细信息，比如请求的地址、请求方法（GET、POST）、请求头、请求体等等。\n\n> ## 为什么要这样写？\n>\n> 拦截器就是“请求和响应之间的中间人”，它能：\n>\n> - **拿到请求**（`chain.request()`）\n> - **对请求做点事**（比如加个头，改改参数，或者打印日志）\n> - **发出请求**（`chain.proceed(request)`）\n> - **拿到响应**，还可以对响应做点事（比如判断失败重试）\n\n```java\npublic class RetryIntercepter implements Interceptor {\n    public int maxRetry;//最大重试次数\n    private int retryNum = 0;//假如设置为3次重试的话，则最大可能请求4次（默认1次+3次重试）\n\n    public RetryIntercepter(int maxRetry) {\n        this.maxRetry = maxRetry;\n    }\n\n    @Override\n    public Response intercept(Chain chain) throws IOException {\n        Request request = chain.request();\n        Response response = chain.proceed(request);\n        while (!response.isSuccessful() && retryNum < maxRetry) {\n            retryNum++;\n            response = chain.proceed(request);\n        }\n        return response;\n    }\n}\n```\n\n\n\n\n\n\n\n\n\n​\tbasemvplib分析完了，下一步要分析monky包。先大体通过AI预测一波各个文件夹的含义和其中类的作用。\n\n> ​\t**base**文件夹项目是基础代码，比如基类（BaseActivity、BaseFragment、BasePresenter等），公共抽象层，用来复用和统一规范。\n>\n> ​\t**bean**文件夹存放数据模型类（实体类），用来表示业务数据，比如书籍信息、用户信息等。通常和数据库表结构或者接口返回数据对应。\n>\n> ​\t**cache**缓存相关的代码，负责数据缓存逻辑。\n>\n> ​\t**common**配置的是访问小说网站的API接口。\n>\n> ​\t**dao**是 Data Access Object（数据访问对象） 的缩写，数据访问层，封装数据库操作（增删改查），通常对应实体bean，有专门的接口或类处理数据存取。\n>\n> ​\t**listener**定义获取章节列表的回调通知。\n>\n> ​\t**model**业务逻辑层，处理具体的数据操作和业务规则。\n>\n> ​\t**presenter**这里是 Presenter 层，负责连接 View 和 Model，实现业务逻辑，处理界面和数据的交互。\n>\n> ​\t**service**一般放后台服务相关代码，比如 Android 的 Service 类，做持续后台任务，或者封装网络请求、系统服务操作等。\n>\n> ​\t**utils**工具类包，存放各种辅助类和静态方法。\n>\n> ​\t**view**自定义的视图类，或者跟界面相关的类（不包括特殊控件），一般用来封装界面逻辑或复用界面组件。\n>\n> ​\t**widget**自定义控件或者 UI 组件，比如自定义按钮、列表、动画控件等，扩展系统控件功能。\n\n​\t**BitIntentDataManager**管理 Intent 传递的数据，封装 Intent 数据处理逻辑，方便 Activity/Fragment 之间传参。\n\n​\t**ErrorAnalyContentManager**错误内容分析管理器，可能是日志收集、错误信息处理或者错误报告生成相关的类。\n\n​\t**MApplication**自定义的 Application 类，应用入口，初始化全局变量、SDK、单例等。\n\n​\t**ProxyManager**代理管理器，可能用来实现某种代理模式，动态代理对象，或者负责网络代理、请求代理等功能。\n\n​\t**ReadBookControl**读书控制器，负责书籍阅读相关的业务逻辑，比如翻页、字体大小、阅读进度管理等。\n\n\n\n\n\n​\t改天再系统分析吧，下面在AI问到了一套比较系统的分析流程。\n\n> ## 🧭 一套系统的 MVP 项目分析流程（从 UI 到数据）\n>\n> ------\n>\n> ### ✅ **第一阶段：搞清楚结构和页面入口**\n>\n> #### 步骤 1：打开项目，看 `包结构`\n>\n> - 看包名下有哪些模块（你前面提到的 `view/`, `presenter/`, `model/`, `dao/` 等等）。\n> - 了解项目是不是使用了 MVP/MVVM 架构（从 `presenter/` 和 `model/` 目录可以看出）。\n>\n> #### 步骤 2：找“首页 Activity”或主入口页面\n>\n> - 找 `MainActivity`, `LauncherActivity`, `SplashActivity` 等。\n> - 它一般会是你启动 App 后看到的第一个页面。\n>\n> ------\n>\n> ### ✅ **第二阶段：从 View 层入手分析一个页面**\n>\n> #### 步骤 3：从 `Activity` 或 `Fragment` 开始看\n>\n> - 关注 `onCreate()` 或 `onCreateView()` 方法。\n>\n> - 看它绑定了哪个 Presenter，例如：\n>\n>   ```java\n>   presenter = new ReadBookPresenter();\n>   presenter.attachView(this);\n>   ```\n>\n> - 查看哪些用户操作（按钮点击、滑动等）触发了哪些逻辑：\n>\n>   ```java\n>   button.setOnClickListener(v -> presenter.doSomething());\n>   ```\n>\n> #### 步骤 4：查找绑定的 View 和自定义控件\n>\n> - 查看 XML 布局文件和 `findViewById()` 绑定了哪些控件。\n> - 如果发现有 `PageWidget`、`ReadSettingView` 这类自定义控件：\n>   - 先了解它的大致作用（比如翻页、显示文字）\n>   - 再决定是否深入看它的绘图或手势逻辑（很多时候可以略过）\n>\n> ------\n>\n> ### ✅ **第三阶段：深入 Presenter 层，分析业务逻辑**\n>\n> #### 步骤 5：打开对应的 `Presenter` 类\n>\n> - 看这个 Presenter 的方法有哪些？\n> - 你在 View 层点击按钮时，是调用的哪个方法？\n>\n> 示例：\n>\n> ```java\n> public void loadBook() {\n>     model.getBookData(new Callback() {\n>         @Override\n>         public void success(BookShelfBean bean) {\n>             view.showContent(bean);\n>         }\n>     });\n> }\n> \n> ```\n>\n> - Presenter 是 **核心逻辑中枢**，连接 View 和 Model。\n>\n> ------\n>\n> ### ✅ **第四阶段：查看 Model 层，数据从哪来？**\n>\n> #### 步骤 6：打开 `Model` 或 `ModelImpl` 类\n>\n> - 看它是从 **哪里拿数据** 的：\n>\n>   - 网络请求？（比如用 Retrofit）\n>   - 数据库？（比如用 Dao、GreenDAO）\n>   - 缓存？（比如用 CacheManager）\n>\n> - 查看具体的数据来源，比如：\n>\n>   ```\n>   RetrofitHelper.getApi().getChapters(bookId);\n>   ```\n>\n> ------\n>\n> ### ✅ **第五阶段：往下看数据支撑层（可选）**\n>\n> #### 步骤 7：查看 Bean、Dao、Utils 工具类\n>\n> - `bean/`：定义了哪些数据结构，比如 `BookShelfBean`, `ChapterBean`？\n> - `dao/`：你可以看看 `BookShelfBeanDao` 是如何存/取书的数据的。\n> - `utils/`：只在你看到用到的时候再深入看，比如处理日期、文件、网络状态等。\n>\n> ------\n>\n> ### ✅ **第六阶段：查找回调机制与事件流**\n>\n> - 项目中可能会有一些回调接口（像你之前提到的 `OnGetChapterListListener`）\n> - 分析它们是怎么传值、触发逻辑的。\n\n","tags":["安卓开发学习"],"categories":["开发"]},{"title":"阅读APP项目学习——3","url":"/2025/06/23/阅读项目学习/安卓项目学习3/","content":"\n\n\n### 前言\n\n​\t分析复杂一点的功能，需要熟悉面向对象的编程思想，熟悉更加基础的代码，我感觉有点力不从心，十分难以下手，考虑要不要从基础类一点点学习，分析其作用、为什么要这样写之类的问题，能学到很多知识点，这样是不是会更加有利于我的开发经验学习，毕竟“轮子”的代码都还没搞明白为什么这么写，直接去解析在此基础上的其他功能会让我有点不脚踏实地的感觉。\n\n​\t另外，因为错误的操作，把资源文件给搞乱了，又得新建项目重新copy了，有点烦。\n\n\n\n​\t\n\n### 正文\n\n​\t先从basemvplib的文件开始吧，IView和IPresenter的基础思想已经学习过了，再从**AppActivityManager**、**BaseApplication**、**EncodoConverter**这三个类开始吧。\n\n​\t\n\n​\t**AppActivityManager**类是管理项目中所有Activity的工具类，方便在应用中统一控制 Activity 生命周期，比如批量关闭某类 Activity 或检测 Activity 是否在栈中。\n\n​\t`private static List<WeakReference<Activity>> activities;`使用弱引用存储Activity，当 Activity 被系统回收时，弱引用不会阻止它的回收，避免强引用导致内存泄漏。\n\n\n\n​\t通过双重检查实现线程安全的单例模式，保证AppActivityManager在整个应用中只有一个实例。\n\n```java\npublic static AppActivityManager getInstance(){\n        if(null == instance){\n            synchronized (AppActivityManager.class){\n                if(null == instance){\n                    instance = new AppActivityManager();\n                }\n            }\n        }\n        return instance;\n    }\n\n```\n\n\n\n​\t提供了add、remove方法，其中有两种移除方式：提供Activity实例和Activity类名。\n\n​\t提供了finish方法，可以关闭指定的Activity实例或关闭指定类型的Activity。\n\n​\t提供isExist方法，能够判断某个Activity类是否存在。\n\n\n\n> ### 简单理解：\n>\n> - **Application.onCreate()**\n>    是整个应用程序的“启动入口”，在应用一启动时调用，只调用一次。\n>    你可以在这里做一些**全局初始化**，比如初始化数据库、网络库、第三方SDK等，所有页面都能用。\n> - **Activity.onCreate()**\n>    是某个具体页面（Activity）创建时调用。每打开一个新页面，就会调用它。\n>    你可以在这里做这个页面专属的初始化，比如加载布局、设置按钮事件等。\n\n\n\n​\t**BaseApplication**是一个自定义的Application类，是安卓应用的入口类，是应用启动时创建的全局入口，用来做全局初始化和管理。这是一个基础框架类，只实现了onCreate方法，调用父类的方法。\n\n\n\n​\t**EncodoConverter**继承了 `retrofit2.Converter.Factory`，用于创建数据转换器；有一个私有字段 `encode`，默认编码是 `\"utf-8\"`，也可以自定义传入编码；提供了两个静态方法 `create()` 用于创建该转换器实例，可以用默认编码，也可以用自定义编码；重写了 `responseBodyConverter()` 方法，返回一个 `Converter<ResponseBody, String>`，这个转换器就是把响应体数据读取为指定编码的字符串。\n\n​\t这段代码就是给 Retrofit 定制一个响应体的编码转换器，让它可以用指定编码把服务器返回的字节流转成字符串。\n\n\n\n​\t**Retrofit** 是一个用于 Android 和 Java 的网络请求库，它帮你很方便地向服务器发送 HTTP 请求，获取数据，然后自动把服务器返回的 JSON 或 XML 转换成你定义的 Java 对象，省去了你自己写很多解析代码。\n\n\n\n\n\n\n\n​\t再看**BaseActivity**类，它是所有Activity的基类，统一封装生命周期方法和Presenter管理，使用了泛型<T extends IPresenter> 表示传入的 Presenter 类型，实现了IView。\n\n​\t页面初始化流程，不需要的方法可以不实现。\n\n```java\n    /**\n     * 生命周期 onCreate，Activity 启动时调用。\n     * 这里统一调用了一系列初始化方法，下面会解释每个方法作用。\n     */\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        this.savedInstanceState = savedInstanceState;\n\n        // 获取是否使用转场动画\n        if(getIntent()!=null){\n            startShareAnim = getIntent().getBooleanExtra(start_share_ele,false);\n        }\n\n        // 添加到全局Activity管理器中（方便统一关闭、管理Activity）\n        AppActivityManager.getInstance().add(this);\n\n        // 第一步：初始化第三方SDK（可选）\n        initSDK();\n\n        // 第二步：设置布局，比如 setContentView(R.layout.xxx)\n        onCreateActivity();\n\n        //第三步：创建 Presenter 对象\n        mPresenter = initInjector();\n\n        // 第四步：将当前View绑定到Presenter上（用于通知刷新）\n        attachView();\n\n        // 第五步：初始化数据（如适配器、变量等）\n        initData();\n\n        // 第六步：绑定控件（findViewById）\n        bindView();\n\n        // 第七步：绑定事件（点击、刷新等逻辑）\n        bindEvent();\n\n        // 第八步：发起首次请求，比如网络加载书架\n        firstRequest();\n    }\n```\n\n​\t还写好了页面的跳转功能，也就是启动新Activity并带动画效果的方法，有多种，适配多种情况下的使用需求。\n\n```java\n////////////////////////////////启动Activity转场动画/////////////////////////////////////////////\n\n    protected void startActivityForResultByAnim(Intent intent, int requestCode, int animIn, int animExit) {\n        startActivityForResult(intent, requestCode);\n        overridePendingTransition(animIn, animExit);\n    }\n\n\n\n    //protected代表它的子类可以调用\n    protected void startActivityByAnim(Intent intent, int animIn, int animExit) {\n        startActivity(intent);\n        overridePendingTransition(animIn, animExit);\n    }\n\n    protected void startActivityForResultByAnim(Intent intent, int requestCode, @NonNull View view, @NonNull String transitionName, int animIn, int animExit) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            startActivityForResult(intent, requestCode, ActivityOptions.makeSceneTransitionAnimation(this, view, transitionName).toBundle());\n        } else {\n            startActivityForResultByAnim(intent, requestCode, animIn, animExit);\n        }\n    }\n\n    protected void startActivityByAnim(Intent intent, @NonNull View view, @NonNull String transitionName, int animIn, int animExit) {\n        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {\n            intent.putExtra(start_share_ele,true);\n            startActivity(intent, ActivityOptions.makeSceneTransitionAnimation(this, view, transitionName).toBundle());\n        } else {\n            startActivityByAnim(intent, animIn, animExit);\n        }\n    }\n\n    public Context getContext(){\t\t//实现的IView方法\n        return this;\n    }\n\n    public Boolean getStart_share_ele() {\n        return startShareAnim;\n    }\n```\n\n​\t什么是“共享元素动画”？简单说，就是两个页面**“共用一个东西”**，这个东西在切换页面时会**动起来，看起来很自然、酷炫**。更加详细的讲解可以百度。\n\n\n\n\n\n\n\n​\t后面还有**BaseFragment**、**BaseModelImpl**、**BasePresenterImpl**、**RetryIntercepter**类，改天再解析，今天学习任务结束！\n","tags":["安卓开发学习"],"categories":["开发"]},{"title":"阅读APP项目学习——2","url":"/2025/06/22/阅读项目学习/安卓项目学习2/","content":"\n​\t欢迎页开始后，就进入主体**MainActivity**中，查看源码可以发现，其使用了众多自定义的其他类。\n\n​\t\n\n### 概述\n\n​\t先大体通过AI分析一波，看看这个主页面在干什么。\n\n- 页面初始化和布局设置：继承自 **MBaseActivity<IMainPresenter>**，采用 MVP 架构设计（视图层 **MainActivity** 负责UI，**IMainPresenter** 负责业务逻辑）。初始化页面上的控件，如应用logo、几个功能按钮（打赏、设置、书库、添加书籍、下载）、刷新列表控件（**RefreshRecyclerView**）等。\n\n- 显示书架列表：使用**RefreshRecyclerView**来展示书架内容，使用自定义的**BookShelfAdapter**作为列表的适配器，再通过布局管理器**LinearLayoutManager**来控制**RecyclerView**布局。\n- 刷新和加载数据：绑定刷新监听器（**OnRefreshWithProcessListener**）来实现下拉刷新书架数据，刷新时调用**mPresenter.queryBookShelf(true)**请求最新数据。同时处理刷新完成和刷新错误的回调，并更新UI和进度条。\n- 事件处理：给首页的各个按钮绑定点击事件：设置按钮弹出代理设置窗口；下载按钮弹出下载列表窗口；书库按钮跳转到书库界面（**LibraryActivity**）；添加书籍按钮跳转到导入书籍界面；打赏按钮预留了点击事件，具体逻辑没写。给书架列表的每个书籍绑定了点击事件：点击跳转到阅读界面；长按跳转到书籍详情界面，并带动画效果。书架中点击“去选书”会跳转到书库。\n- 管理警告信息弹窗：页面上有一个警告信息区域（**flWarn**），可以通过关闭按钮隐藏。\n- 处理系统按键事件：捕获返回键，实现“连续两次按返回键退出应用”的交互逻辑。\n- 生命周期管理：在 **onDestroy** 里做资源销毁，比如关闭弹窗。\n\n\n\n> ​\t上面比较陌生的概念有“适配器”，这是什么东西啊？\n>\n> ​\t举个简单的例子：你想在家里的书架上摆书，RecyclerView就是书架，适配器就是按顺序拿书，一本一本摆放书籍的人，书本的数据就是你手里的书。没有适配器，你的书架就不知道摆哪些书，也不知道怎么摆。\n\n\n\n\n\n### 逻辑解读\n\n​\t\n\n```java\n//成员变量声明\n    private ImageView ivLogo;           //应用logo图标\n    private ImageButton ibMoney;        //打赏按钮\n    private ImageButton ibSettings;     //设置按钮\n    private ImageButton ibLibrary;      //书库按钮\n    private ImageButton ibAdd;          //添加书籍按钮\n    private ImageButton ibDownload;     //下载按钮\n\n    private RefreshRecyclerView rfRvShelf;\n    private BookShelfAdapter bookShelfAdapter;\n\n    private FrameLayout flWarn;         //警告信息布局（弹出框）\n    private ImageView ivWarnClose;      //关闭警告按钮\n\n    private DownloadListPop downloadListPop;        //下载列表弹窗对象\n    private ProxyPop proxyPop;          //代理设置弹窗对象\n```\n\n​\tImageView是安卓里面用来显示图片的控件，就是一个”图片框“，专门用来在界面上展示图片，比如应用图标、照片、按钮图标等等，只负责显示图片，不响应点击事件（当然，你可以给它加点击事件，让它像按钮一样用）。\n\n​\tImageButton就是有图片的按钮。\n\n​\t其他就是自定义的组件了。\n\n\n\n​\t\n\n​\t看到具体的方法，**initInjector**是在初始化一个Presenter对象，然后返回一个**MainPresenterImpl**实例，负责与界面业务逻辑交互。\n\n​\t**onCreateActivity**设置界面的布局文件。\n\n​\t**initData**初始化数据，创建书架适配器实例。\n\n​\t**dispatchTouchEvent**处理触摸事件，调用父类的方法，套壳函数。\n\n​\t**bindView**绑定界面控件（找控件、实例化），找到布局里的各种控件（按钮、列表、弹窗等），并关联到变量，给书架列表 `RecyclerView` 设置适配器和布局管理器。\n\n​\t**bindEvent**绑定各种事件监听器。\n\n​\t**bindRvShelfEvent**给书架的刷新控件绑定刷新监听。\n\n​\t**firstRequest**首次加载数据，应用打开时调用。\n\n​\t**refreshBookShelf**将新的书籍列表数据传给适配器，更新显示。\n\n​\t**activityRefreshView**触发书架刷新动作，让刷新控件开始刷新动画并调用刷新逻辑。\n\n​\t**refreshFinish**刷新结束，隐藏刷新动画。\n\n​\t**refreshError**刷新错误时调用。\n\n​\t**refreshRecyclerViewItemAdd**刷新时进度条+1。\n\n​\t**setRecyclerMaxProgress**设置刷新进度条的最大值。\n\n​\t**onKeyDown**按键事件处理，用户按返回键时，调用 `exit()` 方法，实现“再按一次退出程序”的逻辑。\n\n​\t**onDestroy**资源销毁时调用，清理一些弹窗的资源，防止内存泄漏。\n\n​\t**exit**退出程序的逻辑，如果2秒内第二次按返回键，则退出程序，否则提示“再按一次退出程序”。\n\n\n\n\n\n### 前端页面复现\n\n​\t看到XML文件，里面使用到一个自定义的组件**com.monke.monkeybook.widget.refreshview.RefreshRecyclerView**，\n\n下图中的空白区域就是这个组件的位置。当然也包括一个作者自己开源的沉浸框，需要引用依赖。\n\n​\t里面的布局很清晰明了，沉浸框包裹最外层，然后一个垂直方向的线性布局来隔分上下页面，里面再由水平的线性布局来展示顶部，下面就是书架区。\n\n![image-20250622115453885](/pictures/novelReader_app/image-20250622115453885.png)\n\n​\t需要导入对应的drawable里面的XML文件、layout里面的其他XML文件、values里面的XML文件。然后写入**RefreshRecyclerView**类、**RefreshProgressBar**类、**RefreshRecyclerViewAdapter**抽象类、**OnRefreshWithProgressListener**接口、**OnLoadMoreListener**接口、**BaseRefreshListener**接口，还有**BookContentView**类，因为这个类又引出一堆其他的类和接口。太麻烦了。\n\n​\t先放着BookContentView不管吧，还有其他几个**BitIntentDataManager**、**MApplication**、**ReadBookControl**都有点问题啊！这样分析也太麻烦了。不能按照这个逻辑搞下去。\n\n\n\n\n\n### 具体功能流程分析\n\n​\t先从最简单的退出功能来说吧，不然都没法读下去了。\n\n```java\n\t@Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (keyCode == KeyEvent.KEYCODE_BACK) {\n            exit();\n            return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n\tprivate long exitTime = 0;\n\tpublic void exit() {\n        if ((System.currentTimeMillis() - exitTime) > 2000) {\n            Toast.makeText(getApplicationContext(), \"再按一次退出程序\",\n                    Toast.LENGTH_SHORT).show();\n            exitTime = System.currentTimeMillis();\n        } else {\n            finish();\n            System.exit(0);\n        }\n    }\n```\n\n​\t当用户摁下”返回键“，触发onKeyDown方法，会调用exit方法，导致退出程序。keyCode表示当前被按下的按键的代码（编号），KeyEvent.KEYCODE_BACK是安卓系统定义的常量，代表”返回键“的按键代码。System.currentTimeMillis方法返回一个”long“类型的数字，表示从“1970年1月1日午夜”（称为“Unix纪元”）开始，到当前时刻所经过的毫秒数。\n\n​\t第一次摁下”返回键“会设置exitTime为当前时间，然后需要在两秒内再摁一次，才进入else里面。\n\n​\tfinish方法，**只是告诉系统“关闭这个Activity”，但它是异步的，不会立即停止当前方法的执行**。`finish()` 会请求系统去销毁Activity（触发生命周期`onPause() -> onStop() -> onDestroy()`），但是这个过程是在系统消息队列中排队执行的，并不会马上跳出当前方法或终止线程，但是这个过程是在系统消息队列中排队执行的，并不会马上跳出当前方法或终止线程。\n\n\n\n\n\n\n\n### AI总结主页面功能\n\n​\t后面就根据这些功能，开始进行分块讲解，包括代码跟踪讲解，这样会更加让我专注于功能的实现。\n\n> ### 1. 界面初始化和视图绑定\n>\n> - **加载界面布局**（`setContentView`），让页面显示出来\n> - **查找并绑定控件**，比如logo图标、按钮、书架列表等\n> - **初始化书架适配器**，管理书籍列表的显示\n>\n> ### 2. 数据展示和刷新\n>\n> - **展示书架列表数据**，把数据加载到书架适配器里，显示在列表中\n> - **支持下拉刷新**，用户下拉列表时，重新请求数据，刷新书架内容\n> - **刷新进度反馈**，通过进度条显示刷新进度，提高用户体验\n>\n> ### 3. 用户交互处理\n>\n> - **按钮点击事件**\n>   - 点击“设置”按钮弹出代理设置窗口\n>   - 点击“下载”按钮弹出下载列表\n>   - 点击“打赏”按钮触发打赏操作（这里没实现具体逻辑）\n>   - 点击“书库”按钮进入书库页面\n>   - 点击“添加书籍”按钮进入导入书籍页面\n> - **书架书籍点击**\n>   - 点击书籍跳转到阅读页面，打开书籍\n>   - 长按书籍跳转到书籍详情页面，带动画效果\n>\n> ### 4. 弹窗与提示\n>\n> - 弹出代理设置和下载列表弹窗，方便用户操作\n> - 警告信息框的显示和关闭，提醒用户重要信息\n>\n> ### 5. 生命周期与退出\n>\n> - 监听手机返回键，防止误操作退出\n> - 实现“双击返回键退出程序”的逻辑，提高用户体验\n> - 退出时释放资源，防止内存泄漏\n>\n> ​\t\t","tags":["安卓开发学习"],"categories":["开发"]},{"title":"阅读APP项目学习——1","url":"/2025/06/21/阅读项目学习/安卓项目学习1/","content":"\n# \t前言\n\n​\t该阅读项目是[MONKOVEL](https://github.com/ZhangQinhao/MONKOVEL)，我将分析学习其项目设计和JAVA代码，我没什么语言基础，也没有开发经验，此系列将记录我在这个项目中自学到的知识。\n\n​\t\n\n# \t正文\n\n​\t先看到`AndroidManifest.xml`文件，查看APP存在多少个Activity（界面）：`WelcomeActivity`类负责欢迎界面，实现一个动画的效果。\n\n```xml\n<activity\n            android:name=\".view.impl.WelcomeActivity\"\n            android:screenOrientation=\"portrait\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n```\n\n​\t之后会跳转到主界面。\n\n```java\npublic void onAnimationEnd(Animator animation) {\n                startActivityByAnim(new Intent(WelcomeActivity.this, MainActivity.class), android.R.anim.fade_in, android.R.anim.fade_out);\n                finish();\n            }\n```\n\n\n\n​\t`MainActivity`负责主页面的呈现，展示从各个网站解析来的书籍；`SearchActivity`类负责关键词搜索，可能会调用网络接口或本地数据库查询；`DownloadService`负责后台下载任务，通常是service类型，不阻塞UI，管理下载队列，处理断点续传等等；还有`LibraryActivity`书架页面、`ChoiceBookActivity`书籍选择页面、`BookDetailActivity`书的详细详细、`ReadBookActivity`负责阅读界面、`ImportBookActivity`负责本地导入书籍。\n\n\n\n\n\n## 复现\n\n​\t首先可以单独复现出welcome界面，先处理好xml文件，会需要导入包：注意新的写法是`implementation(\"...\")`。写入`activity_welcome.xml`文件，复制图片资源到res目录下，改写系统默认的`AndroidManifest.xml`文件，删除系统给的`MainActivity`部分。后面从`view.impl.WelcomeActivity`开始慢慢抄入其他文件，暂时不需要的功能可以注释掉。\n\n​\t\n\n### MVP架构\n\n​\t实现`IView`和`IPresenter`接口，这是MVP设计架构中常见的基础接口。\n\n> MVP的思想是：View（视图）：负责“显示”和“用户交互”。\n>\n> ​\t\tPresenter（中间人）：负责“处理逻辑”和“沟通”。\n>\n> ​\t\tModel（模型）：负责“数据和业务逻辑”。\n>\n> MVP 就是把“显示界面”和“业务逻辑”拆开，让代码更整洁、更容易维护\n\n> #### 真实开发中：\n>\n> - 你的手机界面就是 View，负责显示按钮、列表等\n> - 代码里写的 Presenter 负责监听按钮，处理业务逻辑\n> - Model 负责数据存取，比如从数据库拿数据，或者调用网络接口\n\n​\t\n\n​\t\n\n```java\npublic interface IView {\n    public Context getContext();\n}\n```\n\n​\t看到`IView`的接口方法，`getContext`方法，什么是Context？看一下ChatGpt的看法。\n\n> - **Context 就像手机里的“万能钥匙”或者“工具箱”**，它告诉你“现在在哪个环境下”，可以帮你访问很多系统服务、资源，甚至打开新页面、显示提示消息。\n> - 假设你在一个大商场里，Context 就像你的商场会员卡，你拿着会员卡，商场才知道你是谁、你在哪个店铺、你可以用哪些优惠，通过会员卡，你可以去不同的柜台（服务）办事情，比如买东西、退货、查余额。\n> - 在代码里 Context 能做什么？打开新界面、显示弹窗、访问资源、获取系统服务（比如网络、传感器）、访问文件、数据库等等。\n> - 举个简单例子，`Toast.makeText(context, \"Hello!\", Toast.LENGTH_SHORT).show();`，这句话的 `context` 就告诉系统，“你现在在哪个环境下显示这个弹窗”，系统才能正确地把弹窗显示在屏幕上。\n> - 常见的 Context 类型：**Activity**，它本身就是一个 Context，代表一个界面；**Application**，整个应用程序的全局 Context；**Service**，后台服务的 Context。\n\n​\t`getContext`是给谁用的？————给 **Presenter（业务逻辑层）用的**，Presenter 通过 `IView.getContext()` 拿到这个环境（Context），就能做很多事情。\n\n​\t看看例子，很清楚。\n\n```java\npublic class MainPresenter implements IPresenter {\n    private IView view;\n    @Override\n    public void attachView(@NonNull IView iView) {\n        this.view = iView;\n    }\n    @Override\n    public void detachView() {\n        this.view = null;\n    }\n    public void showMessage() {\n        // 通过view拿Context来显示Toast\n        Toast.makeText(view.getContext(), \"Hello MVP!\", Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n\n\n\n\n\n\n```java\npublic interface IPresenter {\n    /**\n     * 注入View，使之能够与View相互响应\n     */\n    void attachView(@NonNull IView iView);\n    /**\n     * 释放资源，如果使用了网络请求 可以在此执行IModel.cancelRequest()\n     */\n    void detachView();\n}\n```\n\n​\t看到`IPresenter`接口，`attachview`就是提供的用来绑定view和presenter的方法。\n\n​\t什么时候会调用？  一般是在界面刚创建或刚准备好跟 Presenter 交互的时候调用，比如 `Activity` 的 `onCreate()` 或 `onStart()` 里。\n\n​\t谁来调用？  通常是 **View（界面层，比如 Activity）自己调用**，或者有时是在创建 Presenter 的时候由框架或代码调用。\n\n​\t为什么？  因为 Presenter 需要知道它服务的是哪个 View，才能让 View 显示数据或者响应用户操作。\n\n\n\n​\t下面是AI举得小例子，很了然了。\n\n```java\npublic class MainActivity extends AppCompatActivity implements IView {\n    private IPresenter presenter;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        presenter = new MainPresenter();\n        presenter.attachView(this);  // 把自己（View）传给Presenter，绑定关系建立\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        presenter.detachView();  // 解绑，防止内存泄漏\n    }\n    // 实现IView的方法\n    @Override\n    public Context getContext() {\n        return this;\n    }\n}\n```\n\n\n\n​\t我们查看presenter和view文件夹也发现了这个一一对应的关系，除了欢迎界面（因为没有交互，所以不需要）。\n\n![image-20250621210554075](/pictures/novelReader_app/image-20250621210554075.png)\n\n\n\n### 其他子类设计\n\n​\t`BaseApplication`基础类。\n\n​\t`AppActivityManager`是一个“Activity管理工具类”：记录、管理当前所有的Activity，能关闭指定的Activity、能判断Activity是否存在、通过弱引用避免内存泄露。\n\n​\t`BaseActivity`是“通用Activity模板”，它封装了 Activity 常用的功能、生命周期管理、和 Presenter 的绑定逻辑，它的作用就是：把每个页面都要重复写的代码（如固定的方法调用，Activity转场动画调用等等），统一写在这个“父类”里，子类只需要关注页面自己的功能实现，省时省力！\n\n​\t`MBaseActivity`是继续添加友盟统计的一个抽象类，能够统计用户的使用情况。\n\n​\t\n\n\n\n​\t再抄下`activity_welcome.xml`布局文件，应该就可以展示第一个界面的效果了。\n","tags":["安卓开发学习"],"categories":["开发"]},{"title":"ISCTF2024","url":"/2025/06/05/ISCTF2024/RE/","content":"\n# Ezre\n\n> ​\t一个简单的维吉尼亚加密，看了半天没看出来，在强行写解密算法后，才突然发现。\n\n------\n\n\n\n# 《回忆安魂曲》三——mainn.exe\n\n\n\n> ​\t迷宫类题目，无壳64位。槽点就是将移动键换成了“love”四个字符，然后迷宫对应的字符串在结尾多给了几个，起到迷惑性效果，差点让我搞不清行列数，还有行坐标从0开始，列坐标从0开始，起始点坐标（1，1）。开始直接把我绕晕。\n>\n> ​\t确定迷宫后，又复习了DFS算法。收获不少。\n\n```python\nmaze_str = \"\"\"###############################P#...............#...#.......#.#####.###.#####.#.###.#####.#.....#...#.#.....#...#.#...#.#####.#.###.#.#######.#.#.###.#C..#.#.#...#.#...#...#.#.#...#.#.#.#.#.###.#.#.#.###.#.#.#.#.#.#.#.#...#...#.#.......#.#.#.###.#.###.#####.#########.###.#...#...#.....#.#.......#...#.#.#####.#####.#.#.#####.###.#...#...#...#...#...#...#.#...#.###.#.###.#.#######.#.#.#.#.#...#.#.#...#.#...#...#...#.#.###.#.#.#####.#.#.#.#######.###.#...#.....#...#.#.#...#.....#.#########.#####.#.###.#.###.#.#.....#.#...#...#...#...#.#.#.#.#.#.#.###.#.#####.###.#.#.#...#.#...#.#...#...#...#...#.#.###.###.#.#####.#.###.###.#.#...#.#.#.......#.#...#.#...#.#####.#.#######.#.#####.#.###.#...#.#.......#.#...#...#.#..E#.#.#.#.#######.###.#.#####.#.#.#...#.............#.....#.#.#.###############.#######.#.#.#.........#...#...#.....#...#.#.#######.#.#.#####.#.#######.#.......#...#.......#.........\"\"\"\n\nfor i in range(30):\n    for j in range(30):\n        print(maze_str[i*30+j], end=' ')\n    print()\n\n\nmaze = []\nfor i in range(30):\n    maze_row = []\n    for j in range(30):\n        maze_row.append(maze_str[i*30+j])\n    maze.append(maze_row)\n\nstart = (1,1)\n\ndef dfs(maze, x, y,path):\n    if maze[x][y] == 'E':\n        return True\n    if x < 0 or x >= len(maze) or y < 0 or y >= len(maze[0]) or maze[x][y] == '#' or maze[x][y] == 'C':\n        return False\n\n    maze[x][y] = '#'\n\n    directions = [(-1,0), (0,-1), (1,0), (0,1)]\n    directions_str = ['l', 'v', 'o', 'e']\n    for i in range(4):\n        dx = directions[i][0]\n        dy = directions[i][1]\n        path.append(directions_str[i])\n        if dfs(maze, x+dx, y+dy,path):\n            return True\n        path.pop()\n\n    maze[x][y] = '.'\n    return False\n\ndef find_path():\n    path = []\n    if dfs(maze, start[0], start[1], path):\n        return path\n    else:\n        return \"No path found\"\n\nans = find_path()\nans = ''.join(ans)\nprint(ans)\n```\n\n------\n\n\n\n# **找啊找**——zhao.exe\n\n> ​\t直接拖入IDA发现只有很少几个函数，于是去查壳发现UPX壳，然后直接-d脱壳失败，拖入HxD发现标志位被改成APK了，改回来就成功脱壳了。\n>\n> ​\t再拖入IDA中就正常了，逻辑很简单，查看加密逻辑，先大小写字母替换，再异或一下。静态分析时直接去数据节查看时，得到一组数据，然后写python代码，跑出来提示为错误的flag，是出题人挖的一个坑。\n>\n> ​\t反复查看加密逻辑发现没有问题，最后动态调试，在比较之前查看数据，发现程序里存储的加密数据被改了，看来是程序在运行初始化时才给出真正的加密flag。取出数据，跑解密脚本就ok了。\n>\n> ​\t还是动调发现问题。\n\n------\n\n\n\n# py不好，会被ban\n\n\n\n> ​\tpython的exe程序。先使用Pyinstxtractor解出pyc，然后直接托在线平台解出py。我开始找的平台解不出来，我还在猜是不是题目加难度了，导致文件进行了一定的修改，不能直接解出来。原来是工具不行！最后看wp才发现这个网站。\n>\n> ​\t解出py后直接反向写解密逻辑即可解密。\n\n\n\n------\n\n\n\n# 你知道.elf文件吗\n\n> ​\t跑不起来，签到题，没有技术含量，算了。\n\n\n\n------\n\n\n\n# 《回忆安魂曲》二——test11\n\n> ​\t一个ELF文件，使用IDA远程调试，收获到了IDA调试ELF程序的方法，进一步增加了动态调试的经验，认识到一种干扰编译的方法，就是在调用程序时，不直接使用call，而是将函数首地址加载进寄存器，然后使用call寄存器调用，这样IDA分析不出来，只有动调能看到其中的跳转逻辑。\n>\n> ​\t查阅知道，这是一种“控制流平坦化”的反编译技术，通过主分发器来控制程序基本块的执行流程。\n>\n> ​\t得知flag长度为36位，然后enc加密，动态调试分析加密逻辑。确定是逐字节加密，假设当前字符下标为i，字符串数组为str。有个密钥key为字符串“i_can_reverse_but_i_can_not_have_you“。\n>\n> ​\t最终得到的加密数据为：[234, 12, 26, 17, 246, 44, 29, 62, 23, 53, 49, 41, 244, 57, 57, 211, 195, 45, 0, 16, 48, 61, 204, 0, 211, 192, 75, 198, 17, 199, 41, 62, 186, 96, 144, 52]\n>\n> - str[i] = str[i] ^ (0x66 + i) ^ 0x52\n>- str[i] = str[i] + 6\n> - str[i] = str[i] ^ (key[i] + i)\n\n```python\nenc = [234, 12, 26, 17, 246, 44, 29, 62, 23, 53, 49, 41, 244, 57, 57, 211, 195, 45, 0, 16, 48, 61, 204, 0, 211, 192, 75, 198, 17, 199, 41, 62, 186, 96, 144, 52]\nkey = 'i_can_reverse_but_i_can_not_have_you'\n\nfor i in range(len(enc)):\n    enc[i] = (enc[i] ^ (ord(key[i]) + i)) & 0xff\n    enc[i] = (enc[i] - 6) & 0xff\n    enc[i] = (enc[i] ^ 0x52 ^(0x66 + i)) & 0xff\n    print(chr(enc[i]), end='')\n    #ISCTF{as_her_never_will_come_back!!}\n```\n\n------\n\n\n\n# 《回忆安魂曲》四——文件夹：初识风仙儿\n\n> ​\t解压得到一个main.py和so文件。这是一个`Cpython`逆向题，我是第一次遇见，先跟着WP学习，但是第一步通过python中的`help函数`查看模块就出问题了。为什么呢，因为几个虚拟机的python版本不对，需要3.10的，而且本机是windows系统，一直是要么导入错系统test模块，要么导入不进，唉，环境愁死人！下载python3.10还把我的ubuntu20.04给干崩了，被我直接删了。**之后再干这种活要拍快照了**！最后在ubuntu24.04中下载好了，然后就导入进去了。真的被环境折磨惨了啊。\n>\n> ​\t看了教程，都是神仙，有的直接猜出加密算法，有的一点点死看IDA中的几千行`Cython代码`，有的凭空生成了so对应的python源代码。一个都行不通，最后在网上找了个AI代码调整，把原本的几千行`Cython`给优化了，出了一个简化的C语言版，并且整理出了核心逻辑，于是我直接看核心加密逻辑，很清晰，然后写解密就出了。\n\n```python\nhack_data = [27, 16, 43, 29, 127, 46, 51, 102, 50, 1, 112, 50, 53, 101, 57, 1] \nkey = 'H1m' sbox = [1, 14, 4, 13, 10, 2, 5, 8, 7, 6, 9, 12, 15, 3, 11, 0]  \nflag_list = [0] * 16  \nfor i in range(len(sbox)):\n    tmp = hack_data[i] ^ ord(key[i % len(key)])\n    flag_list[sbox[i]] = tmp\nfor i in range(len(flag_list)):\n    print(chr(flag_list[i]), end='')\n```\n\n------\n\n\n\n# MIPS\n\n> ​\t一种新的指令集，对应的汇编语言也不一样，需要重新学习。\n\n​\t单独出一个wp来记录学习过程中得到的知识。\n\n------\n\n\n\n\n\n# 桀桀桀\n\n> ​\t`rep stosd是一条高效的字符串操作指令，适用于快速初始化或填充内存区域，edi保存填充地址，ecx保存填充次数，eax保存单次填充值。`\n>\n> ​\t这一题很有意思啊，有花指令、TLS、伪随机数和魔改tea，有很多可学的点，在做题的时候，由于对花指令的不够全面的了解，和对TLS的不全面了解，导致我一直困在对非核心部分的探索学习中，始终未能抓住主要逻辑，最后导致身心疲惫。\n>\n> ​\t于是决定参照WP和网上的资料，好好恶补一下这些方面的知识，并且记录下来。\n\n```python\nfor i in range(0x4119E2, 0x4119E7):\t\t#IDA的patch脚本，记住使用到的函数名就好。\n    idc.patch_byte(i, 0x90)\n```\n\n专门出一个WP，记录一下这些难题。\n\n------\n\n\n\n# 嘿嘿嘿\n\n​\t无壳，验证长度32位，然后进入140001850，有SMC保护技术，我们修改标志位绕过反调试，\n\n![image-20250521110206759](/pictures/ISCTF2024/image-20250521110206759.png)\n\n![image-20250521110250703](/pictures/ISCTF2024/image-20250521110250703.png)\n\n​\t这里也没有调用，我们先不用管140001A0函数，继续去main函数中看程序逻辑。看到1400017B0函数，马上就调用了解密出的函数，参数分别是字符串\"Welcome_to_ISCTF\"，还有两个空数组。\n\n![image-20250521110613803](/pictures/ISCTF2024/image-20250521110613803.png)\n\n​\t先看140001440，对字符串进行异或，存储到a2中，140003270数据可以直接看到。这里需要注意的是，在IDA中数据以小端保存，尽管字符串显示的顺序是“Welcome_to_ISCTF”，但在栈帧中保存的顺序其实是cleW......，需要每4个字节逆序，这样才是a1[i]的值。\n\n![image-20250521110827346](/pictures/ISCTF2024/image-20250521110827346.png)\n\n![image-20250521110918291](/pictures/ISCTF2024/image-20250521110918291.png)\n\n​\t接着进入1400014A0函数，a1是空数组，a2是才加密的中间密钥的指针。如果只是出flag的话，这里没有必要深入分析了，直接取最终密钥就行了。\n\n![image-20250521104520689](/pictures/ISCTF2024/image-20250521104520689.png)\n\n​\t回到主函数，1400017B0函数才是加密的地方，继续看140001630，由于是对明文进行了分块的，分成2个16字节加密的。\n\n![image-20250521113825145](/pictures/ISCTF2024/image-20250521113825145.png)\n\n​\t里面两个函数，一个加密，一个逆序复制。\n\n![image-20250521112328705](/pictures/ISCTF2024/image-20250521112328705.png)\n\n​\t加密以4字节为一个单位，将16字节分为4个元素，加密32轮，整体加密32/4=8轮。加密方式就是异或1400013F0的返回值。\n\n![image-20250521112403260](/pictures/ISCTF2024/image-20250521112403260.png)\n\n​\t\ta2确定是1。a1是那群异或得到的值。\n\n![image-20250521113204681](/pictures/ISCTF2024/image-20250521113204681.png)\n\n​\t这里有一个映射表，256字节。\n\n![image-20250521113218351](/pictures/ISCTF2024/image-20250521113218351.png)\n\n​\t映射后的值为a1.\n\n![image-20250521113233640](/pictures/ISCTF2024/image-20250521113233640.png)\n\n​\t这里其实是一种扩展的左移并记录溢出位的操作。\n\n![image-20250521113401853](/pictures/ISCTF2024/image-20250521113401853.png)\n\n再看这个函数，以4字节为整体进行逆序，因为每次加密只有16字节参与，所以只需要移动4次。\n\n![image-20250521113539461](/pictures/ISCTF2024/image-20250521113539461.png)\n\n看回主函数，通过调试确定，比对的时候密文端序不变，解密脚本中就直接使用数据。\n\n![image-20250521113646251](/pictures/ISCTF2024/image-20250521113646251.png)\n\n最后完全不看WP，自己写出来了，Exp如下。花了4个小时吧。\n\n```c\n#include <stdio.h>\n#include <stdlib.h> \n#include <stdint.h>\n\n//密钥在动调的时候取出就行了。\nuint8_t key[128] = {64, 219, 65, 24, 40, 193, 230, 145, 203, 169, 18, 125, 170, 192, 199, 159, 157, 38, 46, 6, 157, 90, 123, 166, 146, 16, 175, 171, 169, 249, 251, 160, 135, 168, 171, 240, 25, 222, 93, 91, 231, 26, 172, 17, 30, 69, 73, 82, 201, 42, 246, 134, 66, 49, 108, 95, 150, 236, 129, 102, 94, 24, 255, 27, 69, 188, 182, 179, 250, 225, 54, 233, 113, 90, 12, 164, 92, 131, 61, 232, 59, 85, 99, 174, 230, 155, 235, 1, 32, 36, 55, 178, 65, 89, 177, 99, 76, 98, 54, 100, 188, 139, 221, 165, 68, 157, 191, 115, 242, 75, 56, 38, 65, 13, 123, 99, 220, 204, 61, 124, 51, 252, 15, 10, 176, 107, 255, 109};\n\n\n//取出就行了。\nuint8_t map[256] = {214, 144, 233, 254, 204, 225, 61, 183, 22, 182, 20, 194, 40, 251, 44, 5, 43, 103, 154, 118, 42, 190, 4, 195, 170, 68, 19, 38, 73, 134, 6, 153, 156, 66, 80, 244, 145, 239, 152, 122, 51, 84, 11, 67, 237, 207, 172, 98, 228, 179, 28, 169, 201, 8, 232, 149, 128, 223, 148, 250, 117, 143, 63, 166, 71, 7, 167, 252, 243, 115, 23, 186, 131, 89, 60, 25, 230, 133, 79, 168, 104, 107, 129, 178, 113, 100, 218, 139, 248, 235, 15, 75, 112, 86, 157, 53, 30, 36, 14, 94, 99, 88, 209, 162, 37, 34, 124, 59, 1, 33, 120, 135, 212, 0, 70, 87, 159, 211, 39, 82, 76, 54, 2, 231, 160, 196, 200, 158, 234, 191, 138, 210, 64, 199, 56, 181, 163, 247, 242, 206, 249, 97, 21, 161, 224, 174, 93, 164, 155, 52, 26, 85, 173, 147, 50, 48, 245, 140, 177, 227, 29, 246, 226, 46, 130, 102, 202, 96, 192, 41, 35, 171, 13, 83, 78, 111, 213, 219, 55, 69, 222, 253, 142, 47, 3, 255, 106, 114, 109, 108, 91, 81, 141, 27, 175, 146, 187, 221, 188, 127, 17, 217, 92, 65, 31, 16, 90, 216, 10, 193, 49, 136, 165, 205, 123, 189, 45, 116, 208, 18, 184, 229, 180, 176, 137, 105, 151, 74, 12, 150, 119, 126, 101, 185, 241, 9, 197, 110, 198, 132, 24, 240, 125, 236, 58, 220, 77, 32, 121, 238, 95, 62, 215, 203, 57, 72};\n\n\nuint32_t sub_1400012F0(uint32_t a1, int16_t a2){\n    for(int16_t i=0;i<a2;i++){\n        a1 = a1 / 0x80000000 + 2 * a1;\n    }\n    return a1;\n}\n\nuint32_t sub_140001340(uint32_t a1){\n    return sub_1400012F0(a1,24) ^ sub_1400012F0(a1, 18) ^ sub_1400012F0(a1, 10) ^ sub_1400012F0(a1, 2) ^ a1;\n}\n\n//完全照抄加密时的逻辑就行，这里是求异或值的地方，我们的目标是要找出一样的异或值，所以要和加密时的逻辑一样。\nuint32_t get_xor(uint32_t seed){\n    uint32_t t = map[(uint8_t)seed] + (map[(uint8_t)(seed>>8)] << 8) + (map[(uint8_t)(seed>>16)] << 16) + (map[(uint8_t)(seed>>24)] << 24);\n    return sub_140001340(t);\n\n}\n\n\n//仿照加密过程，其实就是一个异或操作，只是这个异或的密钥经过复杂的运算得出的\nvoid  decrypt(uint32_t *enc, uint8_t *key){\n    uint32_t *k = (uint32_t*)key;\n    for(int i=31;i>=0;i--){\n        enc[i%4] ^= get_xor(k[i] ^ enc[(i+3)%4] ^ enc[(i+2)%4] ^ enc[(i+1)%4]);\n    }\n}\n\n\nint main(){\n    \n    //密文最好是调试的时候看，断点下在比较的地方。\n    uint32_t enc[] = \t\t\t\t{0xA8F44759,0xCDB824F2,0x32FB3C01,0x42BEFFE1,0x3EC30B40,0xE094AA46,0x2AEA2B,0x362C0888};\n    uint32_t enc1[8];\n    \n    \n    for(int i=0;i<8;i++){\n        int j = i % 4;\n        enc1[i] = enc[(i/4)*4 + (3-j)];\n    }\n\n    for(int i=0;i<2;i++){\n        decrypt(enc1+i*4,key);\n    }\n\n    for(int i=0;i<8;i++){\t\t\t\t\t//这里开始是反的，还搞错了。字符串的大小端总是让我摸不着头脑。\n        printf(\"%c\",enc1[i]&0xFF);\n        printf(\"%c\",enc1[i]>>8&0xFF);\n        printf(\"%c\",enc1[i]>>16&0xFF);\n        printf(\"%c\",enc1[i]>>24&0xFF);\n    }\n\n    return 0;\n}\n```\n\n------\n\n# 萝卜子的螃蟹\n\n​\t\tRUST语言程序，可以使用IDA反编译打开，难点就是反编译代码很难看，需要配合动调确定程序的运行逻辑。有点累了，改天再写。\n\n​\t动调还是经验太少了，趁此机会，好好照着WP学习一下动调的经验。下面只总结了收获的经验，完整WP都有。\n\n\n\n- #### 通过提示字符串的交叉引用找到程序的主要逻辑函数。\n\n- #### 看到如下图所示的这种乱七八糟的函数名，看到如此难以读懂的伪代码，先单步调试找到input函数。并且，根据input函数中的参数值，找到存储输入flag的地址。参数是指针，要通过G键跳转到对应的内存地址处查看。\n\n![image-20250522122253781](/pictures/ISCTF2024/image-20250522122253781.png)\n\n- #### 找到INPUT之后，再酌情分析程序还有哪些重要部分。然后忽略其他操作，除开与输入flag相关的部分，其他都可以不管，需要什么可以靠动调直接读取值。\n\n- #### 看到长度比较和赋值部分，这一大堆数据很可能就是密文，但是不能着急，密文也是可以做处理的，不到最后比对的时候都不要完全确定密文。\n\n![image-20250522122710905](/pictures/ISCTF2024/image-20250522122710905.png)\n\n- #### 看到下面前两个函数都是对密文进行操作，v35->v40->v36，不用管。我们只需要锁定住我们的输入即可，v29就是输入字符串的指针，我们看到v29只在405F80参数处出现了，而且下面就是比对了。所以该题应该只在这个函数里面进行了处理。\n\n![image-20250522122830052](/pictures/ISCTF2024/image-20250522122830052.png)\n\n- #### 下面的比对操作，需要简单跟踪变量值确定变量代表的含义，在进入406AA0时下断点取出密文值即可。\n\n![image-20250522123228352](/pictures/ISCTF2024/image-20250522123228352.png)\n\n- #### 重点是怎么知道对输入的操作是什么样子的，在上面的v29处找到输入的flag，打下内存断点，这样每当程序去访问这个地址时就会触发断点，分别我们分析程序对flag做了什么处理。具体操作就是在数据头摁下F2下断点，然后填下数据长度就行。\n\n![image-20250522123655696](/pictures/ISCTF2024/image-20250522123655696.png)\n\n- #### 之后就可以看情况F9策马奔腾了，注意ntdll有时候回访问这个内存地址的，我们可以通过查看断点表，随时开启或关闭断点，记得配合程序断点，关闭内存断点，直接F9来跳过ntdll的访问，我们只关心主要逻辑对该地址的访问。跳出ntdll后，再开启内存断点。\n\n![image-20250522123845878](/pictures/ISCTF2024/image-20250522123845878.png)\n\n![image-20250522123934610](/pictures/ISCTF2024/image-20250522123934610.png)\n\n\n\n​\t最后复现WP，自己手动找到数据，解密成功。\n\n​\t通过本题，我学习到了内存断点找加密操作的方法，发现了通过G键进行内存跳转的功能。\n\n```python\ndata = \"A\" * 52\nenc_data = [105, 170, 63, 98, 219, 177, 5, 252, 176, 134, 189, 146, 177, 222, 70, 219, 183, 31, 150, 151, 6, 229, 101, 231, 47, 223, 159, 159, 159, 228, 116, 102, 218, 205, 139, 51, 99, 178, 172, 136, 66, 138, 47, 12, 150, 246, 201, 34, 207, 27, 86, 152]\n\nxor_key = []\nfor i in range(52):\n    xor_key.append(enc_data[i] ^ ord(data[i]))\n\n\nenc_flag =[97, 184, 61, 119, 220, 139, 54, 200, 130, 179, 163, 226, 196, 192, 106, 255, 155, 110, 165, 175, 20, 197, 66, 195, 49, 242, 191, 144, 185, 250, 19, 1, 196, 245, 165, 7, 125, 179, 159, 172, 92, 140, 94, 34, 179, 232, 200, 60, 220, 57, 35, 164]\nflag = \"\"\n\nfor i in range(52):\n    flag += chr(enc_flag[i] ^ xor_key[i])\n\nprint(flag)\n```\n","tags":["复现WP"],"categories":["CTF"]},{"title":"BaseCTF2024","url":"/2025/06/04/BaseCTF/BaseCTF2024_RE/","content":"\n\n\n------\n\n> **UPX mimi：**\n>\n> ​\t初步接触到了UPX加壳保护的知识和对应的脱壳工具，这是一种“压缩”保护壳，即将源程序代码进行压缩，然后配上解压缩代码，组成新的程序，即“UPX解压代码”+“压缩的源文件”。在程序启动时，会先执行UPX的解压代码，得到解压后的源文件，然后将控制流转移到源文件。\n\n> **ez_maze:**\n>\n> ​\t最基础的迷宫题目，从IDA中可以直接看到迷宫，人工就能得到路径。\n\n> **BasePlus:**\n>\n> ​\t无保护，直接拖入IDA，考察基础的阅读代码的能力，加密函数为Base64的一点点变化，对Base64加密后继续异或一下。很基础。第一次认真搓Base64的c语言代码，收获不少。\n\n> **Ez_Xor:**\n>\n> ​\t复习了大小端序的知识。\n>\n> ​\t“小端序”：低位有效字节保存在小地址。如0xDEADBEEF在内存中的顺序是（小地址）EF BE AD DE（大地址）。“大端序”相反。\n>\n> ​\t本题就是简单的流加密，生成密钥流然后加密。对应解密即可。\n\n> **UPX:**\n>\n> ​\t有壳，直接脱壳报错。学习到了，改标志位来保护加壳程序的手段，我们的反制操作就是打开文件，将对应的标志位从小写改回大写。之后就可以正常脱壳了。\n>\n> ​\t拖入IDA后，考察的是换表的Base64。唯一需要注意的点就是因为题目源码是C语言，在IDA字符串显示中给双引号全面加了转义符号的，不要搞错了。\n\n![image-20250425170632940](/pictures/BaseCTF2024/image-20250425170632940.png)\n\n> **lk:**\n>\n> ​\t比较大的线性方程组，考察python的z3solver库使用。\n\n> **喝杯下午茶：**\n>\n> ​\t标准的Tea加密，第一次使用C语言实现了该算法，收获不少。\n\n> **Ezpy:**\n>\n> ​\t考察python打包出的EXE程序。反编译出源码。\n>\n> ​\t再考察RC4加密。\n\n> **最简单的编码：**\n>\n> ​\t无保护技术，纯考验伪代码的阅读水平，耐下心来分析就好了。\n\n> **neuro爱数学：**\n>\n> ​\t\n\n> **RivestCipher:**\n>\n> ​\t考察标准RC4加密算法。\n\n> **ezAndroid:**\n>\n> ​\t收获到了逆向apk安装包的软件jadx，接触到了so文件（共享库）逆向，是一些没有接触过的操作。又要读奇怪的代码。唉！\n\n------\n\n# **UPX PRO MAX**\t\n\n​\t直接运行EXE程序，会出现下图的显示。\n\n![image-20250506132159230](/pictures/BaseCTF2024/image-20250506132159230.png)\n\nDIE也看到UPX壳。\n\n![image-20250506132311405](/pictures/BaseCTF2024/image-20250506132311405.png)\n\n直接上工具是不行的啊，报错了。\n\n跟着WP学习——**利用ESP定律x64dbg手脱UPX壳**。\n\n> “ESP定律”也称“堆栈平衡定律”\n>\n> 由于在程序自解密或者自解压过程中, 多数壳会先将当前寄存器状态压栈, 如使用`pushad`, 而在解压结束后, 会将之前的寄存器值出栈, 如使用`popad`. 因此在寄存器出栈时, 往往程序代码被恢复, 此时硬件断点触发（这就是我们要下硬件断点的原因），然后在程序当前位置, 只需要一些单步操作, 就会到达正确的OEP位置。\n>\n> 1. 程序刚载入开始 `pushad/pushfd`\n> 2. 将全部寄存器压栈后就设对 ESP 寄存器设硬件断点\n> 3. 运行程序, 触发断点\n> 4. 删除硬件断点开始分析\n\n在x64dbg中，F9两次后来到这个压栈的操作处。接着单步运行一次，看到ESP的值为红色，代表其值被修改了，我们右键选择“在内存窗口中转到”，然后在栈中打下硬件断点。\n\n![image-20250506133643545](/pictures/BaseCTF2024/image-20250506133643545.png)\n\n![image-20250506134057787](/pictures/BaseCTF2024/image-20250506134057787.png)\n\n![image-20250506134312068](/pictures/BaseCTF2024/image-20250506134312068.png)\n\n之后F9，触发断点后单步运行几下就找到OEP了，即程序入口点。可以看到这个地方的多次pop指令。\n\n根据wp中的提示，0X41CF65跳转的地方就是程序的入口点了。应该是了。\n\n![image-20250506134519180](/pictures/BaseCTF2024/image-20250506134519180.png)\n\n下面根据WP中的操作介绍一步步就可以脱出无壳的程序了，叫UPX_PRO_MAX_dump_SCY.exe。\n\n> `scylla`插件：在 x64dbg 中内置的 Scylla 插件可用于 dump 进程，**即将内存中的程序数据转储到磁盘上**，形成一个可执行文件的副本，方便后续对程序的分析和研究。\n>\n> `IAT AutoSearch`： 在分析经过加壳或加密的程序时，程序的导入表可能被破坏或隐藏，IAT AutoSearch 可以自动扫描内存或代码段，寻找可能的导入函数地址，帮助逆向工程师快速找到程序所调用的外部函数。\n\n> 程序的导入表是程序的关键数据结构，用于列出程序运行时需要从其他模块（通常是 DLL）中导入的函数和变量。以下是导入表的详细介绍：\n>\n>   * 导入表是程序的一个数据结构，它包含了一系列的引用信息，指向程序运行时需要调用的外部函数和变量所在的模块及其具体地址。\n>\n> \n>\n>   * **便于调用外部模块功能** ：程序通常不会将所有功能都自己实现，而是通过调用系统或第三方提供的 DLL 中的函数和变量来实现复杂的功能。导入表就像一个目录，告诉操作系统程序需要从哪些 DLL 中使用哪些功能。\n>   * **便于程序的动态链接** ：它支持程序的动态链接机制。程序在编译时不会直接将 DLL 中的函数和变量代码包含进来，而是在运行时装载所需的 DLL，并通过导入表找到具体的函数和变量地址，这样可以减少程序自身的体积，同时方便对 DLL 进行更新和共享。\n>\n> \n>\n>   * **导入模块名表** ：存放了程序需要导入的各个模块的名字，比如 “kernel32.dll”“user32.dll” 等。\n>   * **导入函数名表** ：对于每个导入模块，都有一个对应的导入函数名表，列出了从该模块中导入的具体函数名称，如 “MessageBoxA”“CreateFileA” 等。\n>   * **导入函数地址表（IAT）** ：在程序运行时，操作系统会将每个导入函数的实际内存地址填入这个表中，程序通过这个表中的地址来调用相应的函数。\n\n脱壳后的程序导入IDA中，很清晰的加密逻辑。直接逆向写脚本就行。\n\n![image-20250506141212651](/pictures/BaseCTF2024/image-20250506141212651.png)\n\n但是这里出现了一个坑：`sub_401550`函数其实就是一些加密字符串移动操作，分成几部分存储在几个变量中。但是在验证函数中，全程只用到了a1和a2部分，也就是sub_401550中的a2和a3，不是完整的密文，我觉得这里是中间出了问题，而且这个提取出来的exe程序无法正常运行，IDA中也调试不行，只能静态分析。所以还是有点不靠谱的东西存在。\n\n![image-20250506142108769](/pictures/BaseCTF2024/image-20250506142108769.png)\n\n![image-20250506141429954](/pictures/BaseCTF2024/image-20250506141429954.png)\n\n------\n\n# EZ_VM\n\n​\t基本信息：`pyinstaller`打包的`ELF64`位程序，使用`pydumpck`解包得到`py`文件。\n\n​\t加密逻辑在`what.py`文件，打开，里面函数名称和变量名都是用数字代替的，还有一些小错误，比如本来的“while”语句变成“if”，需要改过来。\n\n​\t代码的逻辑就是：分别使用一个数组变量和一个字典来模拟一个栈和内存，使用变量模拟寄存器，通过数组的`pop`和`push`模拟栈的操作，使用函数定义各种汇编指令，如push、pop、add、sub等等，都是统一操作数长度。就这样定义了一个能够通过汇编指令进行运行的“虚拟机”，里面存在出题人预先写好的一段静态汇编代码，作为加密函数。\n\n> 1. 我们首要任务就是给源python代码进行重命名和明显的错误纠正。（需要足够熟悉汇编指令，起码的要知道。转移指令还没那么重要，因为我们不关心程序的执行流程，我们只需要注意密文的来处即可。）\n> 2. 然后在其中插入print调试语句输出操作指令、栈和内存的值，锁定密文的存储地方，观察加密方法。\n> 3. 根据加密方法写逆向脚本。\n\n​\t\n\n```python\nenc_flag = [\n    35,\n    18,\n    22,\n    38,\n    23,\n    18,\n    61,\n    25,\n    83,\n    4,\n    0,\n    5,\n    5,\n    83,\n    95,\n    20,\n    29,\n    83,\n    82,\n    1,\n    29,\n    25,\n    0,\n    0,\n    81,\n    72,\n    76,\n    85,\n    3,\n    85,\n    79,\n    73,\n    83,\n    0,\n    15,\n    9,\n    85,\n    7,\n    80,\n    82,\n    0,\n    5,\n    84,\n    77,\n    130]\n\n\nclass Opcode:\n    vm_push = 240\n    vm_pop = 241\n    vm_and = 242\n    vm_or = 243\n    vm_not = 244\n    vm_xor = 245\n    vm_jmp = 246\n    vm_jz = 247\n    vm_label = 248\n    vm_strlen = 249\n    vm_loadchar = 250\n    vm_store = 251\n    vm_load = 252\n    vm_add = 253\n    vm_sub = 254\n\n\nclass VM:\n\n    def __init__(self):\n        self.stack = []\n        self.bytecode = []\n        self.pc = 0\n        self.labels = {}\n        self.memory = {}\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if not self.stack:\n            raise IndexError('something wrong..')\n        return self.stack.pop()\n\n    def _scan_labels(self):\n        labels = {}\n        pc = 0\n        while pc < len(self.bytecode):\n            if self.bytecode[pc] == Opcode.vm_label:\n                label_name = self.bytecode[pc + 1]\n                labels[label_name] = pc\n                pc += 2\n            else:\n                pc += 1\n\n        return labels\n\n    def vm_and(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b & a)\n\n    def vm_or(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b | a)\n\n    def vm_not(self):\n        b = self.pop()\n        self.push(~b)\n\n    def vm_xor(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b ^ a)\n\n    def vm_jmp(self):\n        label_name = self.bytecode[self.pc]\n        self.pc = self.labels[label_name]\n\n    def vm_jz(self):\n        label_name = self.bytecode[self.pc]\n        self.pc += 1\n        a = self.pop()\n        b = self.pop()\n        if a == b:\n            self.pc = self.labels[label_name]\n\n    def vm_strlen(self):\n        string = self.pop()\n        self.push(len(string))\n\n    def vm_loadchar(self):\n        string = self.pop()\n        index = self.pop()\n        self.push(ord(string[index]))\n\n    def vm_store(self):\n        value = self.pop()\n        key = self.bytecode[self.pc]\n        if key == 'r':\n            if key not in self.memory:\n                self.memory[key] = []\n            self.memory[key].append(value)\n        else:\n            self.memory[key] = value\n        self.pc += 1\n\n    def vm_load(self):\n        key = self.bytecode[self.pc]\n        self.push(self.memory[key])\n        self.pc += 1\n\n    def vm_add(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b + a)\n\n    def vm_sub(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b - a)\n\n    def run(self, bytecode):\n        self.bytecode = bytecode\n        self.pc = 0\n        self.labels = self._scan_labels()\n        while self.pc < len(self.bytecode):\n            opcode = self.bytecode[self.pc]\n            self.pc += 1\n            if opcode == Opcode.vm_push:\n                value = self.bytecode[self.pc]\n                self.pc += 1\n                self.push(value)\n            elif opcode == Opcode.vm_pop:\n                self.pop()\n            elif opcode == Opcode.vm_and:\n                self.vm_and()\n            elif opcode == Opcode.vm_or:\n                self.vm_or()\n            elif opcode == Opcode.vm_not:\n                self.vm_not()\n            elif opcode == Opcode.vm_xor:\n                self.vm_xor()\n            elif opcode == Opcode.vm_jmp:\n                self.vm_jmp()\n            elif opcode == Opcode.vm_jz:\n                self.vm_jz()\n            elif opcode == Opcode.vm_label:\n                self.pc += 1\n            elif opcode == Opcode.vm_strlen:\n                self.vm_strlen()\n            elif opcode == Opcode.vm_loadchar:\n                self.vm_loadchar()\n            elif opcode == Opcode.vm_store:\n                self.vm_store()\n            elif opcode == Opcode.vm_load:\n                self.vm_load()\n            elif opcode == Opcode.vm_add:\n                self.vm_add()\n            elif opcode == Opcode.vm_sub:\n                self.vm_sub()\n            else:\n                raise ValueError('something wrong')\n            print(f\"pc: {self.pc}| opcode: {get_opcode_name(opcode)}, stack: {self.stack}, memory: {self.memory}\")\n\n    def encrypt(self, serial):\n        bytecode = [\n            Opcode.vm_push, serial,\n            Opcode.vm_strlen,\n            Opcode.vm_store, 'l1',\n            Opcode.vm_push, 0,\n            Opcode.vm_store, 'i',\n            Opcode.vm_label, 's',\n            Opcode.vm_load, 'l1',\n            Opcode.vm_push, 1,\n            Opcode.vm_sub,\n            Opcode.vm_load, 'i',\n            Opcode.vm_jz, 'e',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, 1,\n            Opcode.vm_add,\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_xor,\n            Opcode.vm_store, 'r',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, 1,\n            Opcode.vm_add,\n            Opcode.vm_store, 'i',\n            Opcode.vm_jmp, 's',\n            Opcode.vm_label, 'e',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_push, 255,\n            Opcode.vm_xor,\n            Opcode.vm_store, 'r'\n        ]\n        self.run(bytecode)\n        enc = self.memory['r']\n        return enc\n\ndef get_opcode_name(opcode):\n    for name, value in Opcode.__dict__.items():\n        if value == opcode:\n            return name\n    return None\n\nvm = VM()\ntest_flag = \"BaseCTF{VM_is_awesome}\"\nenc = vm.encrypt(test_flag)\nprint(f\"encrypted test_flag: {enc}\")\nprint(f\"original flag: {enc_flag}\")\n```\n\n根据WP提示重命名后，观察传输的调试信息。看一下开头和结尾就行。\n\n![image-20250509160138052](/pictures/BaseCTF2024/image-20250509160138052.png)\n\n![image-20250509160305470](/pictures/BaseCTF2024/image-20250509160305470.png)\n\n​\t所以猜到加密逻辑是：从前往后，相邻两位异或，尾部和255异或。\n\n这里给出我的解密脚本。\n\n```python\nenc_flag = [35, 18, 22, 38, 23,  18,61, 25,  83,4,0, 5, 5,83,95,  20,  29, 83,82,  1, 29, 25, 0,0,81,72,76,85,3,85,79,73,83,0,15,9,85,7,80,82,0,5,84,77,130,255]\n\nflag = \"\"\nfor i in range(len(enc_flag)):\n    char = enc_flag[i]\n    for j in range(i+1, len(enc_flag)):\n        char = char ^ enc_flag[j]\n\n    flag += chr(char)\n\nprint(flag)\n```\n\n------\n\n# Microgame\n\n​\t不理解，不会游戏逆向，后面得学啊。专门做了一个CE的学习。\n\n​\t学习完CE，专门出个WP来做。\n\n------\n\n# neuro爱数学\n\n​\t直接打开IDA看看`main`函数，程序无壳，就是考察数学问题。\n\n![image-20250512120720066](/pictures/BaseCTF2024/image-20250512120720066.png)\n\n![image-20250512130852846](/pictures/BaseCTF2024/image-20250512130852846.png)\n\n![image-20250512130953971](/pictures/BaseCTF2024/image-20250512130953971.png)\n\n```c\n#include<stdio.h>\n#include<stdint.h>\n#include<intrin.h>\n\nint main(){\t\t\t\t\t\t\t\t//注意：各个变量和函数的类型是关键，不能搞错，需要对照IDA伪代码\n    int64_t v5=0x400C0210000001;\t\t\t//这个值是固定的，但是需要动调程序得到这个值。\n\n    for(int i=-60; i<=59; i++){\n        if(i == 44 || i == 58){\n            printf(\"符合条件的i值位：%d/n\", i);\n            continue;\n        }\n\n        unsigned int v12 = (unsigned int)(i + 37);\n        if(v12 <= 54 && _bittest64((int64_t*)&v5,(unsigned int)v12) != 0){\n            printf(\"符合条件的i值为：%d/n\", i);\n        }\n\n    }\n\n    return 0;\n}\n\n```\n\n![image-20250512131328904](/pictures/BaseCTF2024/image-20250512131328904.png)\n\n然后使用python脚本展开多项式得到系数。\n\n````python\nfrom sympy import symbols, expand\n\n# 定义符号变量\nx = symbols('x')\n\n# 构造多项式\npolynomial = (x - 44) * (x - 58) * (x - 5) * (x + 37) * (x - 17) * (x + 9) * (x - 6) * (x + 4)\n\n# 展开多项式\nexpanded_polynomial = expand(polynomial)\n\n# 提取并打印系数\nstandard_form = expanded_polynomial.as_poly()  # 获取标准形式的多项式\ncoefficients = standard_form.all_coeffs()    # 获取所有系数\n\n# 打印系数逆序（从常数项到最高次项）。因为正常是从高次项到低次项。\nprint(coefficients[::-1])\n#[-1733624640, 134045088, 122783468, -12168520, -1364231, 121272, -358, -80, 1]\n````\n\n![测试图片](/pictures/BaseCTF2024/image-20250512131708984.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["复现WP"],"categories":["CTF"]},{"title":"音乐馆","url":"/music/index.html"},{"url":"/json/music.json","content":"[\n  {\n    \"name\": \"青花瓷\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"\n  },\n  {\n    \"name\": \"稻香\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"\n  },\n  {\n    \"name\": \"晴天\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"\n  },\n  {\n    \"name\": \"七里香\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"\n  },\n  {\n    \"name\": \"花海\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"\n  },\n  {\n    \"name\": \"反方向的钟\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"\n  },\n  {\n    \"name\": \"兰亭序\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"\n  },\n  {\n    \"name\": \"说好的辛福呢\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"\n  },\n  {\n    \"name\": \"等你下课 (with 杨瑞代)\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"\n  },\n  {\n    \"name\": \"我落泪情绪零碎\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"\n  },\n  {\n    \"name\": \"听妈妈的话\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"\n  },\n  {\n    \"name\": \"明明就\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"\n  },\n  {\n    \"name\": \"我是如此相信\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"\n  },\n  {\n    \"name\": \"发如雪\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"\n  },\n  {\n    \"name\": \"以父之名\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"\n  },\n  {\n    \"name\": \"园游会\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"\n  },\n  {\n    \"name\": \"本草纲目\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"\n  },\n  {\n    \"name\": \"龙卷风\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"\n  }\n]"},{"title":"关于","url":"/about/index.html","content":"\n\n\n"},{"url":"/static/css/index_media.css","content":"/* index ，主页面动画*/\n\n  #home-media-container {\n    position: fixed; /* 改为固定定位 */\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    z-index: 0;\n    \n    /* 添加底部向上渐变遮罩 */\n    -webkit-mask-image: linear-gradient(to top, transparent 0%, black 0%);\n    mask-image: linear-gradient(to top, transparent 0%, black 0%);\n  }\n  \n  .home-media {\n    position: fixed; /* 同步改为固定定位 */\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n    \n    /* 添加透明度过渡 */\n    transition: opacity 0.5s ease;\n    opacity: 1;\n  }\n  \n    /* 自定义加载动画容器 */\n  .custom-loader {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    z-index: 10; /* 确保在视频上方 */\n    pointer-events: none; /* 防止阻挡视频交互 */\n    transition: opacity 0.5s ease; /* 淡出动画 */\n  }\n\n  /* 加载动画元素 */\n  .loader-animation {\n    width: 18%;\n    height: 18%;\n    min-width: 128px;\n    min-height: 128px;\n    background-size: contain; /* 保持比例 */\n    background-position: center;\n    background-repeat: no-repeat;\n    animation: pulse 1.5s infinite ease-in-out;\n  }\n\n  /* 呼吸动画效果 */\n  @keyframes pulse {\n    0% { transform: scale(1); opacity: 0.8; }\n    50% { transform: scale(1.1); opacity: 1; }\n    100% { transform: scale(1); opacity: 0.8; }\n  }\n"},{"title":"标签","url":"/tags/index.html"},{"title":"分类","url":"/categories/index.html"},{"url":"/static/js/index_media.js","content":"// ======================= 横竖屏自适应背景媒体加载器 =======================\nlet lastOrientation = null; // 记录上一次的方向状态\n\n// ================= 新增滚动渐变效果函数 =================\nfunction initScrollFadeEffect() {\n  const mediaContainer = document.getElementById('home-media-container');\n  if (!mediaContainer) return;\n  \n  const mediaElement = mediaContainer.querySelector('.home-media');\n  if (!mediaElement) return;\n  \n  // 节流函数优化性能\n  function throttle(func, limit) {\n    let lastFunc, lastRan;\n    return function() {\n      const context = this;\n      const args = arguments;\n      if (!lastRan) {\n        func.apply(context, args);\n        lastRan = Date.now();\n      } else {\n        clearTimeout(lastFunc);\n        lastFunc = setTimeout(function() {\n          if ((Date.now() - lastRan) >= limit) {\n            func.apply(context, args);\n            lastRan = Date.now();\n          }\n        }, limit - (Date.now() - lastRan));\n      }\n    }\n  }\n\n  // 处理滚动时的透明度变化\n  function handleScrollFade() {\n    const scrollY = window.scrollY;\n    const windowHeight = window.innerHeight;\n    \n    // 计算透明度：从1（完全不透明）到0（完全透明）\n    // 当滚动到一屏高度时，透明度变为0\n    let opacity = 1 - (scrollY / windowHeight);\n    opacity = Math.max(0, Math.min(1, opacity)); // 限制在0-1范围\n    \n    mediaElement.style.opacity = opacity;\n  }\n\n  // 节流处理滚动事件（每50ms检查一次）\n  const throttledScrollHandler = throttle(handleScrollFade, 50);\n  \n  // 添加滚动监听\n  window.addEventListener('scroll', throttledScrollHandler);\n  \n  // 初始化时执行一次\n  handleScrollFade();\n  \n  // 存储当前滚动处理器以便后续移除\n  return throttledScrollHandler;\n}\n\n\n// ================= 滚动渐变效果函数结束 =================\n\n// ================= 新增底部遮罩层控制函数 =================\nfunction initScrollMaskEffect() {\n  const mediaContainer = document.getElementById('home-media-container');\n  if (!mediaContainer) return;\n  \n  // 节流函数优化性能\n  function throttle(func, limit) {\n    let lastFunc, lastRan;\n    return function() {\n      const context = this;\n      const args = arguments;\n      if (!lastRan) {\n        func.apply(context, args);\n        lastRan = Date.now();\n      } else {\n        clearTimeout(lastFunc);\n        lastFunc = setTimeout(function() {\n          if ((Date.now() - lastRan) >= limit) {\n            func.apply(context, args);\n            lastRan = Date.now();\n          }\n        }, limit - (Date.now() - lastRan));\n      }\n    }\n  }\n\n  // 处理滚动时的遮罩变化\n  function handleScrollMask() {\n    const scrollY = window.scrollY;\n    const windowHeight = window.innerHeight;\n    \n    // 计算遮罩高度（0-100%）\n    let maskHeight = (scrollY / windowHeight) * 100;\n    maskHeight = Math.min(100, Math.max(0, maskHeight));\n    \n    // 动态设置遮罩层高度\n    mediaContainer.style.setProperty('--mask-height', `${maskHeight}%`);\n  }\n\n  // 节流处理滚动事件（每50ms检查一次）\n  const throttledScrollHandler = throttle(handleScrollMask, 50);\n  \n  // 添加滚动监听\n  window.addEventListener('scroll', throttledScrollHandler);\n  \n  // 初始化时执行一次\n  handleScrollMask();\n  \n  // 返回处理器以便后续移除\n  return throttledScrollHandler;\n}\n\n\nfunction initResponsiveBackground() {\n  const mediaContainer = document.getElementById('home-media-container');\n  if (!mediaContainer) {\n    console.error('[背景加载器] 未找到媒体容器元素');\n    return;\n  }\n\n  // 检测当前屏幕方向\n  const currentIsPortrait = window.innerHeight > window.innerWidth;\n  const currentOrientation = currentIsPortrait ? 'portrait' : 'landscape';\n  \n  // 如果方向未改变，则直接返回\n  if (lastOrientation === currentOrientation) {\n    console.log('[背景加载器] 方向未改变，无需重新加载');\n    return;\n  }\n  \n  // 更新方向记录\n  lastOrientation = currentOrientation;\n  console.log(`[背景加载器] 方向变化: ${currentOrientation}`);\n\n  // 清除现有媒体元素和加载动画\n  const existingMedia = mediaContainer.querySelector('.home-media');\n  const existingLoader = mediaContainer.querySelector('.custom-loader');\n  if (existingMedia) existingMedia.remove();\n  if (existingLoader) existingLoader.remove();\n\n  // 根据方向选择资源\n  let mediaSrc, posterSrc, mediaType;\n  if (currentIsPortrait) {\n    mediaSrc = mediaContainer.dataset.portraitVideo || mediaContainer.dataset.portraitImg;\n    posterSrc = mediaContainer.dataset.portraitPoster;\n    mediaType = mediaContainer.dataset.portraitVideo ? 'video' : 'img';\n  } else {\n    mediaSrc = mediaContainer.dataset.landscapeVideo || mediaContainer.dataset.landscapeImg;\n    posterSrc = mediaContainer.dataset.landscapePoster;\n    mediaType = mediaContainer.dataset.landscapeVideo ? 'video' : 'img';\n  }\n\n  if (!mediaSrc) {\n    console.error('[背景加载器] 未找到有效媒体资源');\n    return;\n  }\n\n  console.log(`[背景加载器] 使用资源: ${mediaSrc} (类型: ${mediaType})`);\n\n  // 创建媒体元素\n  const mediaElement = document.createElement(mediaType);\n  mediaElement.className = 'home-media';\n  mediaElement.style.cssText = 'width:100%;height:100%;object-fit:cover';\n  \n  // ================= 设置初始透明度 =================\n  mediaElement.style.opacity = '1';\n  mediaElement.style.transition = 'opacity 0.5s ease';\n  // ================================================\n  \n  // 在媒体容器添加媒体元素后调用效果函数\n  mediaContainer.appendChild(mediaElement);\n  addMediaEffects(mediaElement, mediaType); // 添加新功能\n   \n  console.log('[背景加载器] 媒体元素已创建');\n   \n  // 创建自定义加载动画容器\n  const loaderContainer = document.createElement('div');\n  loaderContainer.className = 'custom-loader';\n  mediaContainer.prepend(loaderContainer);\n  \n  // 创建加载动画元素\n  const loaderElement = document.createElement('div');\n  loaderElement.className = 'loader-animation';\n  \n  // 设置加载动画样式（使用GIF）\n  loaderElement.style.backgroundImage = `url(${posterSrc})`;\n  loaderContainer.appendChild(loaderElement);\n  \n  // 视频特殊处理\n  if (mediaType === 'video') {\n    mediaElement.autoplay = true;\n    mediaElement.muted = true;\n    mediaElement.loop = true;\n    mediaElement.playsInline = true;\n    mediaElement.setAttribute('playsinline', '');\n    mediaElement.setAttribute('webkit-playsinline', '');\n    \n    // 多源支持\n    const source = document.createElement('source');\n    source.src = mediaSrc;\n    source.type = 'video/mp4';\n    mediaElement.appendChild(source);\n    \n    // 处理自动播放限制\n    const playPromise = mediaElement.play();\n    if (playPromise !== undefined) {\n      playPromise.catch(error => {\n        console.warn('[背景加载器] 自动播放被阻止:', error);\n        mediaElement.muted = true;\n        mediaElement.play();\n      });\n    }\n    \n    // 视频加载完成后移除加载动画\n    mediaElement.addEventListener('loadeddata', () => {\n      loaderContainer.style.opacity = '0';\n      setTimeout(() => {\n        if (loaderContainer.parentNode) {\n          loaderContainer.parentNode.removeChild(loaderContainer);\n        }\n      }, 500); // 淡出动画持续时间\n    });\n  } else {\n    mediaElement.src = mediaSrc;\n    mediaElement.loading = 'eager';\n    \n    // 图片加载完成后移除加载动画\n    mediaElement.addEventListener('load', () => {\n      loaderContainer.style.opacity = '0';\n      setTimeout(() => {\n        if (loaderContainer.parentNode) {\n          loaderContainer.parentNode.removeChild(loaderContainer);\n        }\n      }, 500);\n    });\n  }\n\n  // 错误处理\n  mediaElement.onerror = function() {\n    console.error(`[背景加载器] 资源加载失败: ${mediaSrc}`);\n    this.style.display = 'none';\n    \n    // 尝试回退到备用类型\n    console.warn('[背景加载器] 尝试回退到备用媒体');\n    const fallbackType = mediaType === 'video' ? 'img' : 'video';\n    const fallbackSrc = currentIsPortrait ? \n      (mediaContainer.dataset.portraitImg || mediaContainer.dataset.portraitVideo) :\n      (mediaContainer.dataset.landscapeImg || mediaContainer.dataset.landscapeVideo);\n    \n    if (fallbackSrc && fallbackSrc !== mediaSrc) {\n      console.log(`[背景加载器] 使用备用资源: ${fallbackSrc}`);\n      mediaElement.src = fallbackSrc;\n      mediaElement.style.display = 'block';\n    }\n  };\n\n  mediaContainer.appendChild(mediaElement);\n  console.log('[背景加载器] 媒体元素已创建');\n  \n  // ================= 初始化滚动渐变效果 =================\n  initScrollFadeEffect();\n}\n\nfunction addMediaEffects(mediaElement, mediaType) {\n  if (mediaType === 'video') {\n    // 获取当前方向\n    const currentIsPortrait = window.innerHeight > window.innerWidth;\n\n    // 竖屏模式下固定放大105%\n    const baseScale = currentIsPortrait ? 1.05 : 1.2;\n    mediaElement.style.transform = `scale(${baseScale})`;\n    \n    // 检测是否为iOS设备\n    function isIOS() {\n      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n    }\n\n    // 如果是iOS设备，直接禁用所有视差效果\n    if (isIOS()) {\n      console.log('[视差效果] 在iOS设备上，禁用所有视差效果');\n      return; // 直接返回，不初始化任何视差效果\n    }\n    // 1. 添加缩放动画效果\n    mediaElement.style.transform = 'scale(1.2)'; // 初始放大110%\n    mediaElement.style.transition = 'transform 0.5s ease-out';\n    \n    // 在视频加载完成后触发缩放动画\n    mediaElement.addEventListener('loadeddata', () => {\n      // 竖屏模式保持105%缩放，不需要动画\n      if (currentIsPortrait) {\n        mediaElement.style.transform = 'scale(1.05)';\n      } \n      // 横屏模式执行缩放动画到正常大小\n      else {\n        setTimeout(() => {\n          mediaElement.style.transform = 'scale(1)';\n        }, 100);\n      }\n    });\n    \n    // 2. 添加视差效果（鼠标/陀螺仪）\n    const mediaContainer = document.getElementById('page-header');\n    mediaContainer.style.overflow = 'hidden';\n    mediaElement.style.transformOrigin = 'center center';\n    \n    // 视差效果参数\n    const parallaxIntensity = 0.05;\n    const scaleIntensity = 0.05;\n    let isGyroActive = false;\n    \n    // ================= 新增陀螺仪支持 =================\n    // 检测陀螺仪支持\n    function initGyroParallax() {\n      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {\n        // iOS 13+ 需要权限\n        DeviceOrientationEvent.requestPermission()\n          .then(permissionState => {\n            if (permissionState === 'granted') {\n              setupGyroListeners();\n              isGyroActive = true;\n            }\n          })\n          .catch(console.error);\n      } else if ('DeviceOrientationEvent' in window) {\n        // Android和其他支持设备\n        setupGyroListeners();\n        isGyroActive = true;\n      }\n      \n      return isGyroActive;\n    }\n    \n    // 设置陀螺仪监听\n    function setupGyroListeners() {\n      window.addEventListener('deviceorientation', handleOrientation);\n    }\n    \n    // 处理陀螺仪数据\n    function handleOrientation(event) {\n      // 竖屏模式使用105%基础缩放\n      const baseScaleValue = currentIsPortrait ? 1.05 : 1;\n      if (!isGyroActive) return;\n      \n      // 获取陀螺仪数据（beta: 前后倾斜, gamma: 左右倾斜）\n      const beta = event.beta || 0;  // 前后倾斜（-180到180）\n      const gamma = event.gamma || 0; // 左右倾斜（-90到90）\n      \n      // 将角度转换为百分比偏移（归一化处理）\n      const moveX = (gamma / 90) * parallaxIntensity * 100; // -100% 到 100%\n      const moveY = (beta / 180) * parallaxIntensity * 100; \n      \n      // 应用视差效果\n      mediaElement.style.transform = `\n        translate(${moveX}%, ${moveY}%)\n        scale(${baseScaleValue + scaleIntensity})\n      `;\n    }\n    \n    // ================= 鼠标视差效果 =================\n    function initMouseParallax() {\n      mediaContainer.addEventListener('mousemove', (e) => {\n        const rect = mediaContainer.getBoundingClientRect();\n        const x = (e.clientX - rect.left) / rect.width;\n        const y = (e.clientY - rect.top) / rect.height;\n        \n        const moveX = (x - 0.5) * parallaxIntensity * 100;\n        const moveY = (y - 0.5) * parallaxIntensity * 100;\n        \n        mediaElement.style.transform = `\n          translate(${moveX}%, ${moveY}%)\n          scale(${1 + scaleIntensity})\n        `;\n      });\n      \n      mediaContainer.addEventListener('mouseleave', () => {\n        mediaElement.style.transform = 'scale(1)';\n      });\n    }\n    \n    // ================= 根据设备类型初始化 =================\n    // 检测移动设备\n    const isMobile = /Mobi|Android/i.test(navigator.userAgent);\n    \n    if (isMobile) {\n      // 移动设备优先使用陀螺仪\n      if (!initGyroParallax()) {\n        // 不支持陀螺仪则回退到触摸事件\n        initTouchParallax();\n      }\n    } else {\n      // PC设备使用鼠标事件\n      initMouseParallax();\n    }\n    \n    // ================= 触摸事件回退方案 =================\n    function initTouchParallax() {\n      mediaContainer.addEventListener('touchmove', (e) => {\n        e.preventDefault();\n        const touch = e.touches[0];\n        const rect = mediaContainer.getBoundingClientRect();\n        const x = (touch.clientX - rect.left) / rect.width;\n        const y = (touch.clientY - rect.top) / rect.height;\n        \n        const moveX = (x - 0.5) * parallaxIntensity * 50; // 移动强度减半\n        const moveY = (y - 0.5) * parallaxIntensity * 50;\n        \n        mediaElement.style.transform = `\n          translate(${moveX}%, ${moveY}%)\n          scale(${1 + scaleIntensity * 0.5}) // 缩放强度减半\n        `;\n      });\n      \n      mediaContainer.addEventListener('touchend', () => {\n        mediaElement.style.transform = 'scale(1)';\n      });\n    }\n    \n    // ================= 性能优化 =================\n    // 页面不可见时暂停陀螺仪\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden') {\n        isGyroActive = false;\n      } else if (isMobile) {\n        isGyroActive = initGyroParallax();\n      }\n    });\n  }\n}\n\n// 在initMedia函数中调用新功能\nfunction initMedia() {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', function() {\n      initResponsiveBackground();\n      initScrollFadeEffect(); // 添加调用\n    });\n  } else {\n    initResponsiveBackground();\n    initScrollFadeEffect(); // 添加调用\n  }\n}\n\n\n// ======================= 执行入口 =======================\ninitMedia();\n\n// 防抖处理窗口变化\nlet resizeTimer;\nwindow.addEventListener('resize', () => {\n  clearTimeout(resizeTimer);\n  resizeTimer = setTimeout(() => {\n    // 计算当前方向状态\n    const currentIsPortrait = window.innerHeight > window.innerWidth;\n    const currentOrientation = currentIsPortrait ? 'portrait' : 'landscape';\n    \n    // 只有方向实际改变时才执行重载\n    if (lastOrientation !== currentOrientation) {\n      console.log('[背景加载器] 窗口大小变化，重新加载媒体');\n      initResponsiveBackground();\n    } else {\n      console.log('[背景加载器] 窗口大小变化但方向未改变');\n      // ================= 方向未变时重置透明度 =================\n      initScrollFadeEffect();\n    }\n  }, 500);\n});\n\n// 页面可见性变化处理\ndocument.addEventListener('visibilitychange', () => {\n  if (document.visibilityState === 'visible') {\n    const video = document.querySelector('#home-media-container video');\n    if (video && video.paused) {\n      console.log('[背景加载器] 页面恢复可见，重新播放视频');\n      video.play().catch(e => console.warn('视频恢复播放失败:', e));\n    }\n    // ================= 页面恢复可见时重置透明度 =================\n    initScrollFadeEffect();\n  }\n});\n\n// ========== 新增修复代码（直接加在现有代码后面） ========== //\n\n// 1. 缓存恢复检测（核心修复）\nwindow.addEventListener('pageshow', event => {\n  if (event.persisted && location.pathname === '/') {\n    console.log('[修复] 检测到缓存恢复主页，强制重置');\n    lastOrientation = null;\n    initResponsiveBackground();\n    // ================= 缓存恢复时重置透明度 =================\n    setTimeout(initScrollFadeEffect, 300);\n  }\n});\n\n// 2. 路由变化监听（SPA兼容）\nwindow.addEventListener('popstate', () => {\n  if (location.pathname === '/') {\n    console.log('[修复] 检测到返回主页');\n    setTimeout(() => {\n      // 检查媒体元素是否存在\n      const container = document.getElementById('home-media-container');\n      if (!container?.querySelector('.home-media')) {\n        lastOrientation = null;\n        initResponsiveBackground();\n      }\n      // ================= 返回主页时重置透明度 =================\n      initScrollFadeEffect();\n    }, 300); // 延迟确保DOM更新\n  }\n});\n\n// 3. 媒体状态自检（兜底方案）\nfunction checkMediaStatus() {\n  if (location.pathname !== '/') return;\n  \n  const container = document.getElementById('home-media-container');\n  if (!container) return;\n  \n  const hasMedia = container.querySelector('.home-media');\n  if (!hasMedia) {\n    console.log('[修复] 自检发现媒体丢失');\n    lastOrientation = null;\n    initResponsiveBackground();\n  }\n  // ================= 媒体自检时重置透明度 =================\n  initScrollFadeEffect();\n}\n\n// 每0.5秒检查一次（轻量级检测）\nsetInterval(checkMediaStatus, 500);\n\n// 4. 增强错误处理（在initResponsiveBackground函数内修改）\n// 在mediaElement.onerror函数内添加：\nsetTimeout(() => {\n  if (!mediaElement.parentNode) {\n    console.warn('[修复] 尝试完全重建');\n    lastOrientation = null;\n    initResponsiveBackground();\n    // ================= 错误重建时重置透明度 =================\n    setTimeout(initScrollFadeEffect, 500);\n  }\n}, 1000);\n\n\n"}]