[{"title":"ISCTF2024","url":"/2025/06/05/ISCTF2024/RE/","content":"\n# Ezre\n\n> ​\t一个简单的维吉尼亚加密，看了半天没看出来，在强行写解密算法后，才突然发现。\n\n------\n\n\n\n# 《回忆安魂曲》三——mainn.exe\n\n\n\n> ​\t迷宫类题目，无壳64位。槽点就是将移动键换成了“love”四个字符，然后迷宫对应的字符串在结尾多给了几个，起到迷惑性效果，差点让我搞不清行列数，还有行坐标从0开始，列坐标从0开始，起始点坐标（1，1）。开始直接把我绕晕。\n>\n> ​\t确定迷宫后，又复习了DFS算法。收获不少。\n\n```python\nmaze_str = \"\"\"###############################P#...............#...#.......#.#####.###.#####.#.###.#####.#.....#...#.#.....#...#.#...#.#####.#.###.#.#######.#.#.###.#C..#.#.#...#.#...#...#.#.#...#.#.#.#.#.###.#.#.#.###.#.#.#.#.#.#.#.#...#...#.#.......#.#.#.###.#.###.#####.#########.###.#...#...#.....#.#.......#...#.#.#####.#####.#.#.#####.###.#...#...#...#...#...#...#.#...#.###.#.###.#.#######.#.#.#.#.#...#.#.#...#.#...#...#...#.#.###.#.#.#####.#.#.#.#######.###.#...#.....#...#.#.#...#.....#.#########.#####.#.###.#.###.#.#.....#.#...#...#...#...#.#.#.#.#.#.#.###.#.#####.###.#.#.#...#.#...#.#...#...#...#...#.#.###.###.#.#####.#.###.###.#.#...#.#.#.......#.#...#.#...#.#####.#.#######.#.#####.#.###.#...#.#.......#.#...#...#.#..E#.#.#.#.#######.###.#.#####.#.#.#...#.............#.....#.#.#.###############.#######.#.#.#.........#...#...#.....#...#.#.#######.#.#.#####.#.#######.#.......#...#.......#.........\"\"\"\n\nfor i in range(30):\n    for j in range(30):\n        print(maze_str[i*30+j], end=' ')\n    print()\n\n\nmaze = []\nfor i in range(30):\n    maze_row = []\n    for j in range(30):\n        maze_row.append(maze_str[i*30+j])\n    maze.append(maze_row)\n\nstart = (1,1)\n\ndef dfs(maze, x, y,path):\n    if maze[x][y] == 'E':\n        return True\n    if x < 0 or x >= len(maze) or y < 0 or y >= len(maze[0]) or maze[x][y] == '#' or maze[x][y] == 'C':\n        return False\n\n    maze[x][y] = '#'\n\n    directions = [(-1,0), (0,-1), (1,0), (0,1)]\n    directions_str = ['l', 'v', 'o', 'e']\n    for i in range(4):\n        dx = directions[i][0]\n        dy = directions[i][1]\n        path.append(directions_str[i])\n        if dfs(maze, x+dx, y+dy,path):\n            return True\n        path.pop()\n\n    maze[x][y] = '.'\n    return False\n\ndef find_path():\n    path = []\n    if dfs(maze, start[0], start[1], path):\n        return path\n    else:\n        return \"No path found\"\n\nans = find_path()\nans = ''.join(ans)\nprint(ans)\n```\n\n------\n\n\n\n# **找啊找**——zhao.exe\n\n> ​\t直接拖入IDA发现只有很少几个函数，于是去查壳发现UPX壳，然后直接-d脱壳失败，拖入HxD发现标志位被改成APK了，改回来就成功脱壳了。\n>\n> ​\t再拖入IDA中就正常了，逻辑很简单，查看加密逻辑，先大小写字母替换，再异或一下。静态分析时直接去数据节查看时，得到一组数据，然后写python代码，跑出来提示为错误的flag，是出题人挖的一个坑。\n>\n> ​\t反复查看加密逻辑发现没有问题，最后动态调试，在比较之前查看数据，发现程序里存储的加密数据被改了，看来是程序在运行初始化时才给出真正的加密flag。取出数据，跑解密脚本就ok了。\n>\n> ​\t还是动调发现问题。\n\n------\n\n\n\n# py不好，会被ban\n\n\n\n> ​\tpython的exe程序。先使用Pyinstxtractor解出pyc，然后直接托在线平台解出py。我开始找的平台解不出来，我还在猜是不是题目加难度了，导致文件进行了一定的修改，不能直接解出来。原来是工具不行！最后看wp才发现这个网站。\n>\n> ​\t解出py后直接反向写解密逻辑即可解密。\n\n\n\n------\n\n\n\n# 你知道.elf文件吗\n\n> ​\t跑不起来，签到题，没有技术含量，算了。\n\n\n\n------\n\n\n\n# 《回忆安魂曲》二——test11\n\n> ​\t一个ELF文件，使用IDA远程调试，收获到了IDA调试ELF程序的方法，进一步增加了动态调试的经验，认识到一种干扰编译的方法，就是在调用程序时，不直接使用call，而是将函数首地址加载进寄存器，然后使用call寄存器调用，这样IDA分析不出来，只有动调能看到其中的跳转逻辑。\n>\n> ​\t查阅知道，这是一种“控制流平坦化”的反编译技术，通过主分发器来控制程序基本块的执行流程。\n>\n> ​\t得知flag长度为36位，然后enc加密，动态调试分析加密逻辑。确定是逐字节加密，假设当前字符下标为i，字符串数组为str。有个密钥key为字符串“i_can_reverse_but_i_can_not_have_you“。\n>\n> ​\t最终得到的加密数据为：[234, 12, 26, 17, 246, 44, 29, 62, 23, 53, 49, 41, 244, 57, 57, 211, 195, 45, 0, 16, 48, 61, 204, 0, 211, 192, 75, 198, 17, 199, 41, 62, 186, 96, 144, 52]\n>\n> - str[i] = str[i] ^ (0x66 + i) ^ 0x52\n>- str[i] = str[i] + 6\n> - str[i] = str[i] ^ (key[i] + i)\n\n```python\nenc = [234, 12, 26, 17, 246, 44, 29, 62, 23, 53, 49, 41, 244, 57, 57, 211, 195, 45, 0, 16, 48, 61, 204, 0, 211, 192, 75, 198, 17, 199, 41, 62, 186, 96, 144, 52]\nkey = 'i_can_reverse_but_i_can_not_have_you'\n\nfor i in range(len(enc)):\n    enc[i] = (enc[i] ^ (ord(key[i]) + i)) & 0xff\n    enc[i] = (enc[i] - 6) & 0xff\n    enc[i] = (enc[i] ^ 0x52 ^(0x66 + i)) & 0xff\n    print(chr(enc[i]), end='')\n    #ISCTF{as_her_never_will_come_back!!}\n```\n\n------\n\n\n\n# 《回忆安魂曲》四——文件夹：初识风仙儿\n\n> ​\t解压得到一个main.py和so文件。这是一个`Cpython`逆向题，我是第一次遇见，先跟着WP学习，但是第一步通过python中的`help函数`查看模块就出问题了。为什么呢，因为几个虚拟机的python版本不对，需要3.10的，而且本机是windows系统，一直是要么导入错系统test模块，要么导入不进，唉，环境愁死人！下载python3.10还把我的ubuntu20.04给干崩了，被我直接删了。**之后再干这种活要拍快照了**！最后在ubuntu24.04中下载好了，然后就导入进去了。真的被环境折磨惨了啊。\n>\n> ​\t看了教程，都是神仙，有的直接猜出加密算法，有的一点点死看IDA中的几千行`Cython代码`，有的凭空生成了so对应的python源代码。一个都行不通，最后在网上找了个AI代码调整，把原本的几千行`Cython`给优化了，出了一个简化的C语言版，并且整理出了核心逻辑，于是我直接看核心加密逻辑，很清晰，然后写解密就出了。\n\n```python\nhack_data = [27, 16, 43, 29, 127, 46, 51, 102, 50, 1, 112, 50, 53, 101, 57, 1] \nkey = 'H1m' sbox = [1, 14, 4, 13, 10, 2, 5, 8, 7, 6, 9, 12, 15, 3, 11, 0]  \nflag_list = [0] * 16  \nfor i in range(len(sbox)):\n    tmp = hack_data[i] ^ ord(key[i % len(key)])\n    flag_list[sbox[i]] = tmp\nfor i in range(len(flag_list)):\n    print(chr(flag_list[i]), end='')\n```\n\n------\n\n\n\n# MIPS\n\n> ​\t一种新的指令集，对应的汇编语言也不一样，需要重新学习。\n\n​\t单独出一个wp来记录学习过程中得到的知识。\n\n------\n\n\n\n\n\n# 桀桀桀\n\n> ​\t`rep stosd是一条高效的字符串操作指令，适用于快速初始化或填充内存区域，edi保存填充地址，ecx保存填充次数，eax保存单次填充值。`\n>\n> ​\t这一题很有意思啊，有花指令、TLS、伪随机数和魔改tea，有很多可学的点，在做题的时候，由于对花指令的不够全面的了解，和对TLS的不全面了解，导致我一直困在对非核心部分的探索学习中，始终未能抓住主要逻辑，最后导致身心疲惫。\n>\n> ​\t于是决定参照WP和网上的资料，好好恶补一下这些方面的知识，并且记录下来。\n\n```python\nfor i in range(0x4119E2, 0x4119E7):\t\t#IDA的patch脚本，记住使用到的函数名就好。\n    idc.patch_byte(i, 0x90)\n```\n\n专门出一个WP，记录一下这些难题。\n\n------\n\n\n\n# 嘿嘿嘿\n\n​\t无壳，验证长度32位，然后进入140001850，有SMC保护技术，我们修改标志位绕过反调试，\n\n![image-20250521110206759](/pictures/ISCTF2024/image-20250521110206759.png)\n\n![image-20250521110250703](/pictures/ISCTF2024/image-20250521110250703.png)\n\n​\t这里也没有调用，我们先不用管140001A0函数，继续去main函数中看程序逻辑。看到1400017B0函数，马上就调用了解密出的函数，参数分别是字符串\"Welcome_to_ISCTF\"，还有两个空数组。\n\n![image-20250521110613803](/pictures/ISCTF2024/image-20250521110613803.png)\n\n​\t先看140001440，对字符串进行异或，存储到a2中，140003270数据可以直接看到。这里需要注意的是，在IDA中数据以小端保存，尽管字符串显示的顺序是“Welcome_to_ISCTF”，但在栈帧中保存的顺序其实是cleW......，需要每4个字节逆序，这样才是a1[i]的值。\n\n![image-20250521110827346](/pictures/ISCTF2024/image-20250521110827346.png)\n\n![image-20250521110918291](/pictures/ISCTF2024/image-20250521110918291.png)\n\n​\t接着进入1400014A0函数，a1是空数组，a2是才加密的中间密钥的指针。如果只是出flag的话，这里没有必要深入分析了，直接取最终密钥就行了。\n\n![image-20250521104520689](/pictures/ISCTF2024/image-20250521104520689.png)\n\n​\t回到主函数，1400017B0函数才是加密的地方，继续看140001630，由于是对明文进行了分块的，分成2个16字节加密的。\n\n![image-20250521113825145](/pictures/ISCTF2024/image-20250521113825145.png)\n\n​\t里面两个函数，一个加密，一个逆序复制。\n\n![image-20250521112328705](/pictures/ISCTF2024/image-20250521112328705.png)\n\n​\t加密以4字节为一个单位，将16字节分为4个元素，加密32轮，整体加密32/4=8轮。加密方式就是异或1400013F0的返回值。\n\n![image-20250521112403260](/pictures/ISCTF2024/image-20250521112403260.png)\n\n​\t\ta2确定是1。a1是那群异或得到的值。\n\n![image-20250521113204681](/pictures/ISCTF2024/image-20250521113204681.png)\n\n​\t这里有一个映射表，256字节。\n\n![image-20250521113218351](/pictures/ISCTF2024/image-20250521113218351.png)\n\n​\t映射后的值为a1.\n\n![image-20250521113233640](/pictures/ISCTF2024/image-20250521113233640.png)\n\n​\t这里其实是一种扩展的左移并记录溢出位的操作。\n\n![image-20250521113401853](/pictures/ISCTF2024/image-20250521113401853.png)\n\n再看这个函数，以4字节为整体进行逆序，因为每次加密只有16字节参与，所以只需要移动4次。\n\n![image-20250521113539461](/pictures/ISCTF2024/image-20250521113539461.png)\n\n看回主函数，通过调试确定，比对的时候密文端序不变，解密脚本中就直接使用数据。\n\n![image-20250521113646251](/pictures/ISCTF2024/image-20250521113646251.png)\n\n最后完全不看WP，自己写出来了，Exp如下。花了4个小时吧。\n\n```c\n#include <stdio.h>\n#include <stdlib.h> \n#include <stdint.h>\n\n//密钥在动调的时候取出就行了。\nuint8_t key[128] = {64, 219, 65, 24, 40, 193, 230, 145, 203, 169, 18, 125, 170, 192, 199, 159, 157, 38, 46, 6, 157, 90, 123, 166, 146, 16, 175, 171, 169, 249, 251, 160, 135, 168, 171, 240, 25, 222, 93, 91, 231, 26, 172, 17, 30, 69, 73, 82, 201, 42, 246, 134, 66, 49, 108, 95, 150, 236, 129, 102, 94, 24, 255, 27, 69, 188, 182, 179, 250, 225, 54, 233, 113, 90, 12, 164, 92, 131, 61, 232, 59, 85, 99, 174, 230, 155, 235, 1, 32, 36, 55, 178, 65, 89, 177, 99, 76, 98, 54, 100, 188, 139, 221, 165, 68, 157, 191, 115, 242, 75, 56, 38, 65, 13, 123, 99, 220, 204, 61, 124, 51, 252, 15, 10, 176, 107, 255, 109};\n\n\n//取出就行了。\nuint8_t map[256] = {214, 144, 233, 254, 204, 225, 61, 183, 22, 182, 20, 194, 40, 251, 44, 5, 43, 103, 154, 118, 42, 190, 4, 195, 170, 68, 19, 38, 73, 134, 6, 153, 156, 66, 80, 244, 145, 239, 152, 122, 51, 84, 11, 67, 237, 207, 172, 98, 228, 179, 28, 169, 201, 8, 232, 149, 128, 223, 148, 250, 117, 143, 63, 166, 71, 7, 167, 252, 243, 115, 23, 186, 131, 89, 60, 25, 230, 133, 79, 168, 104, 107, 129, 178, 113, 100, 218, 139, 248, 235, 15, 75, 112, 86, 157, 53, 30, 36, 14, 94, 99, 88, 209, 162, 37, 34, 124, 59, 1, 33, 120, 135, 212, 0, 70, 87, 159, 211, 39, 82, 76, 54, 2, 231, 160, 196, 200, 158, 234, 191, 138, 210, 64, 199, 56, 181, 163, 247, 242, 206, 249, 97, 21, 161, 224, 174, 93, 164, 155, 52, 26, 85, 173, 147, 50, 48, 245, 140, 177, 227, 29, 246, 226, 46, 130, 102, 202, 96, 192, 41, 35, 171, 13, 83, 78, 111, 213, 219, 55, 69, 222, 253, 142, 47, 3, 255, 106, 114, 109, 108, 91, 81, 141, 27, 175, 146, 187, 221, 188, 127, 17, 217, 92, 65, 31, 16, 90, 216, 10, 193, 49, 136, 165, 205, 123, 189, 45, 116, 208, 18, 184, 229, 180, 176, 137, 105, 151, 74, 12, 150, 119, 126, 101, 185, 241, 9, 197, 110, 198, 132, 24, 240, 125, 236, 58, 220, 77, 32, 121, 238, 95, 62, 215, 203, 57, 72};\n\n\nuint32_t sub_1400012F0(uint32_t a1, int16_t a2){\n    for(int16_t i=0;i<a2;i++){\n        a1 = a1 / 0x80000000 + 2 * a1;\n    }\n    return a1;\n}\n\nuint32_t sub_140001340(uint32_t a1){\n    return sub_1400012F0(a1,24) ^ sub_1400012F0(a1, 18) ^ sub_1400012F0(a1, 10) ^ sub_1400012F0(a1, 2) ^ a1;\n}\n\n//完全照抄加密时的逻辑就行，这里是求异或值的地方，我们的目标是要找出一样的异或值，所以要和加密时的逻辑一样。\nuint32_t get_xor(uint32_t seed){\n    uint32_t t = map[(uint8_t)seed] + (map[(uint8_t)(seed>>8)] << 8) + (map[(uint8_t)(seed>>16)] << 16) + (map[(uint8_t)(seed>>24)] << 24);\n    return sub_140001340(t);\n\n}\n\n\n//仿照加密过程，其实就是一个异或操作，只是这个异或的密钥经过复杂的运算得出的\nvoid  decrypt(uint32_t *enc, uint8_t *key){\n    uint32_t *k = (uint32_t*)key;\n    for(int i=31;i>=0;i--){\n        enc[i%4] ^= get_xor(k[i] ^ enc[(i+3)%4] ^ enc[(i+2)%4] ^ enc[(i+1)%4]);\n    }\n}\n\n\nint main(){\n    \n    //密文最好是调试的时候看，断点下在比较的地方。\n    uint32_t enc[] = \t\t\t\t{0xA8F44759,0xCDB824F2,0x32FB3C01,0x42BEFFE1,0x3EC30B40,0xE094AA46,0x2AEA2B,0x362C0888};\n    uint32_t enc1[8];\n    \n    \n    for(int i=0;i<8;i++){\n        int j = i % 4;\n        enc1[i] = enc[(i/4)*4 + (3-j)];\n    }\n\n    for(int i=0;i<2;i++){\n        decrypt(enc1+i*4,key);\n    }\n\n    for(int i=0;i<8;i++){\t\t\t\t\t//这里开始是反的，还搞错了。字符串的大小端总是让我摸不着头脑。\n        printf(\"%c\",enc1[i]&0xFF);\n        printf(\"%c\",enc1[i]>>8&0xFF);\n        printf(\"%c\",enc1[i]>>16&0xFF);\n        printf(\"%c\",enc1[i]>>24&0xFF);\n    }\n\n    return 0;\n}\n```\n\n------\n\n# 萝卜子的螃蟹\n\n​\t\tRUST语言程序，可以使用IDA反编译打开，难点就是反编译代码很难看，需要配合动调确定程序的运行逻辑。有点累了，改天再写。\n\n​\t动调还是经验太少了，趁此机会，好好照着WP学习一下动调的经验。下面只总结了收获的经验，完整WP都有。\n\n\n\n- #### 通过提示字符串的交叉引用找到程序的主要逻辑函数。\n\n- #### 看到如下图所示的这种乱七八糟的函数名，看到如此难以读懂的伪代码，先单步调试找到input函数。并且，根据input函数中的参数值，找到存储输入flag的地址。参数是指针，要通过G键跳转到对应的内存地址处查看。\n\n![image-20250522122253781](/pictures/ISCTF2024/image-20250522122253781.png)\n\n- #### 找到INPUT之后，再酌情分析程序还有哪些重要部分。然后忽略其他操作，除开与输入flag相关的部分，其他都可以不管，需要什么可以靠动调直接读取值。\n\n- #### 看到长度比较和赋值部分，这一大堆数据很可能就是密文，但是不能着急，密文也是可以做处理的，不到最后比对的时候都不要完全确定密文。\n\n![image-20250522122710905](/pictures/ISCTF2024/image-20250522122710905.png)\n\n- #### 看到下面前两个函数都是对密文进行操作，v35->v40->v36，不用管。我们只需要锁定住我们的输入即可，v29就是输入字符串的指针，我们看到v29只在405F80参数处出现了，而且下面就是比对了。所以该题应该只在这个函数里面进行了处理。\n\n![image-20250522122830052](/pictures/ISCTF2024/image-20250522122830052.png)\n\n- #### 下面的比对操作，需要简单跟踪变量值确定变量代表的含义，在进入406AA0时下断点取出密文值即可。\n\n![image-20250522123228352](/pictures/ISCTF2024/image-20250522123228352.png)\n\n- #### 重点是怎么知道对输入的操作是什么样子的，在上面的v29处找到输入的flag，打下内存断点，这样每当程序去访问这个地址时就会触发断点，分别我们分析程序对flag做了什么处理。具体操作就是在数据头摁下F2下断点，然后填下数据长度就行。\n\n![image-20250522123655696](/pictures/ISCTF2024/image-20250522123655696.png)\n\n- #### 之后就可以看情况F9策马奔腾了，注意ntdll有时候回访问这个内存地址的，我们可以通过查看断点表，随时开启或关闭断点，记得配合程序断点，关闭内存断点，直接F9来跳过ntdll的访问，我们只关心主要逻辑对该地址的访问。跳出ntdll后，再开启内存断点。\n\n![image-20250522123845878](/pictures/ISCTF2024/image-20250522123845878.png)\n\n![image-20250522123934610](/pictures/ISCTF2024/image-20250522123934610.png)\n\n\n\n​\t最后复现WP，自己手动找到数据，解密成功。\n\n​\t通过本题，我学习到了内存断点找加密操作的方法，发现了通过G键进行内存跳转的功能。\n\n```python\ndata = \"A\" * 52\nenc_data = [105, 170, 63, 98, 219, 177, 5, 252, 176, 134, 189, 146, 177, 222, 70, 219, 183, 31, 150, 151, 6, 229, 101, 231, 47, 223, 159, 159, 159, 228, 116, 102, 218, 205, 139, 51, 99, 178, 172, 136, 66, 138, 47, 12, 150, 246, 201, 34, 207, 27, 86, 152]\n\nxor_key = []\nfor i in range(52):\n    xor_key.append(enc_data[i] ^ ord(data[i]))\n\n\nenc_flag =[97, 184, 61, 119, 220, 139, 54, 200, 130, 179, 163, 226, 196, 192, 106, 255, 155, 110, 165, 175, 20, 197, 66, 195, 49, 242, 191, 144, 185, 250, 19, 1, 196, 245, 165, 7, 125, 179, 159, 172, 92, 140, 94, 34, 179, 232, 200, 60, 220, 57, 35, 164]\nflag = \"\"\n\nfor i in range(52):\n    flag += chr(enc_flag[i] ^ xor_key[i])\n\nprint(flag)\n```\n","tags":["CTF"],"categories":["学习笔记"]},{"title":"Hello World","url":"/2025/06/04/hello-world/","content":"Welcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/one-command-deployment.html)\n"},{"title":"BaseCTF2024","url":"/2025/06/04/BaseCTF/BaseCTF2024_RE/","content":"\n\n\n------\n\n> **UPX mimi：**\n>\n> ​\t初步接触到了UPX加壳保护的知识和对应的脱壳工具，这是一种“压缩”保护壳，即将源程序代码进行压缩，然后配上解压缩代码，组成新的程序，即“UPX解压代码”+“压缩的源文件”。在程序启动时，会先执行UPX的解压代码，得到解压后的源文件，然后将控制流转移到源文件。\n\n> **ez_maze:**\n>\n> ​\t最基础的迷宫题目，从IDA中可以直接看到迷宫，人工就能得到路径。\n\n> **BasePlus:**\n>\n> ​\t无保护，直接拖入IDA，考察基础的阅读代码的能力，加密函数为Base64的一点点变化，对Base64加密后继续异或一下。很基础。第一次认真搓Base64的c语言代码，收获不少。\n\n> **Ez_Xor:**\n>\n> ​\t复习了大小端序的知识。\n>\n> ​\t“小端序”：低位有效字节保存在小地址。如0xDEADBEEF在内存中的顺序是（小地址）EF BE AD DE（大地址）。“大端序”相反。\n>\n> ​\t本题就是简单的流加密，生成密钥流然后加密。对应解密即可。\n\n> **UPX:**\n>\n> ​\t有壳，直接脱壳报错。学习到了，改标志位来保护加壳程序的手段，我们的反制操作就是打开文件，将对应的标志位从小写改回大写。之后就可以正常脱壳了。\n>\n> ​\t拖入IDA后，考察的是换表的Base64。唯一需要注意的点就是因为题目源码是C语言，在IDA字符串显示中给双引号全面加了转义符号的，不要搞错了。\n\n![image-20250425170632940](/pictures/BaseCTF2024/image-20250425170632940.png)\n\n> **lk:**\n>\n> ​\t比较大的线性方程组，考察python的z3solver库使用。\n\n> **喝杯下午茶：**\n>\n> ​\t标准的Tea加密，第一次使用C语言实现了该算法，收获不少。\n\n> **Ezpy:**\n>\n> ​\t考察python打包出的EXE程序。反编译出源码。\n>\n> ​\t再考察RC4加密。\n\n> **最简单的编码：**\n>\n> ​\t无保护技术，纯考验伪代码的阅读水平，耐下心来分析就好了。\n\n> **neuro爱数学：**\n>\n> ​\t\n\n> **RivestCipher:**\n>\n> ​\t考察标准RC4加密算法。\n\n> **ezAndroid:**\n>\n> ​\t收获到了逆向apk安装包的软件jadx，接触到了so文件（共享库）逆向，是一些没有接触过的操作。又要读奇怪的代码。唉！\n\n------\n\n# **UPX PRO MAX**\t\n\n​\t直接运行EXE程序，会出现下图的显示。\n\n![image-20250506132159230](/pictures/BaseCTF2024/image-20250506132159230.png)\n\nDIE也看到UPX壳。\n\n![image-20250506132311405](/pictures/BaseCTF2024/image-20250506132311405.png)\n\n直接上工具是不行的啊，报错了。\n\n跟着WP学习——**利用ESP定律x64dbg手脱UPX壳**。\n\n> “ESP定律”也称“堆栈平衡定律”\n>\n> 由于在程序自解密或者自解压过程中, 多数壳会先将当前寄存器状态压栈, 如使用`pushad`, 而在解压结束后, 会将之前的寄存器值出栈, 如使用`popad`. 因此在寄存器出栈时, 往往程序代码被恢复, 此时硬件断点触发（这就是我们要下硬件断点的原因），然后在程序当前位置, 只需要一些单步操作, 就会到达正确的OEP位置。\n>\n> 1. 程序刚载入开始 `pushad/pushfd`\n> 2. 将全部寄存器压栈后就设对 ESP 寄存器设硬件断点\n> 3. 运行程序, 触发断点\n> 4. 删除硬件断点开始分析\n\n在x64dbg中，F9两次后来到这个压栈的操作处。接着单步运行一次，看到ESP的值为红色，代表其值被修改了，我们右键选择“在内存窗口中转到”，然后在栈中打下硬件断点。\n\n![image-20250506133643545](/pictures/BaseCTF2024/image-20250506133643545.png)\n\n![image-20250506134057787](/pictures/BaseCTF2024/image-20250506134057787.png)\n\n![image-20250506134312068](/pictures/BaseCTF2024/image-20250506134312068.png)\n\n之后F9，触发断点后单步运行几下就找到OEP了，即程序入口点。可以看到这个地方的多次pop指令。\n\n根据wp中的提示，0X41CF65跳转的地方就是程序的入口点了。应该是了。\n\n![image-20250506134519180](/pictures/BaseCTF2024/image-20250506134519180.png)\n\n下面根据WP中的操作介绍一步步就可以脱出无壳的程序了，叫UPX_PRO_MAX_dump_SCY.exe。\n\n> `scylla`插件：在 x64dbg 中内置的 Scylla 插件可用于 dump 进程，**即将内存中的程序数据转储到磁盘上**，形成一个可执行文件的副本，方便后续对程序的分析和研究。\n>\n> `IAT AutoSearch`： 在分析经过加壳或加密的程序时，程序的导入表可能被破坏或隐藏，IAT AutoSearch 可以自动扫描内存或代码段，寻找可能的导入函数地址，帮助逆向工程师快速找到程序所调用的外部函数。\n\n> 程序的导入表是程序的关键数据结构，用于列出程序运行时需要从其他模块（通常是 DLL）中导入的函数和变量。以下是导入表的详细介绍：\n>\n>   * 导入表是程序的一个数据结构，它包含了一系列的引用信息，指向程序运行时需要调用的外部函数和变量所在的模块及其具体地址。\n>\n> \n>\n>   * **便于调用外部模块功能** ：程序通常不会将所有功能都自己实现，而是通过调用系统或第三方提供的 DLL 中的函数和变量来实现复杂的功能。导入表就像一个目录，告诉操作系统程序需要从哪些 DLL 中使用哪些功能。\n>   * **便于程序的动态链接** ：它支持程序的动态链接机制。程序在编译时不会直接将 DLL 中的函数和变量代码包含进来，而是在运行时装载所需的 DLL，并通过导入表找到具体的函数和变量地址，这样可以减少程序自身的体积，同时方便对 DLL 进行更新和共享。\n>\n> \n>\n>   * **导入模块名表** ：存放了程序需要导入的各个模块的名字，比如 “kernel32.dll”“user32.dll” 等。\n>   * **导入函数名表** ：对于每个导入模块，都有一个对应的导入函数名表，列出了从该模块中导入的具体函数名称，如 “MessageBoxA”“CreateFileA” 等。\n>   * **导入函数地址表（IAT）** ：在程序运行时，操作系统会将每个导入函数的实际内存地址填入这个表中，程序通过这个表中的地址来调用相应的函数。\n\n脱壳后的程序导入IDA中，很清晰的加密逻辑。直接逆向写脚本就行。\n\n![image-20250506141212651](/pictures/BaseCTF2024/image-20250506141212651.png)\n\n但是这里出现了一个坑：`sub_401550`函数其实就是一些加密字符串移动操作，分成几部分存储在几个变量中。但是在验证函数中，全程只用到了a1和a2部分，也就是sub_401550中的a2和a3，不是完整的密文，我觉得这里是中间出了问题，而且这个提取出来的exe程序无法正常运行，IDA中也调试不行，只能静态分析。所以还是有点不靠谱的东西存在。\n\n![image-20250506142108769](/pictures/BaseCTF2024/image-20250506142108769.png)\n\n![image-20250506141429954](/pictures/BaseCTF2024/image-20250506141429954.png)\n\n------\n\n# EZ_VM\n\n​\t基本信息：`pyinstaller`打包的`ELF64`位程序，使用`pydumpck`解包得到`py`文件。\n\n​\t加密逻辑在`what.py`文件，打开，里面函数名称和变量名都是用数字代替的，还有一些小错误，比如本来的“while”语句变成“if”，需要改过来。\n\n​\t代码的逻辑就是：分别使用一个数组变量和一个字典来模拟一个栈和内存，使用变量模拟寄存器，通过数组的`pop`和`push`模拟栈的操作，使用函数定义各种汇编指令，如push、pop、add、sub等等，都是统一操作数长度。就这样定义了一个能够通过汇编指令进行运行的“虚拟机”，里面存在出题人预先写好的一段静态汇编代码，作为加密函数。\n\n> 1. 我们首要任务就是给源python代码进行重命名和明显的错误纠正。（需要足够熟悉汇编指令，起码的要知道。转移指令还没那么重要，因为我们不关心程序的执行流程，我们只需要注意密文的来处即可。）\n> 2. 然后在其中插入print调试语句输出操作指令、栈和内存的值，锁定密文的存储地方，观察加密方法。\n> 3. 根据加密方法写逆向脚本。\n\n​\t\n\n```python\nenc_flag = [\n    35,\n    18,\n    22,\n    38,\n    23,\n    18,\n    61,\n    25,\n    83,\n    4,\n    0,\n    5,\n    5,\n    83,\n    95,\n    20,\n    29,\n    83,\n    82,\n    1,\n    29,\n    25,\n    0,\n    0,\n    81,\n    72,\n    76,\n    85,\n    3,\n    85,\n    79,\n    73,\n    83,\n    0,\n    15,\n    9,\n    85,\n    7,\n    80,\n    82,\n    0,\n    5,\n    84,\n    77,\n    130]\n\n\nclass Opcode:\n    vm_push = 240\n    vm_pop = 241\n    vm_and = 242\n    vm_or = 243\n    vm_not = 244\n    vm_xor = 245\n    vm_jmp = 246\n    vm_jz = 247\n    vm_label = 248\n    vm_strlen = 249\n    vm_loadchar = 250\n    vm_store = 251\n    vm_load = 252\n    vm_add = 253\n    vm_sub = 254\n\n\nclass VM:\n\n    def __init__(self):\n        self.stack = []\n        self.bytecode = []\n        self.pc = 0\n        self.labels = {}\n        self.memory = {}\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if not self.stack:\n            raise IndexError('something wrong..')\n        return self.stack.pop()\n\n    def _scan_labels(self):\n        labels = {}\n        pc = 0\n        while pc < len(self.bytecode):\n            if self.bytecode[pc] == Opcode.vm_label:\n                label_name = self.bytecode[pc + 1]\n                labels[label_name] = pc\n                pc += 2\n            else:\n                pc += 1\n\n        return labels\n\n    def vm_and(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b & a)\n\n    def vm_or(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b | a)\n\n    def vm_not(self):\n        b = self.pop()\n        self.push(~b)\n\n    def vm_xor(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b ^ a)\n\n    def vm_jmp(self):\n        label_name = self.bytecode[self.pc]\n        self.pc = self.labels[label_name]\n\n    def vm_jz(self):\n        label_name = self.bytecode[self.pc]\n        self.pc += 1\n        a = self.pop()\n        b = self.pop()\n        if a == b:\n            self.pc = self.labels[label_name]\n\n    def vm_strlen(self):\n        string = self.pop()\n        self.push(len(string))\n\n    def vm_loadchar(self):\n        string = self.pop()\n        index = self.pop()\n        self.push(ord(string[index]))\n\n    def vm_store(self):\n        value = self.pop()\n        key = self.bytecode[self.pc]\n        if key == 'r':\n            if key not in self.memory:\n                self.memory[key] = []\n            self.memory[key].append(value)\n        else:\n            self.memory[key] = value\n        self.pc += 1\n\n    def vm_load(self):\n        key = self.bytecode[self.pc]\n        self.push(self.memory[key])\n        self.pc += 1\n\n    def vm_add(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b + a)\n\n    def vm_sub(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b - a)\n\n    def run(self, bytecode):\n        self.bytecode = bytecode\n        self.pc = 0\n        self.labels = self._scan_labels()\n        while self.pc < len(self.bytecode):\n            opcode = self.bytecode[self.pc]\n            self.pc += 1\n            if opcode == Opcode.vm_push:\n                value = self.bytecode[self.pc]\n                self.pc += 1\n                self.push(value)\n            elif opcode == Opcode.vm_pop:\n                self.pop()\n            elif opcode == Opcode.vm_and:\n                self.vm_and()\n            elif opcode == Opcode.vm_or:\n                self.vm_or()\n            elif opcode == Opcode.vm_not:\n                self.vm_not()\n            elif opcode == Opcode.vm_xor:\n                self.vm_xor()\n            elif opcode == Opcode.vm_jmp:\n                self.vm_jmp()\n            elif opcode == Opcode.vm_jz:\n                self.vm_jz()\n            elif opcode == Opcode.vm_label:\n                self.pc += 1\n            elif opcode == Opcode.vm_strlen:\n                self.vm_strlen()\n            elif opcode == Opcode.vm_loadchar:\n                self.vm_loadchar()\n            elif opcode == Opcode.vm_store:\n                self.vm_store()\n            elif opcode == Opcode.vm_load:\n                self.vm_load()\n            elif opcode == Opcode.vm_add:\n                self.vm_add()\n            elif opcode == Opcode.vm_sub:\n                self.vm_sub()\n            else:\n                raise ValueError('something wrong')\n            print(f\"pc: {self.pc}| opcode: {get_opcode_name(opcode)}, stack: {self.stack}, memory: {self.memory}\")\n\n    def encrypt(self, serial):\n        bytecode = [\n            Opcode.vm_push, serial,\n            Opcode.vm_strlen,\n            Opcode.vm_store, 'l1',\n            Opcode.vm_push, 0,\n            Opcode.vm_store, 'i',\n            Opcode.vm_label, 's',\n            Opcode.vm_load, 'l1',\n            Opcode.vm_push, 1,\n            Opcode.vm_sub,\n            Opcode.vm_load, 'i',\n            Opcode.vm_jz, 'e',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, 1,\n            Opcode.vm_add,\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_xor,\n            Opcode.vm_store, 'r',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, 1,\n            Opcode.vm_add,\n            Opcode.vm_store, 'i',\n            Opcode.vm_jmp, 's',\n            Opcode.vm_label, 'e',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_push, 255,\n            Opcode.vm_xor,\n            Opcode.vm_store, 'r'\n        ]\n        self.run(bytecode)\n        enc = self.memory['r']\n        return enc\n\ndef get_opcode_name(opcode):\n    for name, value in Opcode.__dict__.items():\n        if value == opcode:\n            return name\n    return None\n\nvm = VM()\ntest_flag = \"BaseCTF{VM_is_awesome}\"\nenc = vm.encrypt(test_flag)\nprint(f\"encrypted test_flag: {enc}\")\nprint(f\"original flag: {enc_flag}\")\n```\n\n根据WP提示重命名后，观察传输的调试信息。看一下开头和结尾就行。\n\n![image-20250509160138052](/pictures/BaseCTF2024/image-20250509160138052.png)\n\n![image-20250509160305470](/pictures/BaseCTF2024/image-20250509160305470.png)\n\n​\t所以猜到加密逻辑是：从前往后，相邻两位异或，尾部和255异或。\n\n这里给出我的解密脚本。\n\n```python\nenc_flag = [35, 18, 22, 38, 23,  18,61, 25,  83,4,0, 5, 5,83,95,  20,  29, 83,82,  1, 29, 25, 0,0,81,72,76,85,3,85,79,73,83,0,15,9,85,7,80,82,0,5,84,77,130,255]\n\nflag = \"\"\nfor i in range(len(enc_flag)):\n    char = enc_flag[i]\n    for j in range(i+1, len(enc_flag)):\n        char = char ^ enc_flag[j]\n\n    flag += chr(char)\n\nprint(flag)\n```\n\n------\n\n# Microgame\n\n​\t不理解，不会游戏逆向，后面得学啊。专门做了一个CE的学习。\n\n​\t学习完CE，专门出个WP来做。\n\n------\n\n# neuro爱数学\n\n​\t直接打开IDA看看`main`函数，程序无壳，就是考察数学问题。\n\n![image-20250512120720066](/pictures/BaseCTF2024/image-20250512120720066.png)\n\n![image-20250512130852846](/pictures/BaseCTF2024/image-20250512130852846.png)\n\n![image-20250512130953971](/pictures/BaseCTF2024/image-20250512130953971.png)\n\n```c\n#include<stdio.h>\n#include<stdint.h>\n#include<intrin.h>\n\nint main(){\t\t\t\t\t\t\t\t//注意：各个变量和函数的类型是关键，不能搞错，需要对照IDA伪代码\n    int64_t v5=0x400C0210000001;\t\t\t//这个值是固定的，但是需要动调程序得到这个值。\n\n    for(int i=-60; i<=59; i++){\n        if(i == 44 || i == 58){\n            printf(\"符合条件的i值位：%d/n\", i);\n            continue;\n        }\n\n        unsigned int v12 = (unsigned int)(i + 37);\n        if(v12 <= 54 && _bittest64((int64_t*)&v5,(unsigned int)v12) != 0){\n            printf(\"符合条件的i值为：%d/n\", i);\n        }\n\n    }\n\n    return 0;\n}\n\n```\n\n![image-20250512131328904](/pictures/BaseCTF2024/image-20250512131328904.png)\n\n然后使用python脚本展开多项式得到系数。\n\n````python\nfrom sympy import symbols, expand\n\n# 定义符号变量\nx = symbols('x')\n\n# 构造多项式\npolynomial = (x - 44) * (x - 58) * (x - 5) * (x + 37) * (x - 17) * (x + 9) * (x - 6) * (x + 4)\n\n# 展开多项式\nexpanded_polynomial = expand(polynomial)\n\n# 提取并打印系数\nstandard_form = expanded_polynomial.as_poly()  # 获取标准形式的多项式\ncoefficients = standard_form.all_coeffs()    # 获取所有系数\n\n# 打印系数逆序（从常数项到最高次项）。因为正常是从高次项到低次项。\nprint(coefficients[::-1])\n#[-1733624640, 134045088, 122783468, -12168520, -1364231, 121272, -358, -80, 1]\n````\n\n![测试图片](/pictures/BaseCTF2024/image-20250512131708984.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["CTF"],"categories":["学习笔记"]},{"title":"about","url":"/about/index.html"},{"title":"categories","url":"/categories/index.html"},{"title":"tags","url":"/tags/index.html"}]