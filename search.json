[{"title":"阅读APP项目学习——2","url":"/2025/06/22/阅读项目学习/安卓项目学习2/","content":"\n​\t欢迎页开始后，就进入主体**MainActivity**中，查看源码可以发现，其使用了众多自定义的其他类。\n\n​\t\n\n### 概述\n\n​\t先大体通过AI分析一波，看看这个主页面在干什么。\n\n- 页面初始化和布局设置：继承自 **MBaseActivity<IMainPresenter>**，采用 MVP 架构设计（视图层 **MainActivity** 负责UI，**IMainPresenter** 负责业务逻辑）。初始化页面上的控件，如应用logo、几个功能按钮（打赏、设置、书库、添加书籍、下载）、刷新列表控件（**RefreshRecyclerView**）等。\n\n- 显示书架列表：使用**RefreshRecyclerView**来展示书架内容，使用自定义的**BookShelfAdapter**作为列表的适配器，再通过布局管理器**LinearLayoutManager**来控制**RecyclerView**布局。\n- 刷新和加载数据：绑定刷新监听器（**OnRefreshWithProcessListener**）来实现下拉刷新书架数据，刷新时调用**mPresenter.queryBookShelf(true)**请求最新数据。同时处理刷新完成和刷新错误的回调，并更新UI和进度条。\n- 事件处理：给首页的各个按钮绑定点击事件：设置按钮弹出代理设置窗口；下载按钮弹出下载列表窗口；书库按钮跳转到书库界面（**LibraryActivity**）；添加书籍按钮跳转到导入书籍界面；打赏按钮预留了点击事件，具体逻辑没写。给书架列表的每个书籍绑定了点击事件：点击跳转到阅读界面；长按跳转到书籍详情界面，并带动画效果。书架中点击“去选书”会跳转到书库。\n- 管理警告信息弹窗：页面上有一个警告信息区域（**flWarn**），可以通过关闭按钮隐藏。\n- 处理系统按键事件：捕获返回键，实现“连续两次按返回键退出应用”的交互逻辑。\n- 生命周期管理：在 **onDestroy** 里做资源销毁，比如关闭弹窗。\n\n\n\n> ​\t上面比较陌生的概念有“适配器”，这是什么东西啊？\n>\n> ​\t举个简单的例子：你想在家里的书架上摆书，RecyclerView就是书架，适配器就是按顺序拿书，一本一本摆放书籍的人，书本的数据就是你手里的书。没有适配器，你的书架就不知道摆哪些书，也不知道怎么摆。\n\n\n\n\n\n### 逻辑解读\n\n​\t\n\n```java\n//成员变量声明\n    private ImageView ivLogo;           //应用logo图标\n    private ImageButton ibMoney;        //打赏按钮\n    private ImageButton ibSettings;     //设置按钮\n    private ImageButton ibLibrary;      //书库按钮\n    private ImageButton ibAdd;          //添加书籍按钮\n    private ImageButton ibDownload;     //下载按钮\n\n    private RefreshRecyclerView rfRvShelf;\n    private BookShelfAdapter bookShelfAdapter;\n\n    private FrameLayout flWarn;         //警告信息布局（弹出框）\n    private ImageView ivWarnClose;      //关闭警告按钮\n\n    private DownloadListPop downloadListPop;        //下载列表弹窗对象\n    private ProxyPop proxyPop;          //代理设置弹窗对象\n```\n\n​\tImageView是安卓里面用来显示图片的控件，就是一个”图片框“，专门用来在界面上展示图片，比如应用图标、照片、按钮图标等等，只负责显示图片，不响应点击事件（当然，你可以给它加点击事件，让它像按钮一样用）。\n\n​\tImageButton就是有图片的按钮。\n\n​\t其他就是自定义的组件了。\n\n\n\n​\t\n\n​\t看到具体的方法，**initInjector**是在初始化一个Presenter对象，然后返回一个**MainPresenterImpl**实例，负责与界面业务逻辑交互。\n\n​\t**onCreateActivity**设置界面的布局文件。\n\n​\t**initData**初始化数据，创建书架适配器实例。\n\n​\t**dispatchTouchEvent**处理触摸事件，调用父类的方法，套壳函数。\n\n​\t**bindView**绑定界面控件（找控件、实例化），找到布局里的各种控件（按钮、列表、弹窗等），并关联到变量，给书架列表 `RecyclerView` 设置适配器和布局管理器。\n\n​\t**bindEvent**绑定各种事件监听器。\n\n​\t**bindRvShelfEvent**给书架的刷新控件绑定刷新监听。\n\n​\t**firstRequest**首次加载数据，应用打开时调用。\n\n​\t**refreshBookShelf**将新的书籍列表数据传给适配器，更新显示。\n\n​\t**activityRefreshView**触发书架刷新动作，让刷新控件开始刷新动画并调用刷新逻辑。\n\n​\t**refreshFinish**刷新结束，隐藏刷新动画。\n\n​\t**refreshError**刷新错误时调用。\n\n​\t**refreshRecyclerViewItemAdd**刷新时进度条+1。\n\n​\t**setRecyclerMaxProgress**设置刷新进度条的最大值。\n\n​\t**onKeyDown**按键事件处理，用户按返回键时，调用 `exit()` 方法，实现“再按一次退出程序”的逻辑。\n\n​\t**onDestroy**资源销毁时调用，清理一些弹窗的资源，防止内存泄漏。\n\n​\t**exit**退出程序的逻辑，如果2秒内第二次按返回键，则退出程序，否则提示“再按一次退出程序”。\n\n\n\n\n\n### 前端页面复现\n\n​\t看到XML文件，里面使用到一个自定义的组件**com.monke.monkeybook.widget.refreshview.RefreshRecyclerView**，\n\n下图中的空白区域就是这个组件的位置。当然也包括一个作者自己开源的沉浸框，需要引用依赖。\n\n​\t里面的布局很清晰明了，沉浸框包裹最外层，然后一个垂直方向的线性布局来隔分上下页面，里面再由水平的线性布局来展示顶部，下面就是书架区。\n\n![image-20250622115453885](/pictures/novelReader_app/image-20250622115453885.png)\n\n​\t需要导入对应的drawable里面的XML文件、layout里面的其他XML文件、values里面的XML文件。然后写入**RefreshRecyclerView**类、**RefreshProgressBar**类、**RefreshRecyclerViewAdapter**抽象类、**OnRefreshWithProgressListener**接口、**OnLoadMoreListener**接口、**BaseRefreshListener**接口，还有**BookContentView**类，因为这个类又引出一堆其他的类和接口。太麻烦了。\n\n​\t先放着BookContentView不管吧，还有其他几个**BitIntentDataManager**、**MApplication**、**ReadBookControl**都有点问题啊！这样分析也太麻烦了。不能按照这个逻辑搞下去。\n\n\n\n\n\n### 具体功能流程分析\n\n​\t先从最简单的退出功能来说吧，不然都没法读下去了。\n\n```java\n\t@Override\n    public boolean onKeyDown(int keyCode, KeyEvent event) {\n        if (keyCode == KeyEvent.KEYCODE_BACK) {\n            exit();\n            return true;\n        }\n        return super.onKeyDown(keyCode, event);\n    }\n\n\tprivate long exitTime = 0;\n\tpublic void exit() {\n        if ((System.currentTimeMillis() - exitTime) > 2000) {\n            Toast.makeText(getApplicationContext(), \"再按一次退出程序\",\n                    Toast.LENGTH_SHORT).show();\n            exitTime = System.currentTimeMillis();\n        } else {\n            finish();\n            System.exit(0);\n        }\n    }\n```\n\n​\t当用户摁下”返回键“，触发onKeyDown方法，会调用exit方法，导致退出程序。keyCode表示当前被按下的按键的代码（编号），KeyEvent.KEYCODE_BACK是安卓系统定义的常量，代表”返回键“的按键代码。System.currentTimeMillis方法返回一个”long“类型的数字，表示从“1970年1月1日午夜”（称为“Unix纪元”）开始，到当前时刻所经过的毫秒数。\n\n​\t第一次摁下”返回键“会设置exitTime为当前时间，然后需要在两秒内再摁一次，才进入else里面。\n\n​\tfinish方法，**只是告诉系统“关闭这个Activity”，但它是异步的，不会立即停止当前方法的执行**。`finish()` 会请求系统去销毁Activity（触发生命周期`onPause() -> onStop() -> onDestroy()`），但是这个过程是在系统消息队列中排队执行的，并不会马上跳出当前方法或终止线程，但是这个过程是在系统消息队列中排队执行的，并不会马上跳出当前方法或终止线程。\n\n\n\n\n\n\n\n### AI总结主页面功能\n\n​\t后面就根据这些功能，开始进行分块讲解，包括代码跟踪讲解，这样会更加让我专注于功能的实现。\n\n> ### 1. 界面初始化和视图绑定\n>\n> - **加载界面布局**（`setContentView`），让页面显示出来\n> - **查找并绑定控件**，比如logo图标、按钮、书架列表等\n> - **初始化书架适配器**，管理书籍列表的显示\n>\n> ### 2. 数据展示和刷新\n>\n> - **展示书架列表数据**，把数据加载到书架适配器里，显示在列表中\n> - **支持下拉刷新**，用户下拉列表时，重新请求数据，刷新书架内容\n> - **刷新进度反馈**，通过进度条显示刷新进度，提高用户体验\n>\n> ### 3. 用户交互处理\n>\n> - **按钮点击事件**\n>   - 点击“设置”按钮弹出代理设置窗口\n>   - 点击“下载”按钮弹出下载列表\n>   - 点击“打赏”按钮触发打赏操作（这里没实现具体逻辑）\n>   - 点击“书库”按钮进入书库页面\n>   - 点击“添加书籍”按钮进入导入书籍页面\n> - **书架书籍点击**\n>   - 点击书籍跳转到阅读页面，打开书籍\n>   - 长按书籍跳转到书籍详情页面，带动画效果\n>\n> ### 4. 弹窗与提示\n>\n> - 弹出代理设置和下载列表弹窗，方便用户操作\n> - 警告信息框的显示和关闭，提醒用户重要信息\n>\n> ### 5. 生命周期与退出\n>\n> - 监听手机返回键，防止误操作退出\n> - 实现“双击返回键退出程序”的逻辑，提高用户体验\n> - 退出时释放资源，防止内存泄漏\n>\n> ​\t\t","tags":["安卓开发学习"],"categories":["开发"]},{"title":"阅读APP项目学习——1","url":"/2025/06/21/阅读项目学习/安卓项目学习1/","content":"\n# \t前言\n\n​\t该阅读项目是[MONKOVEL](https://github.com/ZhangQinhao/MONKOVEL)，我将分析学习其项目设计和JAVA代码，我没什么语言基础，也没有开发经验，此系列将记录我在这个项目中自学到的知识。\n\n​\t\n\n# \t正文\n\n​\t先看到`AndroidManifest.xml`文件，查看APP存在多少个Activity（界面）：`WelcomeActivity`类负责欢迎界面，实现一个动画的效果。\n\n```xml\n<activity\n            android:name=\".view.impl.WelcomeActivity\"\n            android:screenOrientation=\"portrait\">\n            <intent-filter>\n                <action android:name=\"android.intent.action.MAIN\" />\n\n                <category android:name=\"android.intent.category.LAUNCHER\" />\n            </intent-filter>\n        </activity>\n```\n\n​\t之后会跳转到主界面。\n\n```java\npublic void onAnimationEnd(Animator animation) {\n                startActivityByAnim(new Intent(WelcomeActivity.this, MainActivity.class), android.R.anim.fade_in, android.R.anim.fade_out);\n                finish();\n            }\n```\n\n\n\n​\t`MainActivity`负责主页面的呈现，展示从各个网站解析来的书籍；`SearchActivity`类负责关键词搜索，可能会调用网络接口或本地数据库查询；`DownloadService`负责后台下载任务，通常是service类型，不阻塞UI，管理下载队列，处理断点续传等等；还有`LibraryActivity`书架页面、`ChoiceBookActivity`书籍选择页面、`BookDetailActivity`书的详细详细、`ReadBookActivity`负责阅读界面、`ImportBookActivity`负责本地导入书籍。\n\n\n\n\n\n## 复现\n\n​\t首先可以单独复现出welcome界面，先处理好xml文件，会需要导入包：注意新的写法是`implementation(\"...\")`。写入`activity_welcome.xml`文件，复制图片资源到res目录下，改写系统默认的`AndroidManifest.xml`文件，删除系统给的`MainActivity`部分。后面从`view.impl.WelcomeActivity`开始慢慢抄入其他文件，暂时不需要的功能可以注释掉。\n\n​\t\n\n### MVP架构\n\n​\t实现`IView`和`IPresenter`接口，这是MVP设计架构中常见的基础接口。\n\n> MVP的思想是：View（视图）：负责“显示”和“用户交互”。\n>\n> ​\t\tPresenter（中间人）：负责“处理逻辑”和“沟通”。\n>\n> ​\t\tModel（模型）：负责“数据和业务逻辑”。\n>\n> MVP 就是把“显示界面”和“业务逻辑”拆开，让代码更整洁、更容易维护\n\n> #### 真实开发中：\n>\n> - 你的手机界面就是 View，负责显示按钮、列表等\n> - 代码里写的 Presenter 负责监听按钮，处理业务逻辑\n> - Model 负责数据存取，比如从数据库拿数据，或者调用网络接口\n\n​\t\n\n​\t\n\n```java\npublic interface IView {\n    public Context getContext();\n}\n```\n\n​\t看到`IView`的接口方法，`getContext`方法，什么是Context？看一下ChatGpt的看法。\n\n> - **Context 就像手机里的“万能钥匙”或者“工具箱”**，它告诉你“现在在哪个环境下”，可以帮你访问很多系统服务、资源，甚至打开新页面、显示提示消息。\n> - 假设你在一个大商场里，Context 就像你的商场会员卡，你拿着会员卡，商场才知道你是谁、你在哪个店铺、你可以用哪些优惠，通过会员卡，你可以去不同的柜台（服务）办事情，比如买东西、退货、查余额。\n> - 在代码里 Context 能做什么？打开新界面、显示弹窗、访问资源、获取系统服务（比如网络、传感器）、访问文件、数据库等等。\n> - 举个简单例子，`Toast.makeText(context, \"Hello!\", Toast.LENGTH_SHORT).show();`，这句话的 `context` 就告诉系统，“你现在在哪个环境下显示这个弹窗”，系统才能正确地把弹窗显示在屏幕上。\n> - 常见的 Context 类型：**Activity**，它本身就是一个 Context，代表一个界面；**Application**，整个应用程序的全局 Context；**Service**，后台服务的 Context。\n\n​\t`getContext`是给谁用的？————给 **Presenter（业务逻辑层）用的**，Presenter 通过 `IView.getContext()` 拿到这个环境（Context），就能做很多事情。\n\n​\t看看例子，很清楚。\n\n```java\npublic class MainPresenter implements IPresenter {\n    private IView view;\n    @Override\n    public void attachView(@NonNull IView iView) {\n        this.view = iView;\n    }\n    @Override\n    public void detachView() {\n        this.view = null;\n    }\n    public void showMessage() {\n        // 通过view拿Context来显示Toast\n        Toast.makeText(view.getContext(), \"Hello MVP!\", Toast.LENGTH_SHORT).show();\n    }\n}\n```\n\n\n\n\n\n\n\n```java\npublic interface IPresenter {\n    /**\n     * 注入View，使之能够与View相互响应\n     */\n    void attachView(@NonNull IView iView);\n    /**\n     * 释放资源，如果使用了网络请求 可以在此执行IModel.cancelRequest()\n     */\n    void detachView();\n}\n```\n\n​\t看到`IPresenter`接口，`attachview`就是提供的用来绑定view和presenter的方法。\n\n​\t什么时候会调用？  一般是在界面刚创建或刚准备好跟 Presenter 交互的时候调用，比如 `Activity` 的 `onCreate()` 或 `onStart()` 里。\n\n​\t谁来调用？  通常是 **View（界面层，比如 Activity）自己调用**，或者有时是在创建 Presenter 的时候由框架或代码调用。\n\n​\t为什么？  因为 Presenter 需要知道它服务的是哪个 View，才能让 View 显示数据或者响应用户操作。\n\n\n\n​\t下面是AI举得小例子，很了然了。\n\n```java\npublic class MainActivity extends AppCompatActivity implements IView {\n    private IPresenter presenter;\n    @Override\n    protected void onCreate(Bundle savedInstanceState) {\n        super.onCreate(savedInstanceState);\n        setContentView(R.layout.activity_main);\n        presenter = new MainPresenter();\n        presenter.attachView(this);  // 把自己（View）传给Presenter，绑定关系建立\n    }\n    @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        presenter.detachView();  // 解绑，防止内存泄漏\n    }\n    // 实现IView的方法\n    @Override\n    public Context getContext() {\n        return this;\n    }\n}\n```\n\n\n\n​\t我们查看presenter和view文件夹也发现了这个一一对应的关系，除了欢迎界面（因为没有交互，所以不需要）。\n\n![image-20250621210554075](/pictures/novelReader_app/image-20250621210554075.png)\n\n\n\n### 其他子类设计\n\n​\t`BaseApplication`基础类。\n\n​\t`AppActivityManager`是一个“Activity管理工具类”：记录、管理当前所有的Activity，能关闭指定的Activity、能判断Activity是否存在、通过弱引用避免内存泄露。\n\n​\t`BaseActivity`是“通用Activity模板”，它封装了 Activity 常用的功能、生命周期管理、和 Presenter 的绑定逻辑，它的作用就是：把每个页面都要重复写的代码（如固定的方法调用，Activity转场动画调用等等），统一写在这个“父类”里，子类只需要关注页面自己的功能实现，省时省力！\n\n​\t`MBaseActivity`是继续添加友盟统计的一个抽象类，能够统计用户的使用情况。\n\n​\t\n\n\n\n​\t再抄下`activity_welcome.xml`布局文件，应该就可以展示第一个界面的效果了。\n","tags":["安卓开发学习"],"categories":["开发"]},{"title":"ISCTF2024","url":"/2025/06/05/ISCTF2024/RE/","content":"\n# Ezre\n\n> ​\t一个简单的维吉尼亚加密，看了半天没看出来，在强行写解密算法后，才突然发现。\n\n------\n\n\n\n# 《回忆安魂曲》三——mainn.exe\n\n\n\n> ​\t迷宫类题目，无壳64位。槽点就是将移动键换成了“love”四个字符，然后迷宫对应的字符串在结尾多给了几个，起到迷惑性效果，差点让我搞不清行列数，还有行坐标从0开始，列坐标从0开始，起始点坐标（1，1）。开始直接把我绕晕。\n>\n> ​\t确定迷宫后，又复习了DFS算法。收获不少。\n\n```python\nmaze_str = \"\"\"###############################P#...............#...#.......#.#####.###.#####.#.###.#####.#.....#...#.#.....#...#.#...#.#####.#.###.#.#######.#.#.###.#C..#.#.#...#.#...#...#.#.#...#.#.#.#.#.###.#.#.#.###.#.#.#.#.#.#.#.#...#...#.#.......#.#.#.###.#.###.#####.#########.###.#...#...#.....#.#.......#...#.#.#####.#####.#.#.#####.###.#...#...#...#...#...#...#.#...#.###.#.###.#.#######.#.#.#.#.#...#.#.#...#.#...#...#...#.#.###.#.#.#####.#.#.#.#######.###.#...#.....#...#.#.#...#.....#.#########.#####.#.###.#.###.#.#.....#.#...#...#...#...#.#.#.#.#.#.#.###.#.#####.###.#.#.#...#.#...#.#...#...#...#...#.#.###.###.#.#####.#.###.###.#.#...#.#.#.......#.#...#.#...#.#####.#.#######.#.#####.#.###.#...#.#.......#.#...#...#.#..E#.#.#.#.#######.###.#.#####.#.#.#...#.............#.....#.#.#.###############.#######.#.#.#.........#...#...#.....#...#.#.#######.#.#.#####.#.#######.#.......#...#.......#.........\"\"\"\n\nfor i in range(30):\n    for j in range(30):\n        print(maze_str[i*30+j], end=' ')\n    print()\n\n\nmaze = []\nfor i in range(30):\n    maze_row = []\n    for j in range(30):\n        maze_row.append(maze_str[i*30+j])\n    maze.append(maze_row)\n\nstart = (1,1)\n\ndef dfs(maze, x, y,path):\n    if maze[x][y] == 'E':\n        return True\n    if x < 0 or x >= len(maze) or y < 0 or y >= len(maze[0]) or maze[x][y] == '#' or maze[x][y] == 'C':\n        return False\n\n    maze[x][y] = '#'\n\n    directions = [(-1,0), (0,-1), (1,0), (0,1)]\n    directions_str = ['l', 'v', 'o', 'e']\n    for i in range(4):\n        dx = directions[i][0]\n        dy = directions[i][1]\n        path.append(directions_str[i])\n        if dfs(maze, x+dx, y+dy,path):\n            return True\n        path.pop()\n\n    maze[x][y] = '.'\n    return False\n\ndef find_path():\n    path = []\n    if dfs(maze, start[0], start[1], path):\n        return path\n    else:\n        return \"No path found\"\n\nans = find_path()\nans = ''.join(ans)\nprint(ans)\n```\n\n------\n\n\n\n# **找啊找**——zhao.exe\n\n> ​\t直接拖入IDA发现只有很少几个函数，于是去查壳发现UPX壳，然后直接-d脱壳失败，拖入HxD发现标志位被改成APK了，改回来就成功脱壳了。\n>\n> ​\t再拖入IDA中就正常了，逻辑很简单，查看加密逻辑，先大小写字母替换，再异或一下。静态分析时直接去数据节查看时，得到一组数据，然后写python代码，跑出来提示为错误的flag，是出题人挖的一个坑。\n>\n> ​\t反复查看加密逻辑发现没有问题，最后动态调试，在比较之前查看数据，发现程序里存储的加密数据被改了，看来是程序在运行初始化时才给出真正的加密flag。取出数据，跑解密脚本就ok了。\n>\n> ​\t还是动调发现问题。\n\n------\n\n\n\n# py不好，会被ban\n\n\n\n> ​\tpython的exe程序。先使用Pyinstxtractor解出pyc，然后直接托在线平台解出py。我开始找的平台解不出来，我还在猜是不是题目加难度了，导致文件进行了一定的修改，不能直接解出来。原来是工具不行！最后看wp才发现这个网站。\n>\n> ​\t解出py后直接反向写解密逻辑即可解密。\n\n\n\n------\n\n\n\n# 你知道.elf文件吗\n\n> ​\t跑不起来，签到题，没有技术含量，算了。\n\n\n\n------\n\n\n\n# 《回忆安魂曲》二——test11\n\n> ​\t一个ELF文件，使用IDA远程调试，收获到了IDA调试ELF程序的方法，进一步增加了动态调试的经验，认识到一种干扰编译的方法，就是在调用程序时，不直接使用call，而是将函数首地址加载进寄存器，然后使用call寄存器调用，这样IDA分析不出来，只有动调能看到其中的跳转逻辑。\n>\n> ​\t查阅知道，这是一种“控制流平坦化”的反编译技术，通过主分发器来控制程序基本块的执行流程。\n>\n> ​\t得知flag长度为36位，然后enc加密，动态调试分析加密逻辑。确定是逐字节加密，假设当前字符下标为i，字符串数组为str。有个密钥key为字符串“i_can_reverse_but_i_can_not_have_you“。\n>\n> ​\t最终得到的加密数据为：[234, 12, 26, 17, 246, 44, 29, 62, 23, 53, 49, 41, 244, 57, 57, 211, 195, 45, 0, 16, 48, 61, 204, 0, 211, 192, 75, 198, 17, 199, 41, 62, 186, 96, 144, 52]\n>\n> - str[i] = str[i] ^ (0x66 + i) ^ 0x52\n>- str[i] = str[i] + 6\n> - str[i] = str[i] ^ (key[i] + i)\n\n```python\nenc = [234, 12, 26, 17, 246, 44, 29, 62, 23, 53, 49, 41, 244, 57, 57, 211, 195, 45, 0, 16, 48, 61, 204, 0, 211, 192, 75, 198, 17, 199, 41, 62, 186, 96, 144, 52]\nkey = 'i_can_reverse_but_i_can_not_have_you'\n\nfor i in range(len(enc)):\n    enc[i] = (enc[i] ^ (ord(key[i]) + i)) & 0xff\n    enc[i] = (enc[i] - 6) & 0xff\n    enc[i] = (enc[i] ^ 0x52 ^(0x66 + i)) & 0xff\n    print(chr(enc[i]), end='')\n    #ISCTF{as_her_never_will_come_back!!}\n```\n\n------\n\n\n\n# 《回忆安魂曲》四——文件夹：初识风仙儿\n\n> ​\t解压得到一个main.py和so文件。这是一个`Cpython`逆向题，我是第一次遇见，先跟着WP学习，但是第一步通过python中的`help函数`查看模块就出问题了。为什么呢，因为几个虚拟机的python版本不对，需要3.10的，而且本机是windows系统，一直是要么导入错系统test模块，要么导入不进，唉，环境愁死人！下载python3.10还把我的ubuntu20.04给干崩了，被我直接删了。**之后再干这种活要拍快照了**！最后在ubuntu24.04中下载好了，然后就导入进去了。真的被环境折磨惨了啊。\n>\n> ​\t看了教程，都是神仙，有的直接猜出加密算法，有的一点点死看IDA中的几千行`Cython代码`，有的凭空生成了so对应的python源代码。一个都行不通，最后在网上找了个AI代码调整，把原本的几千行`Cython`给优化了，出了一个简化的C语言版，并且整理出了核心逻辑，于是我直接看核心加密逻辑，很清晰，然后写解密就出了。\n\n```python\nhack_data = [27, 16, 43, 29, 127, 46, 51, 102, 50, 1, 112, 50, 53, 101, 57, 1] \nkey = 'H1m' sbox = [1, 14, 4, 13, 10, 2, 5, 8, 7, 6, 9, 12, 15, 3, 11, 0]  \nflag_list = [0] * 16  \nfor i in range(len(sbox)):\n    tmp = hack_data[i] ^ ord(key[i % len(key)])\n    flag_list[sbox[i]] = tmp\nfor i in range(len(flag_list)):\n    print(chr(flag_list[i]), end='')\n```\n\n------\n\n\n\n# MIPS\n\n> ​\t一种新的指令集，对应的汇编语言也不一样，需要重新学习。\n\n​\t单独出一个wp来记录学习过程中得到的知识。\n\n------\n\n\n\n\n\n# 桀桀桀\n\n> ​\t`rep stosd是一条高效的字符串操作指令，适用于快速初始化或填充内存区域，edi保存填充地址，ecx保存填充次数，eax保存单次填充值。`\n>\n> ​\t这一题很有意思啊，有花指令、TLS、伪随机数和魔改tea，有很多可学的点，在做题的时候，由于对花指令的不够全面的了解，和对TLS的不全面了解，导致我一直困在对非核心部分的探索学习中，始终未能抓住主要逻辑，最后导致身心疲惫。\n>\n> ​\t于是决定参照WP和网上的资料，好好恶补一下这些方面的知识，并且记录下来。\n\n```python\nfor i in range(0x4119E2, 0x4119E7):\t\t#IDA的patch脚本，记住使用到的函数名就好。\n    idc.patch_byte(i, 0x90)\n```\n\n专门出一个WP，记录一下这些难题。\n\n------\n\n\n\n# 嘿嘿嘿\n\n​\t无壳，验证长度32位，然后进入140001850，有SMC保护技术，我们修改标志位绕过反调试，\n\n![image-20250521110206759](/pictures/ISCTF2024/image-20250521110206759.png)\n\n![image-20250521110250703](/pictures/ISCTF2024/image-20250521110250703.png)\n\n​\t这里也没有调用，我们先不用管140001A0函数，继续去main函数中看程序逻辑。看到1400017B0函数，马上就调用了解密出的函数，参数分别是字符串\"Welcome_to_ISCTF\"，还有两个空数组。\n\n![image-20250521110613803](/pictures/ISCTF2024/image-20250521110613803.png)\n\n​\t先看140001440，对字符串进行异或，存储到a2中，140003270数据可以直接看到。这里需要注意的是，在IDA中数据以小端保存，尽管字符串显示的顺序是“Welcome_to_ISCTF”，但在栈帧中保存的顺序其实是cleW......，需要每4个字节逆序，这样才是a1[i]的值。\n\n![image-20250521110827346](/pictures/ISCTF2024/image-20250521110827346.png)\n\n![image-20250521110918291](/pictures/ISCTF2024/image-20250521110918291.png)\n\n​\t接着进入1400014A0函数，a1是空数组，a2是才加密的中间密钥的指针。如果只是出flag的话，这里没有必要深入分析了，直接取最终密钥就行了。\n\n![image-20250521104520689](/pictures/ISCTF2024/image-20250521104520689.png)\n\n​\t回到主函数，1400017B0函数才是加密的地方，继续看140001630，由于是对明文进行了分块的，分成2个16字节加密的。\n\n![image-20250521113825145](/pictures/ISCTF2024/image-20250521113825145.png)\n\n​\t里面两个函数，一个加密，一个逆序复制。\n\n![image-20250521112328705](/pictures/ISCTF2024/image-20250521112328705.png)\n\n​\t加密以4字节为一个单位，将16字节分为4个元素，加密32轮，整体加密32/4=8轮。加密方式就是异或1400013F0的返回值。\n\n![image-20250521112403260](/pictures/ISCTF2024/image-20250521112403260.png)\n\n​\t\ta2确定是1。a1是那群异或得到的值。\n\n![image-20250521113204681](/pictures/ISCTF2024/image-20250521113204681.png)\n\n​\t这里有一个映射表，256字节。\n\n![image-20250521113218351](/pictures/ISCTF2024/image-20250521113218351.png)\n\n​\t映射后的值为a1.\n\n![image-20250521113233640](/pictures/ISCTF2024/image-20250521113233640.png)\n\n​\t这里其实是一种扩展的左移并记录溢出位的操作。\n\n![image-20250521113401853](/pictures/ISCTF2024/image-20250521113401853.png)\n\n再看这个函数，以4字节为整体进行逆序，因为每次加密只有16字节参与，所以只需要移动4次。\n\n![image-20250521113539461](/pictures/ISCTF2024/image-20250521113539461.png)\n\n看回主函数，通过调试确定，比对的时候密文端序不变，解密脚本中就直接使用数据。\n\n![image-20250521113646251](/pictures/ISCTF2024/image-20250521113646251.png)\n\n最后完全不看WP，自己写出来了，Exp如下。花了4个小时吧。\n\n```c\n#include <stdio.h>\n#include <stdlib.h> \n#include <stdint.h>\n\n//密钥在动调的时候取出就行了。\nuint8_t key[128] = {64, 219, 65, 24, 40, 193, 230, 145, 203, 169, 18, 125, 170, 192, 199, 159, 157, 38, 46, 6, 157, 90, 123, 166, 146, 16, 175, 171, 169, 249, 251, 160, 135, 168, 171, 240, 25, 222, 93, 91, 231, 26, 172, 17, 30, 69, 73, 82, 201, 42, 246, 134, 66, 49, 108, 95, 150, 236, 129, 102, 94, 24, 255, 27, 69, 188, 182, 179, 250, 225, 54, 233, 113, 90, 12, 164, 92, 131, 61, 232, 59, 85, 99, 174, 230, 155, 235, 1, 32, 36, 55, 178, 65, 89, 177, 99, 76, 98, 54, 100, 188, 139, 221, 165, 68, 157, 191, 115, 242, 75, 56, 38, 65, 13, 123, 99, 220, 204, 61, 124, 51, 252, 15, 10, 176, 107, 255, 109};\n\n\n//取出就行了。\nuint8_t map[256] = {214, 144, 233, 254, 204, 225, 61, 183, 22, 182, 20, 194, 40, 251, 44, 5, 43, 103, 154, 118, 42, 190, 4, 195, 170, 68, 19, 38, 73, 134, 6, 153, 156, 66, 80, 244, 145, 239, 152, 122, 51, 84, 11, 67, 237, 207, 172, 98, 228, 179, 28, 169, 201, 8, 232, 149, 128, 223, 148, 250, 117, 143, 63, 166, 71, 7, 167, 252, 243, 115, 23, 186, 131, 89, 60, 25, 230, 133, 79, 168, 104, 107, 129, 178, 113, 100, 218, 139, 248, 235, 15, 75, 112, 86, 157, 53, 30, 36, 14, 94, 99, 88, 209, 162, 37, 34, 124, 59, 1, 33, 120, 135, 212, 0, 70, 87, 159, 211, 39, 82, 76, 54, 2, 231, 160, 196, 200, 158, 234, 191, 138, 210, 64, 199, 56, 181, 163, 247, 242, 206, 249, 97, 21, 161, 224, 174, 93, 164, 155, 52, 26, 85, 173, 147, 50, 48, 245, 140, 177, 227, 29, 246, 226, 46, 130, 102, 202, 96, 192, 41, 35, 171, 13, 83, 78, 111, 213, 219, 55, 69, 222, 253, 142, 47, 3, 255, 106, 114, 109, 108, 91, 81, 141, 27, 175, 146, 187, 221, 188, 127, 17, 217, 92, 65, 31, 16, 90, 216, 10, 193, 49, 136, 165, 205, 123, 189, 45, 116, 208, 18, 184, 229, 180, 176, 137, 105, 151, 74, 12, 150, 119, 126, 101, 185, 241, 9, 197, 110, 198, 132, 24, 240, 125, 236, 58, 220, 77, 32, 121, 238, 95, 62, 215, 203, 57, 72};\n\n\nuint32_t sub_1400012F0(uint32_t a1, int16_t a2){\n    for(int16_t i=0;i<a2;i++){\n        a1 = a1 / 0x80000000 + 2 * a1;\n    }\n    return a1;\n}\n\nuint32_t sub_140001340(uint32_t a1){\n    return sub_1400012F0(a1,24) ^ sub_1400012F0(a1, 18) ^ sub_1400012F0(a1, 10) ^ sub_1400012F0(a1, 2) ^ a1;\n}\n\n//完全照抄加密时的逻辑就行，这里是求异或值的地方，我们的目标是要找出一样的异或值，所以要和加密时的逻辑一样。\nuint32_t get_xor(uint32_t seed){\n    uint32_t t = map[(uint8_t)seed] + (map[(uint8_t)(seed>>8)] << 8) + (map[(uint8_t)(seed>>16)] << 16) + (map[(uint8_t)(seed>>24)] << 24);\n    return sub_140001340(t);\n\n}\n\n\n//仿照加密过程，其实就是一个异或操作，只是这个异或的密钥经过复杂的运算得出的\nvoid  decrypt(uint32_t *enc, uint8_t *key){\n    uint32_t *k = (uint32_t*)key;\n    for(int i=31;i>=0;i--){\n        enc[i%4] ^= get_xor(k[i] ^ enc[(i+3)%4] ^ enc[(i+2)%4] ^ enc[(i+1)%4]);\n    }\n}\n\n\nint main(){\n    \n    //密文最好是调试的时候看，断点下在比较的地方。\n    uint32_t enc[] = \t\t\t\t{0xA8F44759,0xCDB824F2,0x32FB3C01,0x42BEFFE1,0x3EC30B40,0xE094AA46,0x2AEA2B,0x362C0888};\n    uint32_t enc1[8];\n    \n    \n    for(int i=0;i<8;i++){\n        int j = i % 4;\n        enc1[i] = enc[(i/4)*4 + (3-j)];\n    }\n\n    for(int i=0;i<2;i++){\n        decrypt(enc1+i*4,key);\n    }\n\n    for(int i=0;i<8;i++){\t\t\t\t\t//这里开始是反的，还搞错了。字符串的大小端总是让我摸不着头脑。\n        printf(\"%c\",enc1[i]&0xFF);\n        printf(\"%c\",enc1[i]>>8&0xFF);\n        printf(\"%c\",enc1[i]>>16&0xFF);\n        printf(\"%c\",enc1[i]>>24&0xFF);\n    }\n\n    return 0;\n}\n```\n\n------\n\n# 萝卜子的螃蟹\n\n​\t\tRUST语言程序，可以使用IDA反编译打开，难点就是反编译代码很难看，需要配合动调确定程序的运行逻辑。有点累了，改天再写。\n\n​\t动调还是经验太少了，趁此机会，好好照着WP学习一下动调的经验。下面只总结了收获的经验，完整WP都有。\n\n\n\n- #### 通过提示字符串的交叉引用找到程序的主要逻辑函数。\n\n- #### 看到如下图所示的这种乱七八糟的函数名，看到如此难以读懂的伪代码，先单步调试找到input函数。并且，根据input函数中的参数值，找到存储输入flag的地址。参数是指针，要通过G键跳转到对应的内存地址处查看。\n\n![image-20250522122253781](/pictures/ISCTF2024/image-20250522122253781.png)\n\n- #### 找到INPUT之后，再酌情分析程序还有哪些重要部分。然后忽略其他操作，除开与输入flag相关的部分，其他都可以不管，需要什么可以靠动调直接读取值。\n\n- #### 看到长度比较和赋值部分，这一大堆数据很可能就是密文，但是不能着急，密文也是可以做处理的，不到最后比对的时候都不要完全确定密文。\n\n![image-20250522122710905](/pictures/ISCTF2024/image-20250522122710905.png)\n\n- #### 看到下面前两个函数都是对密文进行操作，v35->v40->v36，不用管。我们只需要锁定住我们的输入即可，v29就是输入字符串的指针，我们看到v29只在405F80参数处出现了，而且下面就是比对了。所以该题应该只在这个函数里面进行了处理。\n\n![image-20250522122830052](/pictures/ISCTF2024/image-20250522122830052.png)\n\n- #### 下面的比对操作，需要简单跟踪变量值确定变量代表的含义，在进入406AA0时下断点取出密文值即可。\n\n![image-20250522123228352](/pictures/ISCTF2024/image-20250522123228352.png)\n\n- #### 重点是怎么知道对输入的操作是什么样子的，在上面的v29处找到输入的flag，打下内存断点，这样每当程序去访问这个地址时就会触发断点，分别我们分析程序对flag做了什么处理。具体操作就是在数据头摁下F2下断点，然后填下数据长度就行。\n\n![image-20250522123655696](/pictures/ISCTF2024/image-20250522123655696.png)\n\n- #### 之后就可以看情况F9策马奔腾了，注意ntdll有时候回访问这个内存地址的，我们可以通过查看断点表，随时开启或关闭断点，记得配合程序断点，关闭内存断点，直接F9来跳过ntdll的访问，我们只关心主要逻辑对该地址的访问。跳出ntdll后，再开启内存断点。\n\n![image-20250522123845878](/pictures/ISCTF2024/image-20250522123845878.png)\n\n![image-20250522123934610](/pictures/ISCTF2024/image-20250522123934610.png)\n\n\n\n​\t最后复现WP，自己手动找到数据，解密成功。\n\n​\t通过本题，我学习到了内存断点找加密操作的方法，发现了通过G键进行内存跳转的功能。\n\n```python\ndata = \"A\" * 52\nenc_data = [105, 170, 63, 98, 219, 177, 5, 252, 176, 134, 189, 146, 177, 222, 70, 219, 183, 31, 150, 151, 6, 229, 101, 231, 47, 223, 159, 159, 159, 228, 116, 102, 218, 205, 139, 51, 99, 178, 172, 136, 66, 138, 47, 12, 150, 246, 201, 34, 207, 27, 86, 152]\n\nxor_key = []\nfor i in range(52):\n    xor_key.append(enc_data[i] ^ ord(data[i]))\n\n\nenc_flag =[97, 184, 61, 119, 220, 139, 54, 200, 130, 179, 163, 226, 196, 192, 106, 255, 155, 110, 165, 175, 20, 197, 66, 195, 49, 242, 191, 144, 185, 250, 19, 1, 196, 245, 165, 7, 125, 179, 159, 172, 92, 140, 94, 34, 179, 232, 200, 60, 220, 57, 35, 164]\nflag = \"\"\n\nfor i in range(52):\n    flag += chr(enc_flag[i] ^ xor_key[i])\n\nprint(flag)\n```\n","tags":["复现WP"],"categories":["CTF"]},{"title":"BaseCTF2024","url":"/2025/06/04/BaseCTF/BaseCTF2024_RE/","content":"\n\n\n------\n\n> **UPX mimi：**\n>\n> ​\t初步接触到了UPX加壳保护的知识和对应的脱壳工具，这是一种“压缩”保护壳，即将源程序代码进行压缩，然后配上解压缩代码，组成新的程序，即“UPX解压代码”+“压缩的源文件”。在程序启动时，会先执行UPX的解压代码，得到解压后的源文件，然后将控制流转移到源文件。\n\n> **ez_maze:**\n>\n> ​\t最基础的迷宫题目，从IDA中可以直接看到迷宫，人工就能得到路径。\n\n> **BasePlus:**\n>\n> ​\t无保护，直接拖入IDA，考察基础的阅读代码的能力，加密函数为Base64的一点点变化，对Base64加密后继续异或一下。很基础。第一次认真搓Base64的c语言代码，收获不少。\n\n> **Ez_Xor:**\n>\n> ​\t复习了大小端序的知识。\n>\n> ​\t“小端序”：低位有效字节保存在小地址。如0xDEADBEEF在内存中的顺序是（小地址）EF BE AD DE（大地址）。“大端序”相反。\n>\n> ​\t本题就是简单的流加密，生成密钥流然后加密。对应解密即可。\n\n> **UPX:**\n>\n> ​\t有壳，直接脱壳报错。学习到了，改标志位来保护加壳程序的手段，我们的反制操作就是打开文件，将对应的标志位从小写改回大写。之后就可以正常脱壳了。\n>\n> ​\t拖入IDA后，考察的是换表的Base64。唯一需要注意的点就是因为题目源码是C语言，在IDA字符串显示中给双引号全面加了转义符号的，不要搞错了。\n\n![image-20250425170632940](/pictures/BaseCTF2024/image-20250425170632940.png)\n\n> **lk:**\n>\n> ​\t比较大的线性方程组，考察python的z3solver库使用。\n\n> **喝杯下午茶：**\n>\n> ​\t标准的Tea加密，第一次使用C语言实现了该算法，收获不少。\n\n> **Ezpy:**\n>\n> ​\t考察python打包出的EXE程序。反编译出源码。\n>\n> ​\t再考察RC4加密。\n\n> **最简单的编码：**\n>\n> ​\t无保护技术，纯考验伪代码的阅读水平，耐下心来分析就好了。\n\n> **neuro爱数学：**\n>\n> ​\t\n\n> **RivestCipher:**\n>\n> ​\t考察标准RC4加密算法。\n\n> **ezAndroid:**\n>\n> ​\t收获到了逆向apk安装包的软件jadx，接触到了so文件（共享库）逆向，是一些没有接触过的操作。又要读奇怪的代码。唉！\n\n------\n\n# **UPX PRO MAX**\t\n\n​\t直接运行EXE程序，会出现下图的显示。\n\n![image-20250506132159230](/pictures/BaseCTF2024/image-20250506132159230.png)\n\nDIE也看到UPX壳。\n\n![image-20250506132311405](/pictures/BaseCTF2024/image-20250506132311405.png)\n\n直接上工具是不行的啊，报错了。\n\n跟着WP学习——**利用ESP定律x64dbg手脱UPX壳**。\n\n> “ESP定律”也称“堆栈平衡定律”\n>\n> 由于在程序自解密或者自解压过程中, 多数壳会先将当前寄存器状态压栈, 如使用`pushad`, 而在解压结束后, 会将之前的寄存器值出栈, 如使用`popad`. 因此在寄存器出栈时, 往往程序代码被恢复, 此时硬件断点触发（这就是我们要下硬件断点的原因），然后在程序当前位置, 只需要一些单步操作, 就会到达正确的OEP位置。\n>\n> 1. 程序刚载入开始 `pushad/pushfd`\n> 2. 将全部寄存器压栈后就设对 ESP 寄存器设硬件断点\n> 3. 运行程序, 触发断点\n> 4. 删除硬件断点开始分析\n\n在x64dbg中，F9两次后来到这个压栈的操作处。接着单步运行一次，看到ESP的值为红色，代表其值被修改了，我们右键选择“在内存窗口中转到”，然后在栈中打下硬件断点。\n\n![image-20250506133643545](/pictures/BaseCTF2024/image-20250506133643545.png)\n\n![image-20250506134057787](/pictures/BaseCTF2024/image-20250506134057787.png)\n\n![image-20250506134312068](/pictures/BaseCTF2024/image-20250506134312068.png)\n\n之后F9，触发断点后单步运行几下就找到OEP了，即程序入口点。可以看到这个地方的多次pop指令。\n\n根据wp中的提示，0X41CF65跳转的地方就是程序的入口点了。应该是了。\n\n![image-20250506134519180](/pictures/BaseCTF2024/image-20250506134519180.png)\n\n下面根据WP中的操作介绍一步步就可以脱出无壳的程序了，叫UPX_PRO_MAX_dump_SCY.exe。\n\n> `scylla`插件：在 x64dbg 中内置的 Scylla 插件可用于 dump 进程，**即将内存中的程序数据转储到磁盘上**，形成一个可执行文件的副本，方便后续对程序的分析和研究。\n>\n> `IAT AutoSearch`： 在分析经过加壳或加密的程序时，程序的导入表可能被破坏或隐藏，IAT AutoSearch 可以自动扫描内存或代码段，寻找可能的导入函数地址，帮助逆向工程师快速找到程序所调用的外部函数。\n\n> 程序的导入表是程序的关键数据结构，用于列出程序运行时需要从其他模块（通常是 DLL）中导入的函数和变量。以下是导入表的详细介绍：\n>\n>   * 导入表是程序的一个数据结构，它包含了一系列的引用信息，指向程序运行时需要调用的外部函数和变量所在的模块及其具体地址。\n>\n> \n>\n>   * **便于调用外部模块功能** ：程序通常不会将所有功能都自己实现，而是通过调用系统或第三方提供的 DLL 中的函数和变量来实现复杂的功能。导入表就像一个目录，告诉操作系统程序需要从哪些 DLL 中使用哪些功能。\n>   * **便于程序的动态链接** ：它支持程序的动态链接机制。程序在编译时不会直接将 DLL 中的函数和变量代码包含进来，而是在运行时装载所需的 DLL，并通过导入表找到具体的函数和变量地址，这样可以减少程序自身的体积，同时方便对 DLL 进行更新和共享。\n>\n> \n>\n>   * **导入模块名表** ：存放了程序需要导入的各个模块的名字，比如 “kernel32.dll”“user32.dll” 等。\n>   * **导入函数名表** ：对于每个导入模块，都有一个对应的导入函数名表，列出了从该模块中导入的具体函数名称，如 “MessageBoxA”“CreateFileA” 等。\n>   * **导入函数地址表（IAT）** ：在程序运行时，操作系统会将每个导入函数的实际内存地址填入这个表中，程序通过这个表中的地址来调用相应的函数。\n\n脱壳后的程序导入IDA中，很清晰的加密逻辑。直接逆向写脚本就行。\n\n![image-20250506141212651](/pictures/BaseCTF2024/image-20250506141212651.png)\n\n但是这里出现了一个坑：`sub_401550`函数其实就是一些加密字符串移动操作，分成几部分存储在几个变量中。但是在验证函数中，全程只用到了a1和a2部分，也就是sub_401550中的a2和a3，不是完整的密文，我觉得这里是中间出了问题，而且这个提取出来的exe程序无法正常运行，IDA中也调试不行，只能静态分析。所以还是有点不靠谱的东西存在。\n\n![image-20250506142108769](/pictures/BaseCTF2024/image-20250506142108769.png)\n\n![image-20250506141429954](/pictures/BaseCTF2024/image-20250506141429954.png)\n\n------\n\n# EZ_VM\n\n​\t基本信息：`pyinstaller`打包的`ELF64`位程序，使用`pydumpck`解包得到`py`文件。\n\n​\t加密逻辑在`what.py`文件，打开，里面函数名称和变量名都是用数字代替的，还有一些小错误，比如本来的“while”语句变成“if”，需要改过来。\n\n​\t代码的逻辑就是：分别使用一个数组变量和一个字典来模拟一个栈和内存，使用变量模拟寄存器，通过数组的`pop`和`push`模拟栈的操作，使用函数定义各种汇编指令，如push、pop、add、sub等等，都是统一操作数长度。就这样定义了一个能够通过汇编指令进行运行的“虚拟机”，里面存在出题人预先写好的一段静态汇编代码，作为加密函数。\n\n> 1. 我们首要任务就是给源python代码进行重命名和明显的错误纠正。（需要足够熟悉汇编指令，起码的要知道。转移指令还没那么重要，因为我们不关心程序的执行流程，我们只需要注意密文的来处即可。）\n> 2. 然后在其中插入print调试语句输出操作指令、栈和内存的值，锁定密文的存储地方，观察加密方法。\n> 3. 根据加密方法写逆向脚本。\n\n​\t\n\n```python\nenc_flag = [\n    35,\n    18,\n    22,\n    38,\n    23,\n    18,\n    61,\n    25,\n    83,\n    4,\n    0,\n    5,\n    5,\n    83,\n    95,\n    20,\n    29,\n    83,\n    82,\n    1,\n    29,\n    25,\n    0,\n    0,\n    81,\n    72,\n    76,\n    85,\n    3,\n    85,\n    79,\n    73,\n    83,\n    0,\n    15,\n    9,\n    85,\n    7,\n    80,\n    82,\n    0,\n    5,\n    84,\n    77,\n    130]\n\n\nclass Opcode:\n    vm_push = 240\n    vm_pop = 241\n    vm_and = 242\n    vm_or = 243\n    vm_not = 244\n    vm_xor = 245\n    vm_jmp = 246\n    vm_jz = 247\n    vm_label = 248\n    vm_strlen = 249\n    vm_loadchar = 250\n    vm_store = 251\n    vm_load = 252\n    vm_add = 253\n    vm_sub = 254\n\n\nclass VM:\n\n    def __init__(self):\n        self.stack = []\n        self.bytecode = []\n        self.pc = 0\n        self.labels = {}\n        self.memory = {}\n\n    def push(self, value):\n        self.stack.append(value)\n\n    def pop(self):\n        if not self.stack:\n            raise IndexError('something wrong..')\n        return self.stack.pop()\n\n    def _scan_labels(self):\n        labels = {}\n        pc = 0\n        while pc < len(self.bytecode):\n            if self.bytecode[pc] == Opcode.vm_label:\n                label_name = self.bytecode[pc + 1]\n                labels[label_name] = pc\n                pc += 2\n            else:\n                pc += 1\n\n        return labels\n\n    def vm_and(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b & a)\n\n    def vm_or(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b | a)\n\n    def vm_not(self):\n        b = self.pop()\n        self.push(~b)\n\n    def vm_xor(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b ^ a)\n\n    def vm_jmp(self):\n        label_name = self.bytecode[self.pc]\n        self.pc = self.labels[label_name]\n\n    def vm_jz(self):\n        label_name = self.bytecode[self.pc]\n        self.pc += 1\n        a = self.pop()\n        b = self.pop()\n        if a == b:\n            self.pc = self.labels[label_name]\n\n    def vm_strlen(self):\n        string = self.pop()\n        self.push(len(string))\n\n    def vm_loadchar(self):\n        string = self.pop()\n        index = self.pop()\n        self.push(ord(string[index]))\n\n    def vm_store(self):\n        value = self.pop()\n        key = self.bytecode[self.pc]\n        if key == 'r':\n            if key not in self.memory:\n                self.memory[key] = []\n            self.memory[key].append(value)\n        else:\n            self.memory[key] = value\n        self.pc += 1\n\n    def vm_load(self):\n        key = self.bytecode[self.pc]\n        self.push(self.memory[key])\n        self.pc += 1\n\n    def vm_add(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b + a)\n\n    def vm_sub(self):\n        a = self.pop()\n        b = self.pop()\n        self.push(b - a)\n\n    def run(self, bytecode):\n        self.bytecode = bytecode\n        self.pc = 0\n        self.labels = self._scan_labels()\n        while self.pc < len(self.bytecode):\n            opcode = self.bytecode[self.pc]\n            self.pc += 1\n            if opcode == Opcode.vm_push:\n                value = self.bytecode[self.pc]\n                self.pc += 1\n                self.push(value)\n            elif opcode == Opcode.vm_pop:\n                self.pop()\n            elif opcode == Opcode.vm_and:\n                self.vm_and()\n            elif opcode == Opcode.vm_or:\n                self.vm_or()\n            elif opcode == Opcode.vm_not:\n                self.vm_not()\n            elif opcode == Opcode.vm_xor:\n                self.vm_xor()\n            elif opcode == Opcode.vm_jmp:\n                self.vm_jmp()\n            elif opcode == Opcode.vm_jz:\n                self.vm_jz()\n            elif opcode == Opcode.vm_label:\n                self.pc += 1\n            elif opcode == Opcode.vm_strlen:\n                self.vm_strlen()\n            elif opcode == Opcode.vm_loadchar:\n                self.vm_loadchar()\n            elif opcode == Opcode.vm_store:\n                self.vm_store()\n            elif opcode == Opcode.vm_load:\n                self.vm_load()\n            elif opcode == Opcode.vm_add:\n                self.vm_add()\n            elif opcode == Opcode.vm_sub:\n                self.vm_sub()\n            else:\n                raise ValueError('something wrong')\n            print(f\"pc: {self.pc}| opcode: {get_opcode_name(opcode)}, stack: {self.stack}, memory: {self.memory}\")\n\n    def encrypt(self, serial):\n        bytecode = [\n            Opcode.vm_push, serial,\n            Opcode.vm_strlen,\n            Opcode.vm_store, 'l1',\n            Opcode.vm_push, 0,\n            Opcode.vm_store, 'i',\n            Opcode.vm_label, 's',\n            Opcode.vm_load, 'l1',\n            Opcode.vm_push, 1,\n            Opcode.vm_sub,\n            Opcode.vm_load, 'i',\n            Opcode.vm_jz, 'e',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, 1,\n            Opcode.vm_add,\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_xor,\n            Opcode.vm_store, 'r',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, 1,\n            Opcode.vm_add,\n            Opcode.vm_store, 'i',\n            Opcode.vm_jmp, 's',\n            Opcode.vm_label, 'e',\n            Opcode.vm_load, 'i',\n            Opcode.vm_push, serial,\n            Opcode.vm_loadchar,\n            Opcode.vm_push, 255,\n            Opcode.vm_xor,\n            Opcode.vm_store, 'r'\n        ]\n        self.run(bytecode)\n        enc = self.memory['r']\n        return enc\n\ndef get_opcode_name(opcode):\n    for name, value in Opcode.__dict__.items():\n        if value == opcode:\n            return name\n    return None\n\nvm = VM()\ntest_flag = \"BaseCTF{VM_is_awesome}\"\nenc = vm.encrypt(test_flag)\nprint(f\"encrypted test_flag: {enc}\")\nprint(f\"original flag: {enc_flag}\")\n```\n\n根据WP提示重命名后，观察传输的调试信息。看一下开头和结尾就行。\n\n![image-20250509160138052](/pictures/BaseCTF2024/image-20250509160138052.png)\n\n![image-20250509160305470](/pictures/BaseCTF2024/image-20250509160305470.png)\n\n​\t所以猜到加密逻辑是：从前往后，相邻两位异或，尾部和255异或。\n\n这里给出我的解密脚本。\n\n```python\nenc_flag = [35, 18, 22, 38, 23,  18,61, 25,  83,4,0, 5, 5,83,95,  20,  29, 83,82,  1, 29, 25, 0,0,81,72,76,85,3,85,79,73,83,0,15,9,85,7,80,82,0,5,84,77,130,255]\n\nflag = \"\"\nfor i in range(len(enc_flag)):\n    char = enc_flag[i]\n    for j in range(i+1, len(enc_flag)):\n        char = char ^ enc_flag[j]\n\n    flag += chr(char)\n\nprint(flag)\n```\n\n------\n\n# Microgame\n\n​\t不理解，不会游戏逆向，后面得学啊。专门做了一个CE的学习。\n\n​\t学习完CE，专门出个WP来做。\n\n------\n\n# neuro爱数学\n\n​\t直接打开IDA看看`main`函数，程序无壳，就是考察数学问题。\n\n![image-20250512120720066](/pictures/BaseCTF2024/image-20250512120720066.png)\n\n![image-20250512130852846](/pictures/BaseCTF2024/image-20250512130852846.png)\n\n![image-20250512130953971](/pictures/BaseCTF2024/image-20250512130953971.png)\n\n```c\n#include<stdio.h>\n#include<stdint.h>\n#include<intrin.h>\n\nint main(){\t\t\t\t\t\t\t\t//注意：各个变量和函数的类型是关键，不能搞错，需要对照IDA伪代码\n    int64_t v5=0x400C0210000001;\t\t\t//这个值是固定的，但是需要动调程序得到这个值。\n\n    for(int i=-60; i<=59; i++){\n        if(i == 44 || i == 58){\n            printf(\"符合条件的i值位：%d/n\", i);\n            continue;\n        }\n\n        unsigned int v12 = (unsigned int)(i + 37);\n        if(v12 <= 54 && _bittest64((int64_t*)&v5,(unsigned int)v12) != 0){\n            printf(\"符合条件的i值为：%d/n\", i);\n        }\n\n    }\n\n    return 0;\n}\n\n```\n\n![image-20250512131328904](/pictures/BaseCTF2024/image-20250512131328904.png)\n\n然后使用python脚本展开多项式得到系数。\n\n````python\nfrom sympy import symbols, expand\n\n# 定义符号变量\nx = symbols('x')\n\n# 构造多项式\npolynomial = (x - 44) * (x - 58) * (x - 5) * (x + 37) * (x - 17) * (x + 9) * (x - 6) * (x + 4)\n\n# 展开多项式\nexpanded_polynomial = expand(polynomial)\n\n# 提取并打印系数\nstandard_form = expanded_polynomial.as_poly()  # 获取标准形式的多项式\ncoefficients = standard_form.all_coeffs()    # 获取所有系数\n\n# 打印系数逆序（从常数项到最高次项）。因为正常是从高次项到低次项。\nprint(coefficients[::-1])\n#[-1733624640, 134045088, 122783468, -12168520, -1364231, 121272, -358, -80, 1]\n````\n\n![测试图片](/pictures/BaseCTF2024/image-20250512131708984.png)\n\n\n\n\n\n\n\n\n\n\n\n\n\n","tags":["复现WP"],"categories":["CTF"]},{"title":"标签","url":"/tags/index.html"},{"title":"关于","url":"/about/index.html","content":"\n\n\n"},{"url":"/json/music.json","content":"[\n  {\n    \"name\": \"青花瓷\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002eFUFm2XYZ7z_2.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/青花瓷/青花瓷.lrc\"\n  },\n  {\n    \"name\": \"稻香\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/稻香/稻香.lrc\"\n  },\n  {\n    \"name\": \"晴天\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/晴天/晴天.lrc\"\n  },\n  {\n    \"name\": \"七里香\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/七里香/七里香.lrc\"\n  },\n  {\n    \"name\": \"花海\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/花海/花海.lrc\"\n  },\n  {\n    \"name\": \"反方向的钟\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/反方向的钟/反方向的钟.lrc\"\n  },\n  {\n    \"name\": \"兰亭序\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/兰亭序/兰亭序.lrc\"\n  },\n  {\n    \"name\": \"说好的辛福呢\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的辛福呢.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002Neh8l0uciQZ_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/说好的辛福呢/说好的幸福呢.lrc\"\n  },\n  {\n    \"name\": \"等你下课 (with 杨瑞代)\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003bSL0v4bpKAx_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.1/周杰伦/等你下课/等你下课.lrc\"\n  },\n  {\n    \"name\": \"我落泪情绪零碎\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000bviBl4FjTpO_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/我落泪情绪零碎/我落泪情绪零碎.lrc\"\n  },\n  {\n    \"name\": \"听妈妈的话\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.2/听妈妈的话/听妈妈的话.lrc\"\n  },\n  {\n    \"name\": \"明明就\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003Ow85E3pnoqi_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/明明就/明明就.lrc\"\n  },\n  {\n    \"name\": \"我是如此相信\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000001hGx1Z0so1YX_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music-jay@1.0.1/我是如此相信/我是如此相信.lrc\"\n  },\n  {\n    \"name\": \"发如雪\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M0000024bjiL2aocxT_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/发如雪/发如雪.lrc\"\n  },\n  {\n    \"name\": \"以父之名\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000MkMni19ClKG_3.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/以父之名/以父之名.lrc\"\n  },\n  {\n    \"name\": \"园游会\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.flac\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000003DFRzD192KKD_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.3/园游会/园游会.lrc\"\n  },\n  {\n    \"name\": \"本草纲目\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000002jLGWe16Tf1H_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/本草纲目/本草纲目.lrc\"\n  },\n  {\n    \"name\": \"龙卷风\",\n    \"artist\": \"周杰伦\",\n    \"url\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.mp3\",\n    \"cover\": \"https://y.qq.com/music/photo_new/T002R300x300M000000f01724fd7TH_1.jpg?max_age=2592000\",\n    \"lrc\": \"https://npm.elemecdn.com/anzhiyu-music@1.0.4/龙卷风/龙卷风.lrc\"\n  }\n]"},{"title":"分类","url":"/categories/index.html"},{"title":"音乐馆","url":"/music/index.html"},{"url":"/static/js/index_media.js","content":"// ======================= 横竖屏自适应背景媒体加载器 =======================\nlet lastOrientation = null; // 记录上一次的方向状态\n\n// ================= 新增滚动渐变效果函数 =================\nfunction initScrollFadeEffect() {\n  const mediaContainer = document.getElementById('home-media-container');\n  if (!mediaContainer) return;\n  \n  const mediaElement = mediaContainer.querySelector('.home-media');\n  if (!mediaElement) return;\n  \n  // 节流函数优化性能\n  function throttle(func, limit) {\n    let lastFunc, lastRan;\n    return function() {\n      const context = this;\n      const args = arguments;\n      if (!lastRan) {\n        func.apply(context, args);\n        lastRan = Date.now();\n      } else {\n        clearTimeout(lastFunc);\n        lastFunc = setTimeout(function() {\n          if ((Date.now() - lastRan) >= limit) {\n            func.apply(context, args);\n            lastRan = Date.now();\n          }\n        }, limit - (Date.now() - lastRan));\n      }\n    }\n  }\n\n  // 处理滚动时的透明度变化\n  function handleScrollFade() {\n    const scrollY = window.scrollY;\n    const windowHeight = window.innerHeight;\n    \n    // 计算透明度：从1（完全不透明）到0（完全透明）\n    // 当滚动到一屏高度时，透明度变为0\n    let opacity = 1 - (scrollY / windowHeight);\n    opacity = Math.max(0, Math.min(1, opacity)); // 限制在0-1范围\n    \n    mediaElement.style.opacity = opacity;\n  }\n\n  // 节流处理滚动事件（每50ms检查一次）\n  const throttledScrollHandler = throttle(handleScrollFade, 50);\n  \n  // 添加滚动监听\n  window.addEventListener('scroll', throttledScrollHandler);\n  \n  // 初始化时执行一次\n  handleScrollFade();\n  \n  // 存储当前滚动处理器以便后续移除\n  return throttledScrollHandler;\n}\n\n\n// ================= 滚动渐变效果函数结束 =================\n\n// ================= 新增底部遮罩层控制函数 =================\nfunction initScrollMaskEffect() {\n  const mediaContainer = document.getElementById('home-media-container');\n  if (!mediaContainer) return;\n  \n  // 节流函数优化性能\n  function throttle(func, limit) {\n    let lastFunc, lastRan;\n    return function() {\n      const context = this;\n      const args = arguments;\n      if (!lastRan) {\n        func.apply(context, args);\n        lastRan = Date.now();\n      } else {\n        clearTimeout(lastFunc);\n        lastFunc = setTimeout(function() {\n          if ((Date.now() - lastRan) >= limit) {\n            func.apply(context, args);\n            lastRan = Date.now();\n          }\n        }, limit - (Date.now() - lastRan));\n      }\n    }\n  }\n\n  // 处理滚动时的遮罩变化\n  function handleScrollMask() {\n    const scrollY = window.scrollY;\n    const windowHeight = window.innerHeight;\n    \n    // 计算遮罩高度（0-100%）\n    let maskHeight = (scrollY / windowHeight) * 100;\n    maskHeight = Math.min(100, Math.max(0, maskHeight));\n    \n    // 动态设置遮罩层高度\n    mediaContainer.style.setProperty('--mask-height', `${maskHeight}%`);\n  }\n\n  // 节流处理滚动事件（每50ms检查一次）\n  const throttledScrollHandler = throttle(handleScrollMask, 50);\n  \n  // 添加滚动监听\n  window.addEventListener('scroll', throttledScrollHandler);\n  \n  // 初始化时执行一次\n  handleScrollMask();\n  \n  // 返回处理器以便后续移除\n  return throttledScrollHandler;\n}\n\n\nfunction initResponsiveBackground() {\n  const mediaContainer = document.getElementById('home-media-container');\n  if (!mediaContainer) {\n    console.error('[背景加载器] 未找到媒体容器元素');\n    return;\n  }\n\n  // 检测当前屏幕方向\n  const currentIsPortrait = window.innerHeight > window.innerWidth;\n  const currentOrientation = currentIsPortrait ? 'portrait' : 'landscape';\n  \n  // 如果方向未改变，则直接返回\n  if (lastOrientation === currentOrientation) {\n    console.log('[背景加载器] 方向未改变，无需重新加载');\n    return;\n  }\n  \n  // 更新方向记录\n  lastOrientation = currentOrientation;\n  console.log(`[背景加载器] 方向变化: ${currentOrientation}`);\n\n  // 清除现有媒体元素和加载动画\n  const existingMedia = mediaContainer.querySelector('.home-media');\n  const existingLoader = mediaContainer.querySelector('.custom-loader');\n  if (existingMedia) existingMedia.remove();\n  if (existingLoader) existingLoader.remove();\n\n  // 根据方向选择资源\n  let mediaSrc, posterSrc, mediaType;\n  if (currentIsPortrait) {\n    mediaSrc = mediaContainer.dataset.portraitVideo || mediaContainer.dataset.portraitImg;\n    posterSrc = mediaContainer.dataset.portraitPoster;\n    mediaType = mediaContainer.dataset.portraitVideo ? 'video' : 'img';\n  } else {\n    mediaSrc = mediaContainer.dataset.landscapeVideo || mediaContainer.dataset.landscapeImg;\n    posterSrc = mediaContainer.dataset.landscapePoster;\n    mediaType = mediaContainer.dataset.landscapeVideo ? 'video' : 'img';\n  }\n\n  if (!mediaSrc) {\n    console.error('[背景加载器] 未找到有效媒体资源');\n    return;\n  }\n\n  console.log(`[背景加载器] 使用资源: ${mediaSrc} (类型: ${mediaType})`);\n\n  // 创建媒体元素\n  const mediaElement = document.createElement(mediaType);\n  mediaElement.className = 'home-media';\n  mediaElement.style.cssText = 'width:100%;height:100%;object-fit:cover';\n  \n  // ================= 设置初始透明度 =================\n  mediaElement.style.opacity = '1';\n  mediaElement.style.transition = 'opacity 0.5s ease';\n  // ================================================\n  \n  // 在媒体容器添加媒体元素后调用效果函数\n  mediaContainer.appendChild(mediaElement);\n  addMediaEffects(mediaElement, mediaType); // 添加新功能\n   \n  console.log('[背景加载器] 媒体元素已创建');\n   \n  // 创建自定义加载动画容器\n  const loaderContainer = document.createElement('div');\n  loaderContainer.className = 'custom-loader';\n  mediaContainer.prepend(loaderContainer);\n  \n  // 创建加载动画元素\n  const loaderElement = document.createElement('div');\n  loaderElement.className = 'loader-animation';\n  \n  // 设置加载动画样式（使用GIF）\n  loaderElement.style.backgroundImage = `url(${posterSrc})`;\n  loaderContainer.appendChild(loaderElement);\n  \n  // 视频特殊处理\n  if (mediaType === 'video') {\n    mediaElement.autoplay = true;\n    mediaElement.muted = true;\n    mediaElement.loop = true;\n    mediaElement.playsInline = true;\n    mediaElement.setAttribute('playsinline', '');\n    mediaElement.setAttribute('webkit-playsinline', '');\n    \n    // 多源支持\n    const source = document.createElement('source');\n    source.src = mediaSrc;\n    source.type = 'video/mp4';\n    mediaElement.appendChild(source);\n    \n    // 处理自动播放限制\n    const playPromise = mediaElement.play();\n    if (playPromise !== undefined) {\n      playPromise.catch(error => {\n        console.warn('[背景加载器] 自动播放被阻止:', error);\n        mediaElement.muted = true;\n        mediaElement.play();\n      });\n    }\n    \n    // 视频加载完成后移除加载动画\n    mediaElement.addEventListener('loadeddata', () => {\n      loaderContainer.style.opacity = '0';\n      setTimeout(() => {\n        if (loaderContainer.parentNode) {\n          loaderContainer.parentNode.removeChild(loaderContainer);\n        }\n      }, 500); // 淡出动画持续时间\n    });\n  } else {\n    mediaElement.src = mediaSrc;\n    mediaElement.loading = 'eager';\n    \n    // 图片加载完成后移除加载动画\n    mediaElement.addEventListener('load', () => {\n      loaderContainer.style.opacity = '0';\n      setTimeout(() => {\n        if (loaderContainer.parentNode) {\n          loaderContainer.parentNode.removeChild(loaderContainer);\n        }\n      }, 500);\n    });\n  }\n\n  // 错误处理\n  mediaElement.onerror = function() {\n    console.error(`[背景加载器] 资源加载失败: ${mediaSrc}`);\n    this.style.display = 'none';\n    \n    // 尝试回退到备用类型\n    console.warn('[背景加载器] 尝试回退到备用媒体');\n    const fallbackType = mediaType === 'video' ? 'img' : 'video';\n    const fallbackSrc = currentIsPortrait ? \n      (mediaContainer.dataset.portraitImg || mediaContainer.dataset.portraitVideo) :\n      (mediaContainer.dataset.landscapeImg || mediaContainer.dataset.landscapeVideo);\n    \n    if (fallbackSrc && fallbackSrc !== mediaSrc) {\n      console.log(`[背景加载器] 使用备用资源: ${fallbackSrc}`);\n      mediaElement.src = fallbackSrc;\n      mediaElement.style.display = 'block';\n    }\n  };\n\n  mediaContainer.appendChild(mediaElement);\n  console.log('[背景加载器] 媒体元素已创建');\n  \n  // ================= 初始化滚动渐变效果 =================\n  initScrollFadeEffect();\n}\n\nfunction addMediaEffects(mediaElement, mediaType) {\n  if (mediaType === 'video') {\n    // 获取当前方向\n    const currentIsPortrait = window.innerHeight > window.innerWidth;\n\n    // 竖屏模式下固定放大105%\n    const baseScale = currentIsPortrait ? 1.05 : 1.2;\n    mediaElement.style.transform = `scale(${baseScale})`;\n    \n    // 检测是否为iOS设备\n    function isIOS() {\n      return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;\n    }\n\n    // 如果是iOS设备，直接禁用所有视差效果\n    if (isIOS()) {\n      console.log('[视差效果] 在iOS设备上，禁用所有视差效果');\n      return; // 直接返回，不初始化任何视差效果\n    }\n    // 1. 添加缩放动画效果\n    mediaElement.style.transform = 'scale(1.2)'; // 初始放大110%\n    mediaElement.style.transition = 'transform 0.5s ease-out';\n    \n    // 在视频加载完成后触发缩放动画\n    mediaElement.addEventListener('loadeddata', () => {\n      // 竖屏模式保持105%缩放，不需要动画\n      if (currentIsPortrait) {\n        mediaElement.style.transform = 'scale(1.05)';\n      } \n      // 横屏模式执行缩放动画到正常大小\n      else {\n        setTimeout(() => {\n          mediaElement.style.transform = 'scale(1)';\n        }, 100);\n      }\n    });\n    \n    // 2. 添加视差效果（鼠标/陀螺仪）\n    const mediaContainer = document.getElementById('page-header');\n    mediaContainer.style.overflow = 'hidden';\n    mediaElement.style.transformOrigin = 'center center';\n    \n    // 视差效果参数\n    const parallaxIntensity = 0.05;\n    const scaleIntensity = 0.05;\n    let isGyroActive = false;\n    \n    // ================= 新增陀螺仪支持 =================\n    // 检测陀螺仪支持\n    function initGyroParallax() {\n      if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {\n        // iOS 13+ 需要权限\n        DeviceOrientationEvent.requestPermission()\n          .then(permissionState => {\n            if (permissionState === 'granted') {\n              setupGyroListeners();\n              isGyroActive = true;\n            }\n          })\n          .catch(console.error);\n      } else if ('DeviceOrientationEvent' in window) {\n        // Android和其他支持设备\n        setupGyroListeners();\n        isGyroActive = true;\n      }\n      \n      return isGyroActive;\n    }\n    \n    // 设置陀螺仪监听\n    function setupGyroListeners() {\n      window.addEventListener('deviceorientation', handleOrientation);\n    }\n    \n    // 处理陀螺仪数据\n    function handleOrientation(event) {\n      // 竖屏模式使用105%基础缩放\n      const baseScaleValue = currentIsPortrait ? 1.05 : 1;\n      if (!isGyroActive) return;\n      \n      // 获取陀螺仪数据（beta: 前后倾斜, gamma: 左右倾斜）\n      const beta = event.beta || 0;  // 前后倾斜（-180到180）\n      const gamma = event.gamma || 0; // 左右倾斜（-90到90）\n      \n      // 将角度转换为百分比偏移（归一化处理）\n      const moveX = (gamma / 90) * parallaxIntensity * 100; // -100% 到 100%\n      const moveY = (beta / 180) * parallaxIntensity * 100; \n      \n      // 应用视差效果\n      mediaElement.style.transform = `\n        translate(${moveX}%, ${moveY}%)\n        scale(${baseScaleValue + scaleIntensity})\n      `;\n    }\n    \n    // ================= 鼠标视差效果 =================\n    function initMouseParallax() {\n      mediaContainer.addEventListener('mousemove', (e) => {\n        const rect = mediaContainer.getBoundingClientRect();\n        const x = (e.clientX - rect.left) / rect.width;\n        const y = (e.clientY - rect.top) / rect.height;\n        \n        const moveX = (x - 0.5) * parallaxIntensity * 100;\n        const moveY = (y - 0.5) * parallaxIntensity * 100;\n        \n        mediaElement.style.transform = `\n          translate(${moveX}%, ${moveY}%)\n          scale(${1 + scaleIntensity})\n        `;\n      });\n      \n      mediaContainer.addEventListener('mouseleave', () => {\n        mediaElement.style.transform = 'scale(1)';\n      });\n    }\n    \n    // ================= 根据设备类型初始化 =================\n    // 检测移动设备\n    const isMobile = /Mobi|Android/i.test(navigator.userAgent);\n    \n    if (isMobile) {\n      // 移动设备优先使用陀螺仪\n      if (!initGyroParallax()) {\n        // 不支持陀螺仪则回退到触摸事件\n        initTouchParallax();\n      }\n    } else {\n      // PC设备使用鼠标事件\n      initMouseParallax();\n    }\n    \n    // ================= 触摸事件回退方案 =================\n    function initTouchParallax() {\n      mediaContainer.addEventListener('touchmove', (e) => {\n        e.preventDefault();\n        const touch = e.touches[0];\n        const rect = mediaContainer.getBoundingClientRect();\n        const x = (touch.clientX - rect.left) / rect.width;\n        const y = (touch.clientY - rect.top) / rect.height;\n        \n        const moveX = (x - 0.5) * parallaxIntensity * 50; // 移动强度减半\n        const moveY = (y - 0.5) * parallaxIntensity * 50;\n        \n        mediaElement.style.transform = `\n          translate(${moveX}%, ${moveY}%)\n          scale(${1 + scaleIntensity * 0.5}) // 缩放强度减半\n        `;\n      });\n      \n      mediaContainer.addEventListener('touchend', () => {\n        mediaElement.style.transform = 'scale(1)';\n      });\n    }\n    \n    // ================= 性能优化 =================\n    // 页面不可见时暂停陀螺仪\n    document.addEventListener('visibilitychange', () => {\n      if (document.visibilityState === 'hidden') {\n        isGyroActive = false;\n      } else if (isMobile) {\n        isGyroActive = initGyroParallax();\n      }\n    });\n  }\n}\n\n// 在initMedia函数中调用新功能\nfunction initMedia() {\n  if (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', function() {\n      initResponsiveBackground();\n      initScrollFadeEffect(); // 添加调用\n    });\n  } else {\n    initResponsiveBackground();\n    initScrollFadeEffect(); // 添加调用\n  }\n}\n\n\n// ======================= 执行入口 =======================\ninitMedia();\n\n// 防抖处理窗口变化\nlet resizeTimer;\nwindow.addEventListener('resize', () => {\n  clearTimeout(resizeTimer);\n  resizeTimer = setTimeout(() => {\n    // 计算当前方向状态\n    const currentIsPortrait = window.innerHeight > window.innerWidth;\n    const currentOrientation = currentIsPortrait ? 'portrait' : 'landscape';\n    \n    // 只有方向实际改变时才执行重载\n    if (lastOrientation !== currentOrientation) {\n      console.log('[背景加载器] 窗口大小变化，重新加载媒体');\n      initResponsiveBackground();\n    } else {\n      console.log('[背景加载器] 窗口大小变化但方向未改变');\n      // ================= 方向未变时重置透明度 =================\n      initScrollFadeEffect();\n    }\n  }, 500);\n});\n\n// 页面可见性变化处理\ndocument.addEventListener('visibilitychange', () => {\n  if (document.visibilityState === 'visible') {\n    const video = document.querySelector('#home-media-container video');\n    if (video && video.paused) {\n      console.log('[背景加载器] 页面恢复可见，重新播放视频');\n      video.play().catch(e => console.warn('视频恢复播放失败:', e));\n    }\n    // ================= 页面恢复可见时重置透明度 =================\n    initScrollFadeEffect();\n  }\n});\n\n// ========== 新增修复代码（直接加在现有代码后面） ========== //\n\n// 1. 缓存恢复检测（核心修复）\nwindow.addEventListener('pageshow', event => {\n  if (event.persisted && location.pathname === '/') {\n    console.log('[修复] 检测到缓存恢复主页，强制重置');\n    lastOrientation = null;\n    initResponsiveBackground();\n    // ================= 缓存恢复时重置透明度 =================\n    setTimeout(initScrollFadeEffect, 300);\n  }\n});\n\n// 2. 路由变化监听（SPA兼容）\nwindow.addEventListener('popstate', () => {\n  if (location.pathname === '/') {\n    console.log('[修复] 检测到返回主页');\n    setTimeout(() => {\n      // 检查媒体元素是否存在\n      const container = document.getElementById('home-media-container');\n      if (!container?.querySelector('.home-media')) {\n        lastOrientation = null;\n        initResponsiveBackground();\n      }\n      // ================= 返回主页时重置透明度 =================\n      initScrollFadeEffect();\n    }, 300); // 延迟确保DOM更新\n  }\n});\n\n// 3. 媒体状态自检（兜底方案）\nfunction checkMediaStatus() {\n  if (location.pathname !== '/') return;\n  \n  const container = document.getElementById('home-media-container');\n  if (!container) return;\n  \n  const hasMedia = container.querySelector('.home-media');\n  if (!hasMedia) {\n    console.log('[修复] 自检发现媒体丢失');\n    lastOrientation = null;\n    initResponsiveBackground();\n  }\n  // ================= 媒体自检时重置透明度 =================\n  initScrollFadeEffect();\n}\n\n// 每0.5秒检查一次（轻量级检测）\nsetInterval(checkMediaStatus, 500);\n\n// 4. 增强错误处理（在initResponsiveBackground函数内修改）\n// 在mediaElement.onerror函数内添加：\nsetTimeout(() => {\n  if (!mediaElement.parentNode) {\n    console.warn('[修复] 尝试完全重建');\n    lastOrientation = null;\n    initResponsiveBackground();\n    // ================= 错误重建时重置透明度 =================\n    setTimeout(initScrollFadeEffect, 500);\n  }\n}, 1000);\n\n\n"},{"url":"/static/css/index_media.css","content":"/* index ，主页面动画*/\n\n  #home-media-container {\n    position: fixed; /* 改为固定定位 */\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    overflow: hidden;\n    z-index: 0;\n    \n    /* 添加底部向上渐变遮罩 */\n    -webkit-mask-image: linear-gradient(to top, transparent 0%, black 0%);\n    mask-image: linear-gradient(to top, transparent 0%, black 0%);\n  }\n  \n  .home-media {\n    position: fixed; /* 同步改为固定定位 */\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    object-fit: cover;\n    \n    /* 添加透明度过渡 */\n    transition: opacity 0.5s ease;\n    opacity: 1;\n  }\n  \n    /* 自定义加载动画容器 */\n  .custom-loader {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    z-index: 10; /* 确保在视频上方 */\n    pointer-events: none; /* 防止阻挡视频交互 */\n    transition: opacity 0.5s ease; /* 淡出动画 */\n  }\n\n  /* 加载动画元素 */\n  .loader-animation {\n    width: 18%;\n    height: 18%;\n    min-width: 128px;\n    min-height: 128px;\n    background-size: contain; /* 保持比例 */\n    background-position: center;\n    background-repeat: no-repeat;\n    animation: pulse 1.5s infinite ease-in-out;\n  }\n\n  /* 呼吸动画效果 */\n  @keyframes pulse {\n    0% { transform: scale(1); opacity: 0.8; }\n    50% { transform: scale(1.1); opacity: 1; }\n    100% { transform: scale(1); opacity: 0.8; }\n  }\n"}]